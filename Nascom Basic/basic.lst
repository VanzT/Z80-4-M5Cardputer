                        ; --------------------------------------
                        ; zasm: assemble "basic.asm"
                        ; date: 2021-05-10 19:16:00
                        ; --------------------------------------


                        ;==================================================================================
                        ; The updates to the original BASIC within this file are copyright Grant Searle
                        ;
                        ; You have permission to use this for NON COMMERCIAL USE ONLY
                        ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                        ;
                        ; http://searle.hostei.com/grant/index.html
                        ;
                        ; eMail: home.micros01@btinternet.com
                        ;
                        ; If the above don't work, please perform an Internet search to see if I have
                        ; updated the web page hosting service.
                        ;
                        ;==================================================================================
                        
                        ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                        ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                        ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                        ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                        ; the original ROM code (checksum A934H). PA
                        
                        ; GENERAL EQUATES
                        
0003:                   CTRLC   .EQU    03H             ; Control "C"
0007:                   CTRLG   .EQU    07H             ; Control "G"
0008:                   BKSP    .EQU    08H             ; Back space
000A:                   LF      .EQU    0AH             ; Line feed
000C:                   CS      .EQU    0CH             ; Clear screen
000D:                   CR      .EQU    0DH             ; Carriage return
000F:                   CTRLO   .EQU    0FH             ; Control "O"
0011:                   CTRLQ	.EQU	11H		        ; Control "Q"
0012:                   CTRLR   .EQU    12H             ; Control "R"
0013:                   CTRLS   .EQU    13H             ; Control "S"
0015:                   CTRLU   .EQU    15H             ; Control "U"
001B:                   ESC     .EQU    1BH             ; Escape
007F:                   DEL     .EQU    7FH             ; Delete
                        
                        ; BASIC WORK SPACE LOCATIONS
                        
2045:                   WRKSPC  .EQU    2045H             ; BASIC Work space
2048:                   USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
204B:                   OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
204C:                   OTPORT  .EQU    WRKSPC+7H           ; Port (p)
204E:                   DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
204F:                   DIV1    .EQU    WRKSPC+0AH           ; <- Values
2053:                   DIV2    .EQU    WRKSPC+0EH           ; <-   to
2057:                   DIV3    .EQU    WRKSPC+12H           ; <-   be
205A:                   DIV4    .EQU    WRKSPC+15H           ; <-inserted
205C:                   SEED    .EQU    WRKSPC+17H           ; Random number seed
207F:                   LSTRND  .EQU    WRKSPC+3AH           ; Last random number
2083:                   INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
2084:                   INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
2086:                   NULLS   .EQU    WRKSPC+41H           ; Number of nulls
2087:                   LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
2088:                   COMMAN  .EQU    WRKSPC+43H           ; Width for commas
2089:                   NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
208A:                   CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
208B:                   LINESC  .EQU    WRKSPC+46H           ; Lines counter
208D:                   LINESN  .EQU    WRKSPC+48H           ; Lines number
208F:                   CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
2091:                   NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
2092:                   BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
2093:                   RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
2096:                   POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
2099:                   PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
209C:                   RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
209F:                   STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
20A1:                   LINEAT  .EQU    WRKSPC+5CH           ; Current line number
20A3:                   BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
20A6:                   BUFFER  .EQU    WRKSPC+61H           ; Input buffer
20AB:                   STACK   .EQU    WRKSPC+66H           ; Initial stack
20F0:                   CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
20F1:                   LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
20F2:                   TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
20F3:                   DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
20F4:                   LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
20F6:                   TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
20F8:                   TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
2104:                   TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
2108:                   STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
210A:                   CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
210C:                   LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
210E:                   DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
2110:                   FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
2111:                   LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
2112:                   READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
2113:                   BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
2115:                   NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
2117:                   ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
2119:                   CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
211B:                   PROGND  .EQU    WRKSPC+0D6H          ; End of program
211D:                   VAREND  .EQU    WRKSPC+0D8H          ; End of variables
211F:                   ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
2121:                   NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
2123:                   FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
2125:                   FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
2129:                   FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
212C:                   FPEXP   .EQU    FPREG+3         ; Floating point exponent
212D:                   SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
212E:                   PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
213B:                   MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
213E:                   PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
21A2:                   STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
                        
                        ; BASIC ERROR CODE VALUES
                        
0000:                   NF      .EQU    00H             ; NEXT without FOR
0002:                   SN      .EQU    02H             ; Syntax error
0004:                   RG      .EQU    04H             ; RETURN without GOSUB
0006:                   OD      .EQU    06H             ; Out of DATA
0008:                   FC      .EQU    08H             ; Function call error
000A:                   OV      .EQU    0AH             ; Overflow
000C:                   OM      .EQU    0CH             ; Out of memory
000E:                   UL      .EQU    0EH             ; Undefined line number
0010:                   BS      .EQU    10H             ; Bad subscript
0012:                   DD      .EQU    12H             ; Re-DIMensioned array
0014:                   DZ      .EQU    14H             ; Division by zero (/0)
0016:                   ID      .EQU    16H             ; Illegal direct
0018:                   TM      .EQU    18H             ; Type miss-match
001A:                   OS      .EQU    1AH             ; Out of string space
001C:                   LS      .EQU    1CH             ; String too long
001E:                   ST      .EQU    1EH             ; String formula too complex
0020:                   CN      .EQU    20H             ; Can't CONTinue
0022:                   UF      .EQU    22H             ; UnDEFined FN function
0024:                   MO      .EQU    24H             ; Missing operand
0026:                   HX      .EQU    26H             ; HEX error
0028:                   BN      .EQU    28H             ; BIN error
                        
0150:                           .ORG    00150H
                        
0150: C35601   [10]     COLD:   JP      STARTB          ; Jump for cold start
0153: C3F401   [10]     WARM:   JP      WARMST          ; Jump for warm start
0156:                   STARTB: 
0156: DD210000 [14]             LD      IX,0            ; Flag cold start
015A: C36101   [24]             JP      CSTART          ; Jump to initialise
                        
015D: 070A                      .WORD   DEINT           ; Get integer -32768 to 32767
015F: 7D11                      .WORD   ABPASS          ; Return integer in AB
                        
                        
0161: 214520   [10]     CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0164: F9       [16]             LD      SP,HL           ; Set up a temporary stack
0165: C39C1D   [26]             JP      INITST          ; Go to initialise
                        
0168: 112E04   [10]     INIT:   LD      DE,INITAB       ; Initialise workspace
016B: 0663     [17]             LD      B,INITBE-INITAB+3; Bytes to copy
016D: 214520   [27]             LD      HL,WRKSPC       ; Into workspace RAM
0170: 1A       [ 7]     COPY:   LD      A,(DE)          ; Get source
0171: 77       [14]             LD      (HL),A          ; To destination
0172: 23       [20]             INC     HL              ; Next destination
0173: 13       [26]             INC     DE              ; Next source
0174: 05       [30]             DEC     B               ; Count bytes
0175: C27001   [40|40]          JP      NZ,COPY         ; More to move
0178: F9       [46]             LD      SP,HL           ; Temporary stack
0179: CD2F06   [63]             CALL    CLREG           ; Clear registers and stack
017C: CDFD0B   [80]             CALL    PRNTCRLF        ; Output CRLF
017F: 32EF20   [93]             LD      (BUFFER+72+1),A ; Mark end of buffer
0182: 323E21   [106]            LD      (PROGST),A      ; Initialise program area
0185: 214302   [10]     MSIZE:  LD      HL,MEMMSG       ; Point to message
0188: CD9B12   [27]             CALL    PRS             ; Output "Memory size"
018B: CD4C06   [44]             CALL    PROMPT          ; Get input with '?'
018E: CD5509   [61]             CALL    GETCHR          ; Get next character
0191: B7       [65]             OR      A               ; Set flags
0192: C2AA01   [75|75]          JP      NZ,TSTMEM       ; If number - Test if RAM there
0195: 21A221   [85]             LD      HL,STLOOK       ; Point to start of RAM
0198: 23       [ 6]     MLOOP:  INC     HL              ; Next byte
0199: 7C       [10]             LD      A,H             ; Above address FFFF ?
019A: B5       [14]             OR      L
019B: CABC01   [24|24]          JP      Z,SETTOP        ; Yes - 64K RAM
019E: 7E       [31]             LD      A,(HL)          ; Get contents
019F: 47       [35]             LD      B,A             ; Save it
01A0: 2F       [39]             CPL                     ; Flip all bits
01A1: 77       [46]             LD      (HL),A          ; Put it back
01A2: BE       [53]             CP      (HL)            ; RAM there if same
01A3: 70       [60]             LD      (HL),B          ; Restore old contents
01A4: CA9801   [70|70]          JP      Z,MLOOP         ; If RAM - test next byte
01A7: C3BC01   [80]             JP      SETTOP          ; Top of RAM found
                        
01AA: CD210A   [17]     TSTMEM: CALL    ATOH            ; Get high memory into DE
01AD: B7       [21]             OR      A               ; Set flags on last byte
01AE: C2FD04   [31|31]          JP      NZ,SNERR        ; ?SN Error if bad character
01B1: EB       [35]             EX      DE,HL           ; Address into HL
01B2: 2B       [41]             DEC     HL              ; Back one byte
01B3: 3ED9     [48]             LD      A,11011001B     ; Test byte
01B5: 46       [55]             LD      B,(HL)          ; Get old contents
01B6: 77       [62]             LD      (HL),A          ; Load test byte
01B7: BE       [69]             CP      (HL)            ; RAM there if same
01B8: 70       [76]             LD      (HL),B          ; Restore old contents
01B9: C28501   [86|86]          JP      NZ,MSIZE        ; Ask again if no RAM
                        
01BC: 2B       [ 6]     SETTOP: DEC     HL              ; Back one byte
01BD: 11A121   [16]             LD      DE,STLOOK-1     ; See if enough RAM
01C0: CDC507   [33]             CALL    CPDEHL          ; Compare DE with HL
01C3: DA8501   [43|43]          JP      C,MSIZE         ; Ask again if not enough RAM
01C6: 11CEFF   [53]             LD      DE,0-50         ; 50 Bytes string space
01C9: 22F420   [69]             LD      (LSTRAM),HL     ; Save last available RAM
01CC: 19       [80]             ADD     HL,DE           ; Allocate string space
01CD: 229F20   [96]             LD      (STRSPC),HL     ; Save string space
01D0: CD0A06   [113]            CALL    CLRPTR          ; Clear program area
01D3: 2A9F20   [129]            LD      HL,(STRSPC)     ; Get end of memory
01D6: 11EFFF   [139]            LD      DE,0-17         ; Offset for free bytes
01D9: 19       [150]            ADD     HL,DE           ; Adjust HL
01DA: 113E21   [160]            LD      DE,PROGST       ; Start of program text
01DD: 7D       [164]            LD      A,L             ; Get LSB
01DE: 93       [168]            SUB     E               ; Adjust it
01DF: 6F       [172]            LD      L,A             ; Re-save
01E0: 7C       [176]            LD      A,H             ; Get MSB
01E1: 9A       [180]            SBC     A,D             ; Adjust it
01E2: 67       [184]            LD      H,A             ; Re-save
01E3: E5       [195]            PUSH    HL              ; Save bytes free
01E4: 210C02   [205]            LD      HL,SIGNON       ; Sign-on message
01E7: CD9B12   [222]            CALL    PRS             ; Output string
01EA: E1       [232]            POP     HL              ; Get bytes free back
01EB: CD3E19   [249]            CALL    PRNTHL          ; Output amount of free memory
01EE: 21FD01   [259]            LD      HL,BFREE        ; " Bytes free" message
01F1: CD9B12   [276]            CALL    PRS             ; Output string
                        
01F4: 31AB20   [10]     WARMST: LD      SP,STACK        ; Temporary stack
01F7: CD2F06   [17]     BRKRET: CALL    CLREG           ; Clear registers and stack
01FA: C34805   [27]             JP      PRNTOK          ; Go to get command line
                        
01FD: 20427974          BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0201: 65732066          
0205: 7265650D          
0209: 0A0000            
                        
020C: 5A383020          SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
0210: 42415349          
0214: 43205665          
0218: 7220342E          
021C: 37620D0A          
0220: 436F7079                  .BYTE   "Copyright ",40,"C",41
0224: 72696768          
0228: 74202843          
022C: 29                
022D: 20313937                  .BYTE   " 1978 by Microsoft",CR,LF,0,0
0231: 38206279          
0235: 204D6963          
0239: 726F736F          
023D: 66740D0A          
0241: 0000              
                        
0243: 4D656D6F          MEMMSG: .BYTE   "Memory top",0
0247: 72792074          
024B: 6F7000            
                        
                        ; FUNCTION ADDRESS TABLE
                        
024E: B317              FNCTAB: .WORD   SGN
0250: 7718                      .WORD   INT
0252: C917                      .WORD   ABS
0254: 4820                      .WORD   USR
0256: 5B11                      .WORD   FRE
0258: E014                      .WORD   INP
025A: 8911                      .WORD   POS
025C: 3D1A                      .WORD   SQR
025E: 1C1B                      .WORD   RND
0260: 5816                      .WORD   LOG
0262: 8B1A                      .WORD   EXP
0264: 911B                      .WORD   COS
0266: 971B                      .WORD   SIN
0268: F81B                      .WORD   TAN
026A: 0D1C                      .WORD   ATN
026C: 3415                      .WORD   PEEK
026E: 781C                      .WORD   DEEK
0270: 9620                      .WORD   POINT
0272: 0D14                      .WORD   LEN
0274: 2512                      .WORD   STR
0276: A714                      .WORD   VAL
0278: 1C14                      .WORD   ASC
027A: 2D14                      .WORD   CHR
027C: 9A1C                      .WORD   HEX
027E: 2D1D                      .WORD   BIN
0280: 3D14                      .WORD   LEFT
0282: 6D14                      .WORD   RIGHT
0284: 7714                      .WORD   MID
                        
                        ; RESERVED WORD LIST
                        
0286: C54E44            WORDS:  .BYTE   'E'+80H,"ND"
0289: C64F52                    .BYTE   'F'+80H,"OR"
028C: CE455854                  .BYTE   'N'+80H,"EXT"
0290: C4415441                  .BYTE   'D'+80H,"ATA"
0294: C94E5055                  .BYTE   'I'+80H,"NPUT"
0298: 54                
0299: C4494D                    .BYTE   'D'+80H,"IM"
029C: D2454144                  .BYTE   'R'+80H,"EAD"
02A0: CC4554                    .BYTE   'L'+80H,"ET"
02A3: C74F544F                  .BYTE   'G'+80H,"OTO"
02A7: D2554E                    .BYTE   'R'+80H,"UN"
02AA: C946                      .BYTE   'I'+80H,"F"
02AC: D2455354                  .BYTE   'R'+80H,"ESTORE"
02B0: 4F5245            
02B3: C74F5355                  .BYTE   'G'+80H,"OSUB"
02B7: 42                
02B8: D2455455                  .BYTE   'R'+80H,"ETURN"
02BC: 524E              
02BE: D2454D                    .BYTE   'R'+80H,"EM"
02C1: D3544F50                  .BYTE   'S'+80H,"TOP"
02C5: CF5554                    .BYTE   'O'+80H,"UT"
02C8: CF4E                      .BYTE   'O'+80H,"N"
02CA: CE554C4C                  .BYTE   'N'+80H,"ULL"
02CE: D7414954                  .BYTE   'W'+80H,"AIT"
02D2: C44546                    .BYTE   'D'+80H,"EF"
02D5: D04F4B45                  .BYTE   'P'+80H,"OKE"
02D9: C44F4B45                  .BYTE   'D'+80H,"OKE"
02DD: D3435245                  .BYTE   'S'+80H,"CREEN"
02E1: 454E              
02E3: CC494E45                  .BYTE   'L'+80H,"INES"
02E7: 53                
02E8: C34C53                    .BYTE   'C'+80H,"LS"
02EB: D7494454                  .BYTE   'W'+80H,"IDTH"
02EF: 48                
02F0: CD4F4E49                  .BYTE   'M'+80H,"ONITOR"
02F4: 544F52            
02F7: D34554                    .BYTE   'S'+80H,"ET"
02FA: D2455345                  .BYTE   'R'+80H,"ESET"
02FE: 54                
02FF: D052494E                  .BYTE   'P'+80H,"RINT"
0303: 54                
0304: C34F4E54                  .BYTE   'C'+80H,"ONT"
0308: CC495354                  .BYTE   'L'+80H,"IST"
030C: C34C4541                  .BYTE   'C'+80H,"LEAR"
0310: 52                
0311: C34C4F41                  .BYTE   'C'+80H,"LOAD"
0315: 44                
0316: C3534156                  .BYTE   'C'+80H,"SAVE"
031A: 45                
031B: CE4557                    .BYTE   'N'+80H,"EW"
                        
031E: D4414228                  .BYTE   'T'+80H,"AB("
0322: D44F                      .BYTE   'T'+80H,"O"
0324: C64E                      .BYTE   'F'+80H,"N"
0326: D3504328                  .BYTE   'S'+80H,"PC("
032A: D448454E                  .BYTE   'T'+80H,"HEN"
032E: CE4F54                    .BYTE   'N'+80H,"OT"
0331: D3544550                  .BYTE   'S'+80H,"TEP"
                        
0335: AB                        .BYTE   '+'+80H
0336: AD                        .BYTE   '-'+80H
0337: AA                        .BYTE   '*'+80H
0338: AF                        .BYTE   '/'+80H
0339: DE                        .BYTE   '^'+80H
033A: C14E44                    .BYTE   'A'+80H,"ND"
033D: CF52                      .BYTE   'O'+80H,"R"
033F: BE                        .BYTE   '>'+80H
0340: BD                        .BYTE   '='+80H
0341: BC                        .BYTE   '<'+80H
                        
0342: D3474E                    .BYTE   'S'+80H,"GN"
0345: C94E54                    .BYTE   'I'+80H,"NT"
0348: C14253                    .BYTE   'A'+80H,"BS"
034B: D55352                    .BYTE   'U'+80H,"SR"
034E: C65245                    .BYTE   'F'+80H,"RE"
0351: C94E50                    .BYTE   'I'+80H,"NP"
0354: D04F53                    .BYTE   'P'+80H,"OS"
0357: D35152                    .BYTE   'S'+80H,"QR"
035A: D24E44                    .BYTE   'R'+80H,"ND"
035D: CC4F47                    .BYTE   'L'+80H,"OG"
0360: C55850                    .BYTE   'E'+80H,"XP"
0363: C34F53                    .BYTE   'C'+80H,"OS"
0366: D3494E                    .BYTE   'S'+80H,"IN"
0369: D4414E                    .BYTE   'T'+80H,"AN"
036C: C1544E                    .BYTE   'A'+80H,"TN"
036F: D045454B                  .BYTE   'P'+80H,"EEK"
0373: C445454B                  .BYTE   'D'+80H,"EEK"
0377: D04F494E                  .BYTE   'P'+80H,"OINT"
037B: 54                
037C: CC454E                    .BYTE   'L'+80H,"EN"
037F: D3545224                  .BYTE   'S'+80H,"TR$"
0383: D6414C                    .BYTE   'V'+80H,"AL"
0386: C15343                    .BYTE   'A'+80H,"SC"
0389: C3485224                  .BYTE   'C'+80H,"HR$"
038D: C8455824                  .BYTE   'H'+80H,"EX$"
0391: C2494E24                  .BYTE   'B'+80H,"IN$"
0395: CC454654                  .BYTE   'L'+80H,"EFT$"
0399: 24                
039A: D2494748                  .BYTE   'R'+80H,"IGHT$"
039E: 5424              
03A0: CD494424                  .BYTE   'M'+80H,"ID$"
03A4: 80                        .BYTE   80H             ; End of list marker
                        
                        ; KEYWORD ADDRESS TABLE
                        
03A5: 9F09              WORDTB: .WORD   PEND
03A7: 9C08                      .WORD   FOR
03A9: 770D                      .WORD   NEXT
03AB: EC0A                      .WORD   DATA
03AD: 7E0C                      .WORD   INPUT
03AF: B30F                      .WORD   DIM
03B1: AD0C                      .WORD   READ
03B3: 030B                      .WORD   LET
03B5: A90A                      .WORD   GOTO
03B7: 8C0A                      .WORD   RUN
03B9: 7B0B                      .WORD   IF
03BB: 6509                      .WORD   RESTOR
03BD: 980A                      .WORD   GOSUB
03BF: C70A                      .WORD   RETURN
03C1: EE0A                      .WORD   REM
03C3: 9D09                      .WORD   STOP
03C5: EC14                      .WORD   POUT
03C7: 5D0B                      .WORD   ON
03C9: DE09                      .WORD   NULL
03CB: F214                      .WORD   WAIT
03CD: 9111                      .WORD   DEF
03CF: 3B15                      .WORD   POKE
03D1: 831C                      .WORD   DOKE
03D3: EE0A                      .WORD   REM
03D5: 691C                      .WORD   LINES
03D7: 5C1C                      .WORD   CLS
03D9: 611C                      .WORD   WIDTH
03DB: 991D                      .WORD   MONITR
03DD: 9920                      .WORD   PSET
03DF: 9C20                      .WORD   RESET
03E1: 9F0B                      .WORD   PRINT
03E3: CB09                      .WORD   CONT
03E5: 1108                      .WORD   LIST
03E7: 460A                      .WORD   CLEAR
03E9: EE0A                      .WORD   REM
03EB: EE0A                      .WORD   REM
03ED: 0906                      .WORD   NEW
                        
                        ; RESERVED WORD TOKEN VALUES
                        
0080:                   ZEND    .EQU    080H            ; END
0081:                   ZFOR    .EQU    081H            ; FOR
0083:                   ZDATA   .EQU    083H            ; DATA
0088:                   ZGOTO   .EQU    088H            ; GOTO
008C:                   ZGOSUB  .EQU    08CH            ; GOSUB
008E:                   ZREM    .EQU    08EH            ; REM
009E:                   ZPRINT  .EQU    09EH            ; PRINT
00A4:                   ZNEW    .EQU    0A4H            ; NEW
                        
00A5:                   ZTAB    .EQU    0A5H            ; TAB
00A6:                   ZTO     .EQU    0A6H            ; TO
00A7:                   ZFN     .EQU    0A7H            ; FN
00A8:                   ZSPC    .EQU    0A8H            ; SPC
00A9:                   ZTHEN   .EQU    0A9H            ; THEN
00AA:                   ZNOT    .EQU    0AAH            ; NOT
00AB:                   ZSTEP   .EQU    0ABH            ; STEP
                        
00AC:                   ZPLUS   .EQU    0ACH            ; +
00AD:                   ZMINUS  .EQU    0ADH            ; -
00AE:                   ZTIMES  .EQU    0AEH            ; *
00AF:                   ZDIV    .EQU    0AFH            ; /
00B2:                   ZOR     .EQU    0B2H            ; OR
00B3:                   ZGTR    .EQU    0B3H            ; >
00B4:                   ZEQUAL  .EQU    0B4H            ; M
00B5:                   ZLTH    .EQU    0B5H            ; <
00B6:                   ZSGN    .EQU    0B6H            ; SGN
00C7:                   ZPOINT  .EQU    0C7H            ; POINT
00CF:                   ZLEFT   .EQU    0CDH +2         ; LEFT$
                        
                        ; ARITHMETIC PRECEDENCE TABLE
                        
03EF: 79                PRITAB: .BYTE   79H             ; Precedence value
03F0: 2519                      .WORD   PADD            ; FPREG = <last> + FPREG
                        
03F2: 79                        .BYTE   79H             ; Precedence value
03F3: 5915                      .WORD   PSUB            ; FPREG = <last> - FPREG
                        
03F5: 7C                        .BYTE   7CH             ; Precedence value
03F6: 9716                      .WORD   MULT            ; PPREG = <last> * FPREG
                        
03F8: 7C                        .BYTE   7CH             ; Precedence value
03F9: F816                      .WORD   DIV             ; FPREG = <last> / FPREG
                        
03FB: 7F                        .BYTE   7FH             ; Precedence value
03FC: 461A                      .WORD   POWER           ; FPREG = <last> ^ FPREG
                        
03FE: 50                        .BYTE   50H             ; Precedence value
03FF: 0C0F                      .WORD   PAND            ; FPREG = <last> AND FPREG
                        
0401: 46                        .BYTE   46H             ; Precedence value
0402: 0B0F                      .WORD   POR             ; FPREG = <last> OR FPREG
                        
                        ; BASIC ERROR CODE LIST
                        
0404: 4E46              ERRORS: .BYTE   "NF"            ; NEXT without FOR
0406: 534E                      .BYTE   "SN"            ; Syntax error
0408: 5247                      .BYTE   "RG"            ; RETURN without GOSUB
040A: 4F44                      .BYTE   "OD"            ; Out of DATA
040C: 4643                      .BYTE   "FC"            ; Illegal function call
040E: 4F56                      .BYTE   "OV"            ; Overflow error
0410: 4F4D                      .BYTE   "OM"            ; Out of memory
0412: 554C                      .BYTE   "UL"            ; Undefined line
0414: 4253                      .BYTE   "BS"            ; Bad subscript
0416: 4444                      .BYTE   "DD"            ; Re-DIMensioned array
0418: 2F30                      .BYTE   "/0"            ; Division by zero
041A: 4944                      .BYTE   "ID"            ; Illegal direct
041C: 544D                      .BYTE   "TM"            ; Type mis-match
041E: 4F53                      .BYTE   "OS"            ; Out of string space
0420: 4C53                      .BYTE   "LS"            ; String too long
0422: 5354                      .BYTE   "ST"            ; String formula too complex
0424: 434E                      .BYTE   "CN"            ; Can't CONTinue
0426: 5546                      .BYTE   "UF"            ; Undefined FN function
0428: 4D4F                      .BYTE   "MO"            ; Missing operand
042A: 4858                      .BYTE   "HX"            ; HEX error
042C: 424E                      .BYTE   "BN"            ; BIN error
                        
                        ; INITIALISATION TABLE -------------------------------------------------------
                        
042E: C3F401   [10]     INITAB: JP      WARMST          ; Warm start jump
0431: C31C0A   [20]             JP      FCERR           ; "USR (X)" jump (Set to Error)
0434: D300     [31]             OUT     (0),A           ; "OUT p,n" skeleton
0436: C9       [41]             RET
0437: D600     [48]             SUB     0               ; Division support routine
0439: 6F       [52]             LD      L,A
043A: 7C       [56]             LD      A,H
043B: DE00     [63]             SBC     A,0
043D: 67       [67]             LD      H,A
043E: 78       [71]             LD      A,B
043F: DE00     [78]             SBC     A,0
0441: 47       [82]             LD      B,A
0442: 3E00     [89]             LD      A,0
0444: C9       [99]             RET
0445: 000000                    .BYTE   0,0,0                   ; Random number seed table used by RND
0448: 354ACA99                  .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
044C: 391C7698                  .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
0450: 2295B398                  .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
0454: 0ADD4798                  .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
0458: 53D19999                  .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
045C: 0A1A9F98                  .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
0460: 65BCCD98                  .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
0464: D6773E98                  .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
0468: 52C74F80                  .BYTE   052H,0C7H,04FH,080H     ; Last random number
046C: DB00     [110]            IN      A,(0)           ; INP (x) skeleton
046E: C9       [120]            RET
046F: 01                        .BYTE   1               ; POS (x) number (1)
0470: FF                        .BYTE   255             ; Terminal width (255 = no auto CRLF)
0471: 1C                        .BYTE   28              ; Width for commas (3 columns)
0472: 00                        .BYTE   0               ; No nulls after input bytes
0473: 00                        .BYTE   0               ; Output enabled (^O off)
0474: 1400                      .WORD   20              ; Initial lines counter
0476: 1400                      .WORD   20              ; Initial lines number
0478: 0000                      .WORD   0               ; Array load/save check sum
047A: 00                        .BYTE   0               ; Break not by NMI
047B: 00                        .BYTE   0               ; Break flag
047C: C34207   [130]            JP      TTYLIN          ; Input reflection (set to TTY)
047F: C30000   [140]            JP      $0000           ; POINT reflection unused
0482: C30000   [150]            JP      $0000           ; SET reflection
0485: C30000   [160]            JP      $0000          	; RESET reflection
0488: A221                      .WORD   STLOOK          ; Temp string space
048A: FEFF                      .WORD   -2              ; Current line number (cold)
048C: 3F21                      .WORD   PROGST+1        ; Start of program text
048E:                   INITBE:                         
                        
                        ; END OF INITIALISATION TABLE ---------------------------------------------------
                        
048E: 20457272          ERRMSG: .BYTE   " Error",0
0492: 6F7200            
0495: 20696E20          INMSG:  .BYTE   " in ",0
0499: 00                
0499:                   ZERBYT  .EQU    $-1             ; A zero byte
049A: 4F6B0D0A          OKMSG:  .BYTE   "Ok",CR,LF,0,0
049E: 0000              
04A0: 42726561          BRKMSG: .BYTE   "Break",0
04A4: 6B00              
                        
04A6: 210400   [10]     BAKSTK: LD      HL,4            ; Look for "FOR" block with
04A9: 39       [21]             ADD     HL,SP           ; same index as specified
04AA: 7E       [ 7]     LOKFOR: LD      A,(HL)          ; Get block ID
04AB: 23       [13]             INC     HL              ; Point to index address
04AC: FE81     [20]             CP      ZFOR            ; Is it a "FOR" token
04AE: C0       [25|31]          RET     NZ              ; No - exit
04AF: 4E       [32]             LD      C,(HL)          ; BC = Address of "FOR" index
04B0: 23       [38]             INC     HL
04B1: 46       [45]             LD      B,(HL)
04B2: 23       [51]             INC     HL              ; Point to sign of STEP
04B3: E5       [62]             PUSH    HL              ; Save pointer to sign
04B4: 69       [66]             LD      L,C             ; HL = address of "FOR" index
04B5: 60       [70]             LD      H,B
04B6: 7A       [74]             LD      A,D             ; See if an index was specified
04B7: B3       [78]             OR      E               ; DE = 0 if no index specified
04B8: EB       [82]             EX      DE,HL           ; Specified index into HL
04B9: CAC004   [92|92]          JP      Z,INDFND        ; Skip if no index given
04BC: EB       [96]             EX      DE,HL           ; Index back into DE
04BD: CDC507   [113]            CALL    CPDEHL          ; Compare index with one given
04C0: 010D00   [10]     INDFND: LD      BC,16-3         ; Offset to next block
04C3: E1       [20]             POP     HL              ; Restore pointer to sign
04C4: C8       [25|31]          RET     Z               ; Return if block found
04C5: 09       [36]             ADD     HL,BC           ; Point to next block
04C6: C3AA04   [46]             JP      LOKFOR          ; Keep on looking
                        
04C9: CDE304   [17]     MOVUP:  CALL    ENFMEM          ; See if enough memory
04CC: C5       [11]     MOVSTR: PUSH    BC              ; Save end of source
04CD: E3       [30]             EX      (SP),HL         ; Swap source and dest" end
04CE: C1       [40]             POP     BC              ; Get end of destination
04CF: CDC507   [17]     MOVLP:  CALL    CPDEHL          ; See if list moved
04D2: 7E       [24]             LD      A,(HL)          ; Get byte
04D3: 02       [31]             LD      (BC),A          ; Move it
04D4: C8       [36|42]          RET     Z               ; Exit if all done
04D5: 0B       [42]             DEC     BC              ; Next byte to move to
04D6: 2B       [48]             DEC     HL              ; Next byte to move
04D7: C3CF04   [58]             JP      MOVLP           ; Loop until all bytes moved
                        
04DA: E5       [11]     CHKSTK: PUSH    HL              ; Save code string address
04DB: 2A1F21   [27]             LD      HL,(ARREND)     ; Lowest free memory
04DE: 0600     [34]             LD      B,0             ; BC = Number of levels to test
04E0: 09       [45]             ADD     HL,BC           ; 2 Bytes for each level
04E1: 09       [56]             ADD     HL,BC
04E2: 3E                        .BYTE   3EH             ; Skip "PUSH HL"
04E3: E5       [11]     ENFMEM: PUSH    HL              ; Save code string address
04E4: 3ED0     [18]             LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
04E6: 95       [22]             SUB     L
04E7: 6F       [26]             LD      L,A
04E8: 3EFF     [33]             LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
04EA: 9C       [37]             SBC     A,H
04EB: DAF204   [47|47]          JP      C,OMERR         ; Not enough - ?OM Error
04EE: 67       [51]             LD      H,A
04EF: 39       [62]             ADD     HL,SP           ; Test if stack is overflowed
04F0: E1       [72]             POP     HL              ; Restore code string address
04F1: D8       [77|83]          RET     C               ; Return if enough mmory
04F2: 1E0C     [ 7]     OMERR:  LD      E,OM            ; ?OM Error
04F4: C31105   [17]             JP      ERROR
                        
04F7: 2A0E21   [16]     DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
04FA: 22A120   [32]             LD      (LINEAT),HL     ; Save as current line
04FD: 1E02     [ 7]     SNERR:  LD      E,SN            ; ?SN Error
04FF: 01                        .BYTE   01H             ; Skip "LD E,DZ"
0500: 1E14     [ 7]     DZERR:  LD      E,DZ            ; ?/0 Error
0502: 01                        .BYTE   01H             ; Skip "LD E,NF"
0503: 1E00     [ 7]     NFERR:  LD      E,NF            ; ?NF Error
0505: 01                        .BYTE   01H             ; Skip "LD E,DD"
0506: 1E12     [ 7]     DDERR:  LD      E,DD            ; ?DD Error
0508: 01                        .BYTE   01H             ; Skip "LD E,UF"
0509: 1E22     [ 7]     UFERR:  LD      E,UF            ; ?UF Error
050B: 01                        .BYTE   01H             ; Skip "LD E,OV
050C: 1E0A     [ 7]     OVERR:  LD      E,OV            ; ?OV Error
050E: 01                        .BYTE   01H             ; Skip "LD E,TM"
050F: 1E18     [ 7]     TMERR:  LD      E,TM            ; ?TM Error
                        
0511: CD2F06   [17]     ERROR:  CALL    CLREG           ; Clear registers and stack
0514: 328A20   [30]             LD      (CTLOFG),A      ; Enable output (A is 0)
0517: CDF00B   [47]             CALL    STTLIN          ; Start new line
051A: 210404   [57]             LD      HL,ERRORS       ; Point to error codes
051D: 57       [61]             LD      D,A             ; D = 0 (A is 0)
051E: 3E3F     [68]             LD      A,'?'
0520: CDD607   [85]             CALL    OUTC            ; Output '?'
0523: 19       [96]             ADD     HL,DE           ; Offset to correct error code
0524: 7E       [103]            LD      A,(HL)          ; First character
0525: CDD607   [120]            CALL    OUTC            ; Output it
0528: CD5509   [137]            CALL    GETCHR          ; Get next character
052B: CDD607   [154]            CALL    OUTC            ; Output it
052E: 218E04   [164]            LD      HL,ERRMSG       ; "Error" message
0531: CD9B12   [17]     ERRIN:  CALL    PRS             ; Output message
0534: 2AA120   [33]             LD      HL,(LINEAT)     ; Get line of error
0537: 11FEFF   [43]             LD      DE,-2           ; Cold start error if -2
053A: CDC507   [60]             CALL    CPDEHL          ; See if cold start error
053D: CA6101   [70|70]          JP      Z,CSTART        ; Cold start error - Restart
0540: 7C       [74]             LD      A,H             ; Was it a direct error?
0541: A5       [78]             AND     L               ; Line = -1 if direct error
0542: 3C       [82]             INC     A
0543: C43619   [92|99]          CALL    NZ,LINEIN       ; No - output line of error
0546: 3E                        .BYTE   3EH             ; Skip "POP BC"
0547: C1       [10]     POPNOK: POP     BC              ; Drop address in input buffer
                        
0548: AF       [ 4]     PRNTOK: XOR     A               ; Output "Ok" and get command
0549: 328A20   [17]             LD      (CTLOFG),A      ; Enable output
054C: CDF00B   [34]             CALL    STTLIN          ; Start new line
054F: 219A04   [44]             LD      HL,OKMSG        ; "Ok" message
0552: CD9B12   [61]             CALL    PRS             ; Output "Ok"
0555: 21FFFF   [10]     GETCMD: LD      HL,-1           ; Flag direct mode
0558: 22A120   [26]             LD      (LINEAT),HL     ; Save as current line
055B: CD4207   [43]             CALL    GETLIN          ; Get an input line
055E: DA5505   [53|53]          JP      C,GETCMD        ; Get line again if break
0561: CD5509   [70]             CALL    GETCHR          ; Get first character
0564: 3C       [74]             INC     A               ; Test if end of line
0565: 3D       [78]             DEC     A               ; Without affecting Carry
0566: CA5505   [88|88]          JP      Z,GETCMD        ; Nothing entered - Get another
0569: F5       [99]             PUSH    AF              ; Save Carry status
056A: CD210A   [116]            CALL    ATOH            ; Get line number into DE
056D: D5       [127]            PUSH    DE              ; Save line number
056E: CD5906   [144]            CALL    CRUNCH          ; Tokenise rest of line
0571: 47       [148]            LD      B,A             ; Length of tokenised line
0572: D1       [158]            POP     DE              ; Restore line number
0573: F1       [168]            POP     AF              ; Restore Carry
0574: D23509   [178|178]        JP      NC,EXCUTE       ; No line number - Direct mode
0577: D5       [189]            PUSH    DE              ; Save line number
0578: C5       [200]            PUSH    BC              ; Save length of tokenised line
0579: AF       [204]            XOR     A
057A: 321121   [217]            LD      (LSTBIN),A      ; Clear last byte input
057D: CD5509   [234]            CALL    GETCHR          ; Get next character
0580: B7       [238]            OR      A               ; Set flags
0581: F5       [249]            PUSH    AF              ; And save them
0582: CDE905   [266]            CALL    SRCHLN          ; Search for line number in DE
0585: DA8E05   [276|276]        JP      C,LINFND        ; Jump if line found
0588: F1       [286]            POP     AF              ; Get status
0589: F5       [297]            PUSH    AF              ; And re-save
058A: CAC20A   [307|307]        JP      Z,ULERR         ; Nothing after number - Error
058D: B7       [311]            OR      A               ; Clear Carry
058E: C5       [11]     LINFND: PUSH    BC              ; Save address of line in prog
058F: D2A505   [21|21]          JP      NC,INEWLN       ; Line not found - Insert new
0592: EB       [25]             EX      DE,HL           ; Next line address in DE
0593: 2A1B21   [41]             LD      HL,(PROGND)     ; End of program
0596: 1A       [ 7]     SFTPRG: LD      A,(DE)          ; Shift rest of program down
0597: 02       [14]             LD      (BC),A
0598: 03       [20]             INC     BC              ; Next destination
0599: 13       [26]             INC     DE              ; Next source
059A: CDC507   [43]             CALL    CPDEHL          ; All done?
059D: C29605   [53|53]          JP      NZ,SFTPRG       ; More to do
05A0: 60       [57]             LD      H,B             ; HL - New end of program
05A1: 69       [61]             LD      L,C
05A2: 221B21   [77]             LD      (PROGND),HL     ; Update end of program
                        
05A5: D1       [10]     INEWLN: POP     DE              ; Get address of line,
05A6: F1       [20]             POP     AF              ; Get status
05A7: CACC05   [30|30]          JP      Z,SETPTR        ; No text - Set up pointers
05AA: 2A1B21   [46]             LD      HL,(PROGND)     ; Get end of program
05AD: E3       [65]             EX      (SP),HL         ; Get length of input line
05AE: C1       [75]             POP     BC              ; End of program to BC
05AF: 09       [86]             ADD     HL,BC           ; Find new end
05B0: E5       [97]             PUSH    HL              ; Save new end
05B1: CDC904   [114]            CALL    MOVUP           ; Make space for line
05B4: E1       [124]            POP     HL              ; Restore new end
05B5: 221B21   [140]            LD      (PROGND),HL     ; Update end of program pointer
05B8: EB       [144]            EX      DE,HL           ; Get line to move up in HL
05B9: 74       [151]            LD      (HL),H          ; Save MSB
05BA: D1       [161]            POP     DE              ; Get new line number
05BB: 23       [167]            INC     HL              ; Skip pointer
05BC: 23       [173]            INC     HL
05BD: 73       [180]            LD      (HL),E          ; Save LSB of line number
05BE: 23       [186]            INC     HL
05BF: 72       [193]            LD      (HL),D          ; Save MSB of line number
05C0: 23       [199]            INC     HL              ; To first byte in line
05C1: 11A620   [209]            LD      DE,BUFFER       ; Copy buffer to program
05C4: 1A       [ 7]     MOVBUF: LD      A,(DE)          ; Get source
05C5: 77       [14]             LD      (HL),A          ; Save destinations
05C6: 23       [20]             INC     HL              ; Next source
05C7: 13       [26]             INC     DE              ; Next destination
05C8: B7       [30]             OR      A               ; Done?
05C9: C2C405   [40|40]          JP      NZ,MOVBUF       ; No - Repeat
05CC: CD1506   [17]     SETPTR: CALL    RUNFST          ; Set line pointers
05CF: 23       [23]             INC     HL              ; To LSB of pointer
05D0: EB       [27]             EX      DE,HL           ; Address to DE
05D1: 62       [ 4]     PTRLP:  LD      H,D             ; Address to HL
05D2: 6B       [ 8]             LD      L,E
05D3: 7E       [15]             LD      A,(HL)          ; Get LSB of pointer
05D4: 23       [21]             INC     HL              ; To MSB of pointer
05D5: B6       [28]             OR      (HL)            ; Compare with MSB pointer
05D6: CA5505   [38|38]          JP      Z,GETCMD        ; Get command line if end
05D9: 23       [44]             INC     HL              ; To LSB of line number
05DA: 23       [50]             INC     HL              ; Skip line number
05DB: 23       [56]             INC     HL              ; Point to first byte in line
05DC: AF       [60]             XOR     A               ; Looking for 00 byte
05DD: BE       [ 7]     FNDEND: CP      (HL)            ; Found end of line?
05DE: 23       [13]             INC     HL              ; Move to next byte
05DF: C2DD05   [23|23]          JP      NZ,FNDEND       ; No - Keep looking
05E2: EB       [27]             EX      DE,HL           ; Next line address to HL
05E3: 73       [34]             LD      (HL),E          ; Save LSB of pointer
05E4: 23       [40]             INC     HL
05E5: 72       [47]             LD      (HL),D          ; Save MSB of pointer
05E6: C3D105   [57]             JP      PTRLP           ; Do next line
                        
05E9: 2AA320   [16]     SRCHLN: LD      HL,(BASTXT)     ; Start of program text
05EC: 44       [ 4]     SRCHLP: LD      B,H             ; BC = Address to look at
05ED: 4D       [ 8]             LD      C,L
05EE: 7E       [15]             LD      A,(HL)          ; Get address of next line
05EF: 23       [21]             INC     HL
05F0: B6       [28]             OR      (HL)            ; End of program found?
05F1: 2B       [34]             DEC     HL
05F2: C8       [39|45]          RET     Z               ; Yes - Line not found
05F3: 23       [45]             INC     HL
05F4: 23       [51]             INC     HL
05F5: 7E       [58]             LD      A,(HL)          ; Get LSB of line number
05F6: 23       [64]             INC     HL
05F7: 66       [71]             LD      H,(HL)          ; Get MSB of line number
05F8: 6F       [75]             LD      L,A
05F9: CDC507   [92]             CALL    CPDEHL          ; Compare with line in DE
05FC: 60       [96]             LD      H,B             ; HL = Start of this line
05FD: 69       [100]            LD      L,C
05FE: 7E       [107]            LD      A,(HL)          ; Get LSB of next line address
05FF: 23       [113]            INC     HL
0600: 66       [120]            LD      H,(HL)          ; Get MSB of next line address
0601: 6F       [124]            LD      L,A             ; Next line to HL
0602: 3F       [128]            CCF
0603: C8       [133|139]        RET     Z               ; Lines found - Exit
0604: 3F       [137]            CCF
0605: D0       [142|148]        RET     NC              ; Line not found,at line after
0606: C3EC05   [152]            JP      SRCHLP          ; Keep looking
                        
0609: C0       [ 5|11]  NEW:    RET     NZ              ; Return if any more on line
060A: 2AA320   [16]     CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
060D: AF       [20]             XOR     A               ; Set program area to empty
060E: 77       [27]             LD      (HL),A          ; Save LSB = 00
060F: 23       [33]             INC     HL
0610: 77       [40]             LD      (HL),A          ; Save MSB = 00
0611: 23       [46]             INC     HL
0612: 221B21   [62]             LD      (PROGND),HL     ; Set program end
                        
0615: 2AA320   [16]     RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0618: 2B       [22]             DEC     HL
                        
0619: 221321   [16]     INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
061C: 2AF420   [32]             LD      HL,(LSTRAM)     ; Get end of RAM
061F: 220821   [48]             LD      (STRBOT),HL     ; Clear string space
0622: AF       [52]             XOR     A
0623: CD6509   [69]             CALL    RESTOR          ; Reset DATA pointers
0626: 2A1B21   [85]             LD      HL,(PROGND)     ; Get end of program
0629: 221D21   [101]            LD      (VAREND),HL     ; Clear variables
062C: 221F21   [117]            LD      (ARREND),HL     ; Clear arrays
                        
062F: C1       [10]     CLREG:  POP     BC              ; Save return address
0630: 2A9F20   [26]             LD      HL,(STRSPC)     ; Get end of working RAN
0633: F9       [32]             LD      SP,HL           ; Set stack
0634: 21F820   [42]             LD      HL,TMSTPL       ; Temporary string pool
0637: 22F620   [58]             LD      (TMSTPT),HL     ; Reset temporary string ptr
063A: AF       [62]             XOR     A               ; A = 00
063B: 6F       [66]             LD      L,A             ; HL = 0000
063C: 67       [70]             LD      H,A
063D: 221921   [86]             LD      (CONTAD),HL     ; No CONTinue
0640: 321021   [99]             LD      (FORFLG),A      ; Clear FOR flag
0643: 222321   [115]            LD      (FNRGNM),HL     ; Clear FN argument
0646: E5       [126]            PUSH    HL              ; HL = 0000
0647: C5       [137]            PUSH    BC              ; Put back return
0648: 2A1321   [16]     DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
064B: C9       [26]             RET                     ; Return to execution driver
                        
064C: 3E3F     [ 7]     PROMPT: LD      A,'?'           ; '?'
064E: CDD607   [24]             CALL    OUTC            ; Output character
0651: 3E20     [31]             LD      A,' '           ; Space
0653: CDD607   [48]             CALL    OUTC            ; Output character
0656: C39320   [58]             JP      RINPUT          ; Get input line
                        
0659: AF       [ 4]     CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
065A: 32F320   [17]             LD      (DATFLG),A      ; Reset literal flag
065D: 0E05     [24]             LD      C,2+3           ; 2 byte number and 3 nulls
065F: 11A620   [34]             LD      DE,BUFFER       ; Start of input buffer
0662: 7E       [ 7]     CRNCLP: LD      A,(HL)          ; Get byte
0663: FE20     [14]             CP      ' '             ; Is it a space?
0665: CAE106   [24|24]          JP      Z,MOVDIR        ; Yes - Copy direct
0668: 47       [28]             LD      B,A             ; Save character
0669: FE22     [35]             CP      '"'             ; Is it a quote?
066B: CA0107   [45|45]          JP      Z,CPYLIT        ; Yes - Copy literal string
066E: B7       [49]             OR      A               ; Is it end of buffer?
066F: CA0807   [59|59]          JP      Z,ENDBUF        ; Yes - End buffer
0672: 3AF320   [72]             LD      A,(DATFLG)      ; Get data type
0675: B7       [76]             OR      A               ; Literal?
0676: 7E       [83]             LD      A,(HL)          ; Get byte to copy
0677: C2E106   [93|93]          JP      NZ,MOVDIR       ; Literal - Copy direct
067A: FE3F     [100]            CP      '?'             ; Is it '?' short for PRINT
067C: 3E9E     [107]            LD      A,ZPRINT        ; "PRINT" token
067E: CAE106   [117|117]        JP      Z,MOVDIR        ; Yes - replace it
0681: 7E       [124]            LD      A,(HL)          ; Get byte again
0682: FE30     [131]            CP      '0'             ; Is it less than '0'
0684: DA8C06   [141|141]        JP      C,FNDWRD        ; Yes - Look for reserved words
0687: FE3C     [148]            CP      60; ";"+1           ; Is it "0123456789:;" ?
0689: DAE106   [158|158]        JP      C,MOVDIR        ; Yes - copy it direct
068C: D5       [11]     FNDWRD: PUSH    DE              ; Look for reserved words
068D: 118502   [21]             LD      DE,WORDS-1      ; Point to table
0690: C5       [32]             PUSH    BC              ; Save count
0691: 01DD06   [42]             LD      BC,RETNAD       ; Where to return to
0694: C5       [53]             PUSH    BC              ; Save return address
0695: 067F     [60]             LD      B,ZEND-1        ; First token value -1
0697: 7E       [67]             LD      A,(HL)          ; Get byte
0698: FE61     [74]             CP      'a'             ; Less than 'a' ?
069A: DAA506   [84|84]          JP      C,SEARCH        ; Yes - search for words
069D: FE7B     [91]             CP      'z'+1           ; Greater than 'z' ?
069F: D2A506   [101|101]        JP      NC,SEARCH       ; Yes - search for words
06A2: E65F     [108]            AND     01011111B       ; Force upper case
06A4: 77       [115]            LD      (HL),A          ; Replace byte
06A5: 4E       [ 7]     SEARCH: LD      C,(HL)          ; Search for a word
06A6: EB       [11]             EX      DE,HL
06A7: 23       [ 6]     GETNXT: INC     HL              ; Get next reserved word
06A8: B6       [13]             OR      (HL)            ; Start of word?
06A9: F2A706   [23|23]          JP      P,GETNXT        ; No - move on
06AC: 04       [27]             INC     B               ; Increment token value
06AD: 7E       [34]             LD      A, (HL)         ; Get byte from table
06AE: E67F     [41]             AND     01111111B       ; Strip bit 7
06B0: C8       [46|52]          RET     Z               ; Return if end of list
06B1: B9       [50]             CP      C               ; Same character as in buffer?
06B2: C2A706   [60|60]          JP      NZ,GETNXT       ; No - get next word
06B5: EB       [64]             EX      DE,HL
06B6: E5       [75]             PUSH    HL              ; Save start of word
                        
06B7: 13       [ 6]     NXTBYT: INC     DE              ; Look through rest of word
06B8: 1A       [13]             LD      A,(DE)          ; Get byte from table
06B9: B7       [17]             OR      A               ; End of word ?
06BA: FAD906   [27|27]          JP      M,MATCH         ; Yes - Match found
06BD: 4F       [31]             LD      C,A             ; Save it
06BE: 78       [35]             LD      A,B             ; Get token value
06BF: FE88     [42]             CP      ZGOTO           ; Is it "GOTO" token ?
06C1: C2C806   [52|52]          JP      NZ,NOSPC        ; No - Don't allow spaces
06C4: CD5509   [69]             CALL    GETCHR          ; Get next character
06C7: 2B       [75]             DEC     HL              ; Cancel increment from GETCHR
06C8: 23       [ 6]     NOSPC:  INC     HL              ; Next byte
06C9: 7E       [13]             LD      A,(HL)          ; Get byte
06CA: FE61     [20]             CP      'a'             ; Less than 'a' ?
06CC: DAD106   [30|30]          JP      C,NOCHNG        ; Yes - don't change
06CF: E65F     [37]             AND     01011111B       ; Make upper case
06D1: B9       [ 4]     NOCHNG: CP      C               ; Same as in buffer ?
06D2: CAB706   [14|14]          JP      Z,NXTBYT        ; Yes - keep testing
06D5: E1       [24]             POP     HL              ; Get back start of word
06D6: C3A506   [34]             JP      SEARCH          ; Look at next word
                        
06D9: 48       [ 4]     MATCH:  LD      C,B             ; Word found - Save token value
06DA: F1       [14]             POP     AF              ; Throw away return
06DB: EB       [18]             EX      DE,HL
06DC: C9       [28]             RET                     ; Return to "RETNAD"
06DD: EB       [ 4]     RETNAD: EX      DE,HL           ; Get address in string
06DE: 79       [ 8]             LD      A,C             ; Get token value
06DF: C1       [18]             POP     BC              ; Restore buffer length
06E0: D1       [28]             POP     DE              ; Get destination address
06E1: 23       [ 6]     MOVDIR: INC     HL              ; Next source in buffer
06E2: 12       [13]             LD      (DE),A          ; Put byte in buffer
06E3: 13       [19]             INC     DE              ; Move up buffer
06E4: 0C       [23]             INC     C               ; Increment length of buffer
06E5: D63A     [30]             SUB     ':'             ; End of statement?
06E7: CAEF06   [40|40]          JP      Z,SETLIT        ; Jump if multi-statement line
06EA: FE49     [47]             CP      ZDATA-3AH       ; Is it DATA statement ?
06EC: C2F206   [57|57]          JP      NZ,TSTREM       ; No - see if REM
06EF: 32F320   [13]     SETLIT: LD      (DATFLG),A      ; Set literal flag
06F2: D654     [ 7]     TSTREM: SUB     ZREM-3AH        ; Is it REM?
06F4: C26206   [17|17]          JP      NZ,CRNCLP       ; No - Leave flag
06F7: 47       [21]             LD      B,A             ; Copy rest of buffer
06F8: 7E       [ 7]     NXTCHR: LD      A,(HL)          ; Get byte
06F9: B7       [11]             OR      A               ; End of line ?
06FA: CA0807   [21|21]          JP      Z,ENDBUF        ; Yes - Terminate buffer
06FD: B8       [25]             CP      B               ; End of statement ?
06FE: CAE106   [35|35]          JP      Z,MOVDIR        ; Yes - Get next one
0701: 23       [ 6]     CPYLIT: INC     HL              ; Move up source string
0702: 12       [13]             LD      (DE),A          ; Save in destination
0703: 0C       [17]             INC     C               ; Increment length
0704: 13       [23]             INC     DE              ; Move up destination
0705: C3F806   [33]             JP      NXTCHR          ; Repeat
                        
0708: 21A520   [10]     ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
070B: 12       [17]             LD      (DE),A          ; Mark end of buffer (A = 00)
070C: 13       [23]             INC     DE
070D: 12       [30]             LD      (DE),A          ; A = 00
070E: 13       [36]             INC     DE
070F: 12       [43]             LD      (DE),A          ; A = 00
0710: C9       [53]             RET
                        
0711: 3A8920   [13]     DODEL:  LD      A,(NULFLG)      ; Get null flag status
0714: B7       [17]             OR      A               ; Is it zero?
0715: 3E00     [24]             LD      A,0             ; Zero A - Leave flags
0717: 328920   [37]             LD      (NULFLG),A      ; Zero null flag
071A: C22507   [47|47]          JP      NZ,ECHDEL       ; Set - Echo it
071D: 05       [51]             DEC     B               ; Decrement length
071E: CA4207   [61|61]          JP      Z,GETLIN        ; Get line again if empty
0721: CDD607   [78]             CALL    OUTC            ; Output null character
0724: 3E                        .BYTE   3EH             ; Skip "DEC B"
0725: 05       [ 4]     ECHDEL: DEC     B               ; Count bytes in buffer
0726: 2B       [10]             DEC     HL              ; Back space buffer
0727: CA3907   [20|20]          JP      Z,OTKLN         ; No buffer - Try again
072A: 7E       [27]             LD      A,(HL)          ; Get deleted byte
072B: CDD607   [44]             CALL    OUTC            ; Echo it
072E: C34B07   [54]             JP      MORINP          ; Get more input
                        
0731: 05       [ 4]     DELCHR: DEC     B               ; Count bytes in buffer
0732: 2B       [10]             DEC     HL              ; Back space buffer
0733: CDD607   [27]             CALL    OUTC            ; Output character in A
0736: C24B07   [37|37]          JP      NZ,MORINP       ; Not end - Get more
0739: CDD607   [17]     OTKLN:  CALL    OUTC            ; Output character in A
073C: CDFD0B   [17]     KILIN:  CALL    PRNTCRLF        ; Output CRLF
073F: C34207   [27]             JP      TTYLIN          ; Get line again
                        
0742:                   GETLIN:
0742: 21A620   [10]     TTYLIN: LD      HL,BUFFER       ; Get a line by character
0745: 0601     [17]             LD      B,1             ; Set buffer as empty
0747: AF       [21]             XOR     A
0748: 328920   [34]             LD      (NULFLG),A      ; Clear null flag
074B: CD0008   [17]     MORINP: CALL    CLOTST          ; Get character and test ^O
074E: 4F       [21]             LD      C,A             ; Save character in C
074F: FE7F     [28]             CP      DEL             ; Delete character?
0751: CA1107   [38|38]          JP      Z,DODEL         ; Yes - Process it
0754: 3A8920   [51]             LD      A,(NULFLG)      ; Get null flag
0757: B7       [55]             OR      A               ; Test null flag status
0758: CA6407   [65|65]          JP      Z,PROCES        ; Reset - Process character
075B: 3E00     [72]             LD      A,0             ; Set a null
075D: CDD607   [89]             CALL    OUTC            ; Output null
0760: AF       [93]             XOR     A               ; Clear A
0761: 328920   [106]            LD      (NULFLG),A      ; Reset null flag
0764: 79       [ 4]     PROCES: LD      A,C             ; Get character
0765: FE07     [11]             CP      CTRLG           ; Bell?
0767: CAA807   [21|21]          JP      Z,PUTCTL        ; Yes - Save it
076A: FE03     [28]             CP      CTRLC           ; Is it control "C"?
076C: CCFD0B   [38|45]          CALL    Z,PRNTCRLF      ; Yes - Output CRLF
076F: 37       [42]             SCF                     ; Flag break
0770: C8       [47|53]          RET     Z               ; Return if control "C"
0771: FE0D     [54]             CP      CR              ; Is it enter?
0773: CAF80B   [64|64]          JP      Z,ENDINP        ; Yes - Terminate input
0776: FE15     [71]             CP      CTRLU           ; Is it control "U"?
0778: CA3C07   [81|81]          JP      Z,KILIN         ; Yes - Get another line
077B: FE40     [88]             CP      '@'             ; Is it "kill line"?
077D: CA3907   [98|98]          JP      Z,OTKLN         ; Yes - Kill line
0780: FE5F     [105]            CP      '_'             ; Is it delete?
0782: CA3107   [115|115]        JP      Z,DELCHR        ; Yes - Delete character
0785: FE08     [122]            CP      BKSP            ; Is it backspace?
0787: CA3107   [132|132]        JP      Z,DELCHR        ; Yes - Delete character
078A: FE12     [139]            CP      CTRLR           ; Is it control "R"?
078C: C2A307   [149|149]        JP      NZ,PUTBUF       ; No - Put in buffer
078F: C5       [160]            PUSH    BC              ; Save buffer length
0790: D5       [171]            PUSH    DE              ; Save DE
0791: E5       [182]            PUSH    HL              ; Save buffer address
0792: 3600     [192]            LD      (HL),0          ; Mark end of buffer
0794: CDAD1D   [209]            CALL    OUTNCR          ; Output and do CRLF
0797: 21A620   [219]            LD      HL,BUFFER       ; Point to buffer start
079A: CD9B12   [236]            CALL    PRS             ; Output buffer
079D: E1       [246]            POP     HL              ; Restore buffer address
079E: D1       [256]            POP     DE              ; Restore DE
079F: C1       [266]            POP     BC              ; Restore buffer length
07A0: C34B07   [276]            JP      MORINP          ; Get another character
                        
07A3: FE20     [ 7]     PUTBUF: CP      ' '             ; Is it a control code?
07A5: DA4B07   [17|17]          JP      C,MORINP        ; Yes - Ignore
07A8: 78       [ 4]     PUTCTL: LD      A,B             ; Get number of bytes in buffer
07A9: FE49     [11]             CP      72+1            ; Test for line overflow
07AB: 3E07     [18]             LD      A,CTRLG         ; Set a bell
07AD: D2BD07   [28|28]          JP      NC,OUTNBS       ; Ring bell if buffer full
07B0: 79       [32]             LD      A,C             ; Get character
07B1: 71       [39]             LD      (HL),C          ; Save in buffer
07B2: 321121   [52]             LD      (LSTBIN),A      ; Save last input byte
07B5: 23       [58]             INC     HL              ; Move up buffer
07B6: 04       [62]             INC     B               ; Increment length
07B7: CDD607   [17]     OUTIT:  CALL    OUTC            ; Output the character entered
07BA: C34B07   [27]             JP      MORINP          ; Get another character
                        
07BD: CDD607   [17]     OUTNBS: CALL    OUTC            ; Output bell and back over it
07C0: 3E08     [24]             LD      A,BKSP          ; Set back space
07C2: C3B707   [34]             JP      OUTIT           ; Output it and get more
                        
07C5: 7C       [ 4]     CPDEHL: LD      A,H             ; Get H
07C6: 92       [ 8]             SUB     D               ; Compare with D
07C7: C0       [13|19]          RET     NZ              ; Different - Exit
07C8: 7D       [17]             LD      A,L             ; Get L
07C9: 93       [21]             SUB     E               ; Compare with E
07CA: C9       [31]             RET                     ; Return status
                        
07CB: 7E       [ 7]     CHKSYN: LD      A,(HL)          ; Check syntax of character
07CC: E3       [26]             EX      (SP),HL         ; Address of test byte
07CD: BE       [33]             CP      (HL)            ; Same as in code string?
07CE: 23       [39]             INC     HL              ; Return address
07CF: E3       [58]             EX      (SP),HL         ; Put it back
07D0: CA5509   [68|68]          JP      Z,GETCHR        ; Yes - Get next character
07D3: C3FD04   [78]             JP      SNERR           ; Different - ?SN Error
                        
07D6: F5       [11]     OUTC:   PUSH    AF              ; Save character
07D7: 3A8A20   [24]             LD      A,(CTLOFG)      ; Get control "O" flag
07DA: B7       [28]             OR      A               ; Is it set?
07DB: C2D012   [38|38]          JP      NZ,POPAF        ; Yes - don't output
07DE: F1       [48]             POP     AF              ; Restore character
07DF: C5       [59]             PUSH    BC              ; Save buffer length
07E0: F5       [70]             PUSH    AF              ; Save character
07E1: FE20     [77]             CP      ' '             ; Is it a control code?
07E3: DAFA07   [87|87]          JP      C,DINPOS        ; Yes - Don't INC POS(X)
07E6: 3A8720   [100]            LD      A,(LWIDTH)      ; Get line width
07E9: 47       [104]            LD      B,A             ; To B
07EA: 3AF020   [117]            LD      A,(CURPOS)      ; Get cursor position
07ED: 04       [121]            INC     B               ; Width 255?
07EE: CAF607   [131|131]        JP      Z,INCLEN        ; Yes - No width limit
07F1: 05       [135]            DEC     B               ; Restore width
07F2: B8       [139]            CP      B               ; At end of line?
07F3: CCFD0B   [149|156]        CALL    Z,PRNTCRLF      ; Yes - output CRLF
07F6: 3C       [ 4]     INCLEN: INC     A               ; Move on one character
07F7: 32F020   [17]             LD      (CURPOS),A      ; Save new position
07FA: F1       [10]     DINPOS: POP     AF              ; Restore character
07FB: C1       [20]             POP     BC              ; Restore buffer length
07FC: CD961D   [37]             CALL    MONOUT          ; Send it
07FF: C9       [47]             RET
                        
0800: CD5A1C   [17]     CLOTST: CALL    GETINP          ; Get input character
0803: E67F     [24]             AND     01111111B       ; Strip bit 7
0805: FE0F     [31]             CP      CTRLO           ; Is it control "O"?
0807: C0       [36|42]          RET     NZ              ; No don't flip flag
0808: 3A8A20   [49]             LD      A,(CTLOFG)      ; Get flag
080B: 2F       [53]             CPL                     ; Flip it
080C: 328A20   [66]             LD      (CTLOFG),A      ; Put it back
080F: AF       [70]             XOR     A               ; Null character
0810: C9       [80]             RET
                        
0811: CD210A   [17]     LIST:   CALL    ATOH            ; ASCII number to DE
0814: C0       [22|28]          RET     NZ              ; Return if anything extra
0815: C1       [32]             POP     BC              ; Rubbish - Not needed
0816: CDE905   [49]             CALL    SRCHLN          ; Search for line number in DE
0819: C5       [60]             PUSH    BC              ; Save address of line
081A: CD6708   [77]             CALL    SETLIN          ; Set up lines counter
081D: E1       [10]     LISTLP: POP     HL              ; Restore address of line
081E: 4E       [17]             LD      C,(HL)          ; Get LSB of next line
081F: 23       [23]             INC     HL
0820: 46       [30]             LD      B,(HL)          ; Get MSB of next line
0821: 23       [36]             INC     HL
0822: 78       [40]             LD      A,B             ; BC = 0 (End of program)?
0823: B1       [44]             OR      C
0824: CA4805   [54|54]          JP      Z,PRNTOK        ; Yes - Go to command mode
0827: CD7008   [71]             CALL    COUNT           ; Count lines
082A: CD8009   [88]             CALL    TSTBRK          ; Test for break key
082D: C5       [99]             PUSH    BC              ; Save address of next line
082E: CDFD0B   [116]            CALL    PRNTCRLF        ; Output CRLF
0831: 5E       [123]            LD      E,(HL)          ; Get LSB of line number
0832: 23       [129]            INC     HL
0833: 56       [136]            LD      D,(HL)          ; Get MSB of line number
0834: 23       [142]            INC     HL
0835: E5       [153]            PUSH    HL              ; Save address of line start
0836: EB       [157]            EX      DE,HL           ; Line number to HL
0837: CD3E19   [174]            CALL    PRNTHL          ; Output line number in decimal
083A: 3E20     [181]            LD      A,' '           ; Space after line number
083C: E1       [191]            POP     HL              ; Restore start of line address
083D: CDD607   [17]     LSTLP2: CALL    OUTC            ; Output character in A
0840: 7E       [ 7]     LSTLP3: LD      A,(HL)          ; Get next byte in line
0841: B7       [11]             OR      A               ; End of line?
0842: 23       [17]             INC     HL              ; To next byte in line
0843: CA1D08   [27|27]          JP      Z,LISTLP        ; Yes - get next line
0846: F23D08   [37|37]          JP      P,LSTLP2        ; No token - output it
0849: D67F     [44]             SUB     ZEND-1          ; Find and output word
084B: 4F       [48]             LD      C,A             ; Token offset+1 to C
084C: 118602   [58]             LD      DE,WORDS        ; Reserved word list
084F: 1A       [ 7]     FNDTOK: LD      A,(DE)          ; Get character in list
0850: 13       [13]             INC     DE              ; Move on to next
0851: B7       [17]             OR      A               ; Is it start of word?
0852: F24F08   [27|27]          JP      P,FNDTOK        ; No - Keep looking for word
0855: 0D       [31]             DEC     C               ; Count words
0856: C24F08   [41|41]          JP      NZ,FNDTOK       ; Not there - keep looking
0859: E67F     [ 7]     OUTWRD: AND     01111111B       ; Strip bit 7
085B: CDD607   [24]             CALL    OUTC            ; Output first character
085E: 1A       [31]             LD      A,(DE)          ; Get next character
085F: 13       [37]             INC     DE              ; Move on to next
0860: B7       [41]             OR      A               ; Is it end of word?
0861: F25908   [51|51]          JP      P,OUTWRD        ; No - output the rest
0864: C34008   [61]             JP      LSTLP3          ; Next byte in line
                        
0867: E5       [11]     SETLIN: PUSH    HL              ; Set up LINES counter
0868: 2A8D20   [27]             LD      HL,(LINESN)     ; Get LINES number
086B: 228B20   [43]             LD      (LINESC),HL     ; Save in LINES counter
086E: E1       [53]             POP     HL
086F: C9       [63]             RET
                        
0870: E5       [11]     COUNT:  PUSH    HL              ; Save code string address
0871: D5       [22]             PUSH    DE
0872: 2A8B20   [38]             LD      HL,(LINESC)     ; Get LINES counter
0875: 11FFFF   [48]             LD      DE,-1
0878: ED5A     [63]             ADC     HL,DE           ; Decrement
087A: 228B20   [79]             LD      (LINESC),HL     ; Put it back
087D: D1       [89]             POP     DE
087E: E1       [99]             POP     HL              ; Restore code string address
087F: F0       [104|110]        RET     P               ; Return if more lines to go
0880: E5       [115]            PUSH    HL              ; Save code string address
0881: 2A8D20   [131]            LD      HL,(LINESN)     ; Get LINES number
0884: 228B20   [147]            LD      (LINESC),HL     ; Reset LINES counter
0887: CD5A1C   [164]            CALL    GETINP          ; Get input character
088A: FE03     [171]            CP      CTRLC           ; Is it control "C"?
088C: CA9308   [181|181]        JP      Z,RSLNBK        ; Yes - Reset LINES and break
088F: E1       [191]            POP     HL              ; Restore code string address
0890: C37008   [201]            JP      COUNT           ; Keep on counting
                        
0893: 2A8D20   [16]     RSLNBK: LD      HL,(LINESN)     ; Get LINES number
0896: 228B20   [32]             LD      (LINESC),HL     ; Reset LINES counter
0899: C3F701   [42]             JP      BRKRET          ; Go and output "Break"
                        
089C: 3E64     [ 7]     FOR:    LD      A,64H           ; Flag "FOR" assignment
089E: 321021   [20]             LD      (FORFLG),A      ; Save "FOR" flag
08A1: CD030B   [37]             CALL    LET             ; Set up initial index
08A4: C1       [47]             POP     BC              ; Drop RETurn address
08A5: E5       [58]             PUSH    HL              ; Save code string address
08A6: CDEC0A   [75]             CALL    DATA            ; Get next statement address
08A9: 220C21   [91]             LD      (LOOPST),HL     ; Save it for start of loop
08AC: 210200   [101]            LD      HL,2            ; Offset for "FOR" block
08AF: 39       [112]            ADD     HL,SP           ; Point to it
08B0: CDAA04   [17]     FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
08B3: D1       [27]             POP     DE              ; Get code string address
08B4: C2CC08   [37|37]          JP      NZ,FORFND       ; No nesting found
08B7: 09       [48]             ADD     HL,BC           ; Move into "FOR" block
08B8: D5       [59]             PUSH    DE              ; Save code string address
08B9: 2B       [65]             DEC     HL
08BA: 56       [72]             LD      D,(HL)          ; Get MSB of loop statement
08BB: 2B       [78]             DEC     HL
08BC: 5E       [85]             LD      E,(HL)          ; Get LSB of loop statement
08BD: 23       [91]             INC     HL
08BE: 23       [97]             INC     HL
08BF: E5       [108]            PUSH    HL              ; Save block address
08C0: 2A0C21   [124]            LD      HL,(LOOPST)     ; Get address of loop statement
08C3: CDC507   [141]            CALL    CPDEHL          ; Compare the FOR loops
08C6: E1       [151]            POP     HL              ; Restore block address
08C7: C2B008   [161|161]        JP      NZ,FORSLP       ; Different FORs - Find another
08CA: D1       [171]            POP     DE              ; Restore code string address
08CB: F9       [177]            LD      SP,HL           ; Remove all nested loops
                        
08CC: EB       [ 4]     FORFND: EX      DE,HL           ; Code string address to HL
08CD: 0E08     [11]             LD      C,8
08CF: CDDA04   [28]             CALL    CHKSTK          ; Check for 8 levels of stack
08D2: E5       [39]             PUSH    HL              ; Save code string address
08D3: 2A0C21   [55]             LD      HL,(LOOPST)     ; Get first statement of loop
08D6: E3       [74]             EX      (SP),HL         ; Save and restore code string
08D7: E5       [85]             PUSH    HL              ; Re-save code string address
08D8: 2AA120   [101]            LD      HL,(LINEAT)     ; Get current line number
08DB: E3       [120]            EX      (SP),HL         ; Save and restore code string
08DC: CDC50D   [137]            CALL    TSTNUM          ; Make sure it's a number
08DF: CDCB07   [154]            CALL    CHKSYN          ; Make sure "TO" is next
08E2: A6                        .BYTE   ZTO          ; "TO" token
08E3: CDC20D   [171]            CALL    GETNUM          ; Get "TO" expression value
08E6: E5       [182]            PUSH    HL              ; Save code string address
08E7: CDF017   [199]            CALL    BCDEFP          ; Move "TO" value to BCDE
08EA: E1       [209]            POP     HL              ; Restore code string address
08EB: C5       [220]            PUSH    BC              ; Save "TO" value in block
08EC: D5       [231]            PUSH    DE
08ED: 010081   [241]            LD      BC,8100H        ; BCDE - 1 (default STEP)
08F0: 51       [245]            LD      D,C             ; C=0
08F1: 5A       [249]            LD      E,D             ; D=0
08F2: 7E       [256]            LD      A,(HL)          ; Get next byte in code string
08F3: FEAB     [263]            CP      ZSTEP           ; See if "STEP" is stated
08F5: 3E01     [270]            LD      A,1             ; Sign of step = 1
08F7: C20809   [280|280]        JP      NZ,SAVSTP       ; No STEP given - Default to 1
08FA: CD5509   [297]            CALL    GETCHR          ; Jump over "STEP" token
08FD: CDC20D   [314]            CALL    GETNUM          ; Get step value
0900: E5       [325]            PUSH    HL              ; Save code string address
0901: CDF017   [342]            CALL    BCDEFP          ; Move STEP to BCDE
0904: CDA417   [359]            CALL    TSTSGN          ; Test sign of FPREG
0907: E1       [369]            POP     HL              ; Restore code string address
0908: C5       [11]     SAVSTP: PUSH    BC              ; Save the STEP value in block
0909: D5       [22]             PUSH    DE
090A: F5       [33]             PUSH    AF              ; Save sign of STEP
090B: 33       [39]             INC     SP              ; Don't save flags
090C: E5       [50]             PUSH    HL              ; Save code string address
090D: 2A1321   [66]             LD      HL,(BRKLIN)     ; Get address of index variable
0910: E3       [85]             EX      (SP),HL         ; Save and restore code string
0911: 0681     [ 7]     PUTFID: LD      B,ZFOR          ; "FOR" block marker
0913: C5       [18]             PUSH    BC              ; Save it
0914: 33       [24]             INC     SP              ; Don't save C
                        
0915: CD8009   [17]     RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
0918: 221321   [33]             LD      (BRKLIN),HL     ; Save code address for break
091B: 7E       [40]             LD      A,(HL)          ; Get next byte in code string
091C: FE3A     [47]             CP      ':'             ; Multi statement line?
091E: CA3509   [57|57]          JP      Z,EXCUTE        ; Yes - Execute it
0921: B7       [61]             OR      A               ; End of line?
0922: C2FD04   [71|71]          JP      NZ,SNERR        ; No - Syntax error
0925: 23       [77]             INC     HL              ; Point to address of next line
0926: 7E       [84]             LD      A,(HL)          ; Get LSB of line pointer
0927: 23       [90]             INC     HL
0928: B6       [97]             OR      (HL)            ; Is it zero (End of prog)?
0929: CAA709   [107|107]        JP      Z,ENDPRG        ; Yes - Terminate execution
092C: 23       [113]            INC     HL              ; Point to line number
092D: 5E       [120]            LD      E,(HL)          ; Get LSB of line number
092E: 23       [126]            INC     HL
092F: 56       [133]            LD      D,(HL)          ; Get MSB of line number
0930: EB       [137]            EX      DE,HL           ; Line number to HL
0931: 22A120   [153]            LD      (LINEAT),HL     ; Save as current line number
0934: EB       [157]            EX      DE,HL           ; Line number back to DE
0935: CD5509   [17]     EXCUTE: CALL    GETCHR          ; Get key word
0938: 111509   [27]             LD      DE,RUNCNT       ; Where to RETurn to
093B: D5       [38]             PUSH    DE              ; Save for RETurn
093C: C8       [ 5|11]  IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
093D: D680     [ 7]     ONJMP:  SUB     ZEND            ; Is it a token?
093F: DA030B   [17|17]          JP      C,LET           ; No - try to assign it
0942: FE25     [24]             CP      ZNEW+1-ZEND     ; END to NEW ?
0944: D2FD04   [34|34]          JP      NC,SNERR        ; Not a key word - ?SN Error
0947: 07       [38]             RLCA                    ; Double it
0948: 4F       [42]             LD      C,A             ; BC = Offset into table
0949: 0600     [49]             LD      B,0
094B: EB       [53]             EX      DE,HL           ; Save code string address
094C: 21A503   [63]             LD      HL,WORDTB       ; Keyword address table
094F: 09       [74]             ADD     HL,BC           ; Point to routine address
0950: 4E       [81]             LD      C,(HL)          ; Get LSB of routine address
0951: 23       [87]             INC     HL
0952: 46       [94]             LD      B,(HL)          ; Get MSB of routine address
0953: C5       [105]            PUSH    BC              ; Save routine address
0954: EB       [109]            EX      DE,HL           ; Restore code string address
                        
0955: 23       [ 6]     GETCHR: INC     HL              ; Point to next character
0956: 7E       [13]             LD      A,(HL)          ; Get next code string byte
0957: FE3A     [20]             CP      ':'             ; Z if ':'
0959: D0       [25|31]          RET     NC              ; NC if > "9"
095A: FE20     [32]             CP      ' '
095C: CA5509   [42|42]          JP      Z,GETCHR        ; Skip over spaces
095F: FE30     [49]             CP      '0'
0961: 3F       [53]             CCF                     ; NC if < '0'
0962: 3C       [57]             INC     A               ; Test for zero - Leave carry
0963: 3D       [61]             DEC     A               ; Z if Null
0964: C9       [71]             RET
                        
0965: EB       [ 4]     RESTOR: EX      DE,HL           ; Save code string address
0966: 2AA320   [20]             LD      HL,(BASTXT)     ; Point to start of program
0969: CA7A09   [30|30]          JP      Z,RESTNL        ; Just RESTORE - reset pointer
096C: EB       [34]             EX      DE,HL           ; Restore code string address
096D: CD210A   [51]             CALL    ATOH            ; Get line number to DE
0970: E5       [62]             PUSH    HL              ; Save code string address
0971: CDE905   [79]             CALL    SRCHLN          ; Search for line number in DE
0974: 60       [83]             LD      H,B             ; HL = Address of line
0975: 69       [87]             LD      L,C
0976: D1       [97]             POP     DE              ; Restore code string address
0977: D2C20A   [107|107]        JP      NC,ULERR        ; ?UL Error if not found
097A: 2B       [ 6]     RESTNL: DEC     HL              ; Byte before DATA statement
097B: 222121   [16]     UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
097E: EB       [20]             EX      DE,HL           ; Restore code string address
097F: C9       [30]             RET
                        
                        
0980: DF       [11]     TSTBRK: RST     18H             ; Check input status
0981: C8       [16|22]          RET     Z               ; No key, go back
0982: D7       [27]             RST     10H             ; Get the key into A
0983: FE1B     [34]             CP      ESC             ; Escape key?
0985: 2811     [41|46]          JR      Z,BRK           ; Yes, break
0987: FE03     [48]             CP      CTRLC           ; <Ctrl-C>
0989: 280D     [55|60]          JR      Z,BRK           ; Yes, break
098B: FE13     [62]             CP      CTRLS           ; Stop scrolling?
098D: C0       [67|73]          RET     NZ              ; Other key, ignore
                        
                        
098E: D7       [11]     STALL:  RST     10H             ; Wait for key
098F: FE11     [18]             CP      CTRLQ           ; Resume scrolling?
0991: C8       [23|29]          RET      Z              ; Release the chokehold
0992: FE03     [30]             CP      CTRLC           ; Second break?
0994: 2807     [37|42]          JR      Z,STOP          ; Break during hold exits prog
0996: 18F6     [49]             JR      STALL           ; Loop until <Ctrl-Q> or <brk>
                        
0998: 3EFF     [ 7]     BRK     LD      A,$FF           ; Set BRKFLG
099A: 329220   [20]             LD      (BRKFLG),A      ; Store it
                        
                        
099D: C0       [ 5|11]  STOP:   RET     NZ              ; Exit if anything else
099E: F6                        .BYTE   0F6H            ; Flag "STOP"
099F: C0       [ 5|11]  PEND:   RET     NZ              ; Exit if anything else
09A0: 221321   [21]             LD      (BRKLIN),HL     ; Save point of break
09A3: 21                        .BYTE   21H             ; Skip "OR 11111111B"
09A4: F6FF     [ 7]     INPBRK: OR      11111111B       ; Flag "Break" wanted
09A6: C1       [17]             POP     BC              ; Return not needed and more
09A7: 2AA120   [16]     ENDPRG: LD      HL,(LINEAT)     ; Get current line number
09AA: F5       [27]             PUSH    AF              ; Save STOP / END status
09AB: 7D       [31]             LD      A,L             ; Is it direct break?
09AC: A4       [35]             AND     H
09AD: 3C       [39]             INC     A               ; Line is -1 if direct break
09AE: CABA09   [49|49]          JP      Z,NOLIN         ; Yes - No line number
09B1: 221721   [65]             LD      (ERRLIN),HL     ; Save line of break
09B4: 2A1321   [81]             LD      HL,(BRKLIN)     ; Get point of break
09B7: 221921   [97]             LD      (CONTAD),HL     ; Save point to CONTinue
09BA: AF       [ 4]     NOLIN:  XOR     A
09BB: 328A20   [17]             LD      (CTLOFG),A      ; Enable output
09BE: CDF00B   [34]             CALL    STTLIN          ; Start a new line
09C1: F1       [44]             POP     AF              ; Restore STOP / END status
09C2: 21A004   [54]             LD      HL,BRKMSG       ; "Break" message
09C5: C23105   [64|64]          JP      NZ,ERRIN        ; "in line" wanted?
09C8: C34805   [74]             JP      PRNTOK          ; Go to command mode
                        
09CB: 2A1921   [16]     CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
09CE: 7C       [20]             LD      A,H             ; Is it zero?
09CF: B5       [24]             OR      L
09D0: 1E20     [31]             LD      E,CN            ; ?CN Error
09D2: CA1105   [41|41]          JP      Z,ERROR         ; Yes - output "?CN Error"
09D5: EB       [45]             EX      DE,HL           ; Save code string address
09D6: 2A1721   [61]             LD      HL,(ERRLIN)     ; Get line of last break
09D9: 22A120   [77]             LD      (LINEAT),HL     ; Set up current line number
09DC: EB       [81]             EX      DE,HL           ; Restore code string address
09DD: C9       [91]             RET                     ; CONTinue where left off
                        
09DE: CD2315   [17]     NULL:   CALL    GETINT          ; Get integer 0-255
09E1: C0       [22|28]          RET     NZ              ; Return if bad value
09E2: 328620   [35]             LD      (NULLS),A       ; Set nulls number
09E5: C9       [45]             RET
                        
                        
09E6: E5       [11]     ACCSUM: PUSH    HL              ; Save address in array
09E7: 2A8F20   [27]             LD      HL,(CHKSUM)     ; Get check sum
09EA: 0600     [34]             LD      B,0             ; BC - Value of byte
09EC: 4F       [38]             LD      C,A
09ED: 09       [49]             ADD     HL,BC           ; Add byte to check sum
09EE: 228F20   [65]             LD      (CHKSUM),HL     ; Re-save check sum
09F1: E1       [75]             POP     HL              ; Restore address in array
09F2: C9       [85]             RET
                        
09F3: 7E       [ 7]     CHKLTR: LD      A,(HL)          ; Get byte
09F4: FE41     [14]             CP      'A'             ; < 'a' ?
09F6: D8       [19|25]          RET     C               ; Carry set if not letter
09F7: FE5B     [26]             CP      'Z'+1           ; > 'z' ?
09F9: 3F       [30]             CCF
09FA: C9       [40]             RET                     ; Carry set if not letter
                        
09FB: CD5509   [17]     FPSINT: CALL    GETCHR          ; Get next character
09FE: CDC20D   [17]     POSINT: CALL    GETNUM          ; Get integer 0 to 32767
0A01: CDA417   [17]     DEPINT: CALL    TSTSGN          ; Test sign of FPREG
0A04: FA1C0A   [27|27]          JP      M,FCERR         ; Negative - ?FC Error
0A07: 3A2C21   [13]     DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
0A0A: FE90     [20]             CP      80H+16          ; Exponent in range (16 bits)?
0A0C: DA4C18   [30|30]          JP      C,FPINT         ; Yes - convert it
0A0F: 018090   [40]             LD      BC,9080H        ; BCDE = -32768
0A12: 110000   [50]             LD      DE,0000
0A15: E5       [61]             PUSH    HL              ; Save code string address
0A16: CD1F18   [78]             CALL    CMPNUM          ; Compare FPREG with BCDE
0A19: E1       [88]             POP     HL              ; Restore code string address
0A1A: 51       [92]             LD      D,C             ; MSB to D
0A1B: C8       [97|103]         RET     Z               ; Return if in range
0A1C: 1E08     [ 7]     FCERR:  LD      E,FC            ; ?FC Error
0A1E: C31105   [17]             JP      ERROR           ; Output error-
                        
0A21: 2B       [ 6]     ATOH:   DEC     HL              ; ASCII number to DE binary
0A22: 110000   [10]     GETLN:  LD      DE,0            ; Get number to DE
0A25: CD5509   [17]     GTLNLP: CALL    GETCHR          ; Get next character
0A28: D0       [22|28]          RET     NC              ; Exit if not a digit
0A29: E5       [33]             PUSH    HL              ; Save code string address
0A2A: F5       [44]             PUSH    AF              ; Save digit
0A2B: 219819   [54]             LD      HL,65529/10     ; Largest number 65529
0A2E: CDC507   [71]             CALL    CPDEHL          ; Number in range?
0A31: DAFD04   [81|81]          JP      C,SNERR         ; No - ?SN Error
0A34: 62       [85]             LD      H,D             ; HL = Number
0A35: 6B       [89]             LD      L,E
0A36: 19       [100]            ADD     HL,DE           ; Times 2
0A37: 29       [111]            ADD     HL,HL           ; Times 4
0A38: 19       [122]            ADD     HL,DE           ; Times 5
0A39: 29       [133]            ADD     HL,HL           ; Times 10
0A3A: F1       [143]            POP     AF              ; Restore digit
0A3B: D630     [150]            SUB     '0'             ; Make it 0 to 9
0A3D: 5F       [154]            LD      E,A             ; DE = Value of digit
0A3E: 1600     [161]            LD      D,0
0A40: 19       [172]            ADD     HL,DE           ; Add to number
0A41: EB       [176]            EX      DE,HL           ; Number to DE
0A42: E1       [186]            POP     HL              ; Restore code string address
0A43: C3250A   [196]            JP      GTLNLP          ; Go to next character
                        
0A46: CA1906   [10|10]  CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
0A49: CDFE09   [27]             CALL    POSINT          ; Get integer 0 to 32767 to DE
0A4C: 2B       [33]             DEC     HL              ; Cancel increment
0A4D: CD5509   [50]             CALL    GETCHR          ; Get next character
0A50: E5       [61]             PUSH    HL              ; Save code string address
0A51: 2AF420   [77]             LD      HL,(LSTRAM)     ; Get end of RAM
0A54: CA690A   [87|87]          JP      Z,STORED        ; No value given - Use stored
0A57: E1       [97]             POP     HL              ; Restore code string address
0A58: CDCB07   [114]            CALL    CHKSYN          ; Check for comma
0A5B: 2C                        .BYTE      ','
0A5C: D5       [125]            PUSH    DE              ; Save number
0A5D: CDFE09   [142]            CALL    POSINT          ; Get integer 0 to 32767
0A60: 2B       [148]            DEC     HL              ; Cancel increment
0A61: CD5509   [165]            CALL    GETCHR          ; Get next character
0A64: C2FD04   [175|175]        JP      NZ,SNERR        ; ?SN Error if more on line
0A67: E3       [194]            EX      (SP),HL         ; Save code string address
0A68: EB       [198]            EX      DE,HL           ; Number to DE
0A69: 7D       [ 4]     STORED: LD      A,L             ; Get LSB of new RAM top
0A6A: 93       [ 8]             SUB     E               ; Subtract LSB of string space
0A6B: 5F       [12]             LD      E,A             ; Save LSB
0A6C: 7C       [16]             LD      A,H             ; Get MSB of new RAM top
0A6D: 9A       [20]             SBC     A,D             ; Subtract MSB of string space
0A6E: 57       [24]             LD      D,A             ; Save MSB
0A6F: DAF204   [34|34]          JP      C,OMERR         ; ?OM Error if not enough mem
0A72: E5       [45]             PUSH    HL              ; Save RAM top
0A73: 2A1B21   [61]             LD      HL,(PROGND)     ; Get program end
0A76: 012800   [71]             LD      BC,40           ; 40 Bytes minimum working RAM
0A79: 09       [82]             ADD     HL,BC           ; Get lowest address
0A7A: CDC507   [99]             CALL    CPDEHL          ; Enough memory?
0A7D: D2F204   [109|109]        JP      NC,OMERR        ; No - ?OM Error
0A80: EB       [113]            EX      DE,HL           ; RAM top to HL
0A81: 229F20   [129]            LD      (STRSPC),HL     ; Set new string space
0A84: E1       [139]            POP     HL              ; End of memory to use
0A85: 22F420   [155]            LD      (LSTRAM),HL     ; Set new top of RAM
0A88: E1       [165]            POP     HL              ; Restore code string address
0A89: C31906   [175]            JP      INTVAR          ; Initialise variables
                        
0A8C: CA1506   [10|10]  RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
0A8F: CD1906   [27]             CALL    INTVAR          ; Initialise variables
0A92: 011509   [37]             LD      BC,RUNCNT       ; Execution driver loop
0A95: C3A80A   [47]             JP      RUNLIN          ; RUN from line number
                        
0A98: 0E03     [ 7]     GOSUB:  LD      C,3             ; 3 Levels of stack needed
0A9A: CDDA04   [24]             CALL    CHKSTK          ; Check for 3 levels of stack
0A9D: C1       [34]             POP     BC              ; Get return address
0A9E: E5       [45]             PUSH    HL              ; Save code string for RETURN
0A9F: E5       [56]             PUSH    HL              ; And for GOSUB routine
0AA0: 2AA120   [72]             LD      HL,(LINEAT)     ; Get current line
0AA3: E3       [91]             EX      (SP),HL         ; Into stack - Code string out
0AA4: 3E8C     [98]             LD      A,ZGOSUB        ; "GOSUB" token
0AA6: F5       [109]            PUSH    AF              ; Save token
0AA7: 33       [115]            INC     SP              ; Don't save flags
                        
0AA8: C5       [11]     RUNLIN: PUSH    BC              ; Save return address
0AA9: CD210A   [17]     GOTO:   CALL    ATOH            ; ASCII number to DE binary
0AAC: CDEE0A   [34]             CALL    REM             ; Get end of line
0AAF: E5       [45]             PUSH    HL              ; Save end of line
0AB0: 2AA120   [61]             LD      HL,(LINEAT)     ; Get current line
0AB3: CDC507   [78]             CALL    CPDEHL          ; Line after current?
0AB6: E1       [88]             POP     HL              ; Restore end of line
0AB7: 23       [94]             INC     HL              ; Start of next line
0AB8: DCEC05   [104|111]        CALL    C,SRCHLP        ; Line is after current line
0ABB: D4E905   [114|121]        CALL    NC,SRCHLN       ; Line is before current line
0ABE: 60       [118]            LD      H,B             ; Set up code string address
0ABF: 69       [122]            LD      L,C
0AC0: 2B       [128]            DEC     HL              ; Incremented after
0AC1: D8       [133|139]        RET     C               ; Line found
0AC2: 1E0E     [ 7]     ULERR:  LD      E,UL            ; ?UL Error
0AC4: C31105   [17]             JP      ERROR           ; Output error message
                        
0AC7: C0       [ 5|11]  RETURN: RET     NZ              ; Return if not just RETURN
0AC8: 16FF     [12]             LD      D,-1            ; Flag "GOSUB" search
0ACA: CDA604   [29]             CALL    BAKSTK          ; Look "GOSUB" block
0ACD: F9       [35]             LD      SP,HL           ; Kill all FORs in subroutine
0ACE: FE8C     [42]             CP      ZGOSUB          ; Test for "GOSUB" token
0AD0: 1E04     [49]             LD      E,RG            ; ?RG Error
0AD2: C21105   [59|59]          JP      NZ,ERROR        ; Error if no "GOSUB" found
0AD5: E1       [69]             POP     HL              ; Get RETURN line number
0AD6: 22A120   [85]             LD      (LINEAT),HL     ; Save as current
0AD9: 23       [91]             INC     HL              ; Was it from direct statement?
0ADA: 7C       [95]             LD      A,H
0ADB: B5       [99]             OR      L               ; Return to line
0ADC: C2E60A   [109|109]        JP      NZ,RETLIN       ; No - Return to line
0ADF: 3A1121   [122]            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
0AE2: B7       [126]            OR      A               ; If so buffer is corrupted
0AE3: C24705   [136|136]        JP      NZ,POPNOK       ; Yes - Go to command mode
0AE6: 211509   [10]     RETLIN: LD      HL,RUNCNT       ; Execution driver loop
0AE9: E3       [29]             EX      (SP),HL         ; Into stack - Code string out
0AEA: 3E                        .BYTE      3EH             ; Skip "POP HL"
0AEB: E1       [10]     NXTDTA: POP     HL              ; Restore code string address
                        
0AEC: 013A              DATA:   .BYTE      01H,3AH         ; ':' End of statement
0AEE: 0E00     [ 7]     REM:    LD      C,0             ; 00  End of statement
0AF0: 0600     [14]             LD      B,0
0AF2: 79       [ 4]     NXTSTL: LD      A,C             ; Statement and byte
0AF3: 48       [ 8]             LD      C,B
0AF4: 47       [12]             LD      B,A             ; Statement end byte
0AF5: 7E       [ 7]     NXTSTT: LD      A,(HL)          ; Get byte
0AF6: B7       [11]             OR      A               ; End of line?
0AF7: C8       [16|22]          RET     Z               ; Yes - Exit
0AF8: B8       [20]             CP      B               ; End of statement?
0AF9: C8       [25|31]          RET     Z               ; Yes - Exit
0AFA: 23       [31]             INC     HL              ; Next byte
0AFB: FE22     [38]             CP      '"'             ; Literal string?
0AFD: CAF20A   [48|48]          JP      Z,NXTSTL        ; Yes - Look for another '"'
0B00: C3F50A   [58]             JP      NXTSTT          ; Keep looking
                        
0B03: CDB80F   [17]     LET:    CALL    GETVAR          ; Get variable name
0B06: CDCB07   [34]             CALL    CHKSYN          ; Make sure "=" follows
0B09: B4                        .BYTE      ZEQUAL          ; "=" token
0B0A: D5       [45]             PUSH    DE              ; Save address of variable
0B0B: 3AF220   [58]             LD      A,(TYPE)        ; Get data type
0B0E: F5       [69]             PUSH    AF              ; Save type
0B0F: CDD40D   [86]             CALL    EVAL            ; Evaluate expression
0B12: F1       [96]             POP     AF              ; Restore type
0B13: E3       [115]            EX      (SP),HL         ; Save code - Get var addr
0B14: 221321   [131]            LD      (BRKLIN),HL     ; Save address of variable
0B17: 1F       [135]            RRA                     ; Adjust type
0B18: CDC70D   [152]            CALL    CHKTYP          ; Check types are the same
0B1B: CA560B   [162|162]        JP      Z,LETNUM        ; Numeric - Move value
0B1E: E5       [11]     LETSTR: PUSH    HL              ; Save address of string var
0B1F: 2A2921   [27]             LD      HL,(FPREG)      ; Pointer to string entry
0B22: E5       [38]             PUSH    HL              ; Save it on stack
0B23: 23       [44]             INC     HL              ; Skip over length
0B24: 23       [50]             INC     HL
0B25: 5E       [57]             LD      E,(HL)          ; LSB of string address
0B26: 23       [63]             INC     HL
0B27: 56       [70]             LD      D,(HL)          ; MSB of string address
0B28: 2AA320   [86]             LD      HL,(BASTXT)     ; Point to start of program
0B2B: CDC507   [103]            CALL    CPDEHL          ; Is string before program?
0B2E: D2450B   [113|113]        JP      NC,CRESTR       ; Yes - Create string entry
0B31: 2A9F20   [129]            LD      HL,(STRSPC)     ; Point to string space
0B34: CDC507   [146]            CALL    CPDEHL          ; Is string literal in program?
0B37: D1       [156]            POP     DE              ; Restore address of string
0B38: D24D0B   [166|166]        JP      NC,MVSTPT       ; Yes - Set up pointer
0B3B: 210421   [176]            LD      HL,TMPSTR       ; Temporary string pool
0B3E: CDC507   [193]            CALL    CPDEHL          ; Is string in temporary pool?
0B41: D24D0B   [203|203]        JP      NC,MVSTPT       ; No - Set up pointer
0B44: 3E                        .BYTE   3EH             ; Skip "POP DE"
0B45: D1       [10]     CRESTR: POP     DE              ; Restore address of string
0B46: CDFC13   [27]             CALL    BAKTMP          ; Back to last tmp-str entry
0B49: EB       [31]             EX      DE,HL           ; Address of string entry
0B4A: CD3512   [48]             CALL    SAVSTR          ; Save string in string area
0B4D: CDFC13   [17]     MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
0B50: E1       [27]             POP     HL              ; Get string pointer
0B51: CDFF17   [44]             CALL    DETHL4          ; Move string pointer to var
0B54: E1       [54]             POP     HL              ; Restore code string address
0B55: C9       [64]             RET
                        
0B56: E5       [11]     LETNUM: PUSH    HL              ; Save address of variable
0B57: CDFC17   [28]             CALL    FPTHL           ; Move value to variable
0B5A: D1       [38]             POP     DE              ; Restore address of variable
0B5B: E1       [48]             POP     HL              ; Restore code string address
0B5C: C9       [58]             RET
                        
0B5D: CD2315   [17]     ON:     CALL    GETINT          ; Get integer 0-255
0B60: 7E       [24]             LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
0B61: 47       [28]             LD      B,A             ; Save in B
0B62: FE8C     [35]             CP      ZGOSUB          ; "GOSUB" token?
0B64: CA6C0B   [45|45]          JP      Z,ONGO          ; Yes - Find line number
0B67: CDCB07   [62]             CALL    CHKSYN          ; Make sure it's "GOTO"
0B6A: 88                        .BYTE   ZGOTO           ; "GOTO" token
0B6B: 2B       [68]             DEC     HL              ; Cancel increment
0B6C: 4B       [ 4]     ONGO:   LD      C,E             ; Integer of branch value
0B6D: 0D       [ 4]     ONGOLP: DEC     C               ; Count branches
0B6E: 78       [ 8]             LD      A,B             ; Get "GOTO" or "GOSUB" token
0B6F: CA3D09   [18|18]          JP      Z,ONJMP         ; Go to that line if right one
0B72: CD220A   [35]             CALL    GETLN           ; Get line number to DE
0B75: FE2C     [42]             CP      ','             ; Another line number?
0B77: C0       [47|53]          RET     NZ              ; No - Drop through
0B78: C36D0B   [57]             JP      ONGOLP          ; Yes - loop
                        
0B7B: CDD40D   [17]     IF:     CALL    EVAL            ; Evaluate expression
0B7E: 7E       [24]             LD      A,(HL)          ; Get token
0B7F: FE88     [31]             CP      ZGOTO           ; "GOTO" token?
0B81: CA890B   [41|41]          JP      Z,IFGO          ; Yes - Get line
0B84: CDCB07   [58]             CALL    CHKSYN          ; Make sure it's "THEN"
0B87: A9                        .BYTE      ZTHEN           ; "THEN" token
0B88: 2B       [64]             DEC     HL              ; Cancel increment
0B89: CDC50D   [17]     IFGO:   CALL    TSTNUM          ; Make sure it's numeric
0B8C: CDA417   [34]             CALL    TSTSGN          ; Test state of expression
0B8F: CAEE0A   [44|44]          JP      Z,REM           ; False - Drop through
0B92: CD5509   [61]             CALL    GETCHR          ; Get next character
0B95: DAA90A   [71|71]          JP      C,GOTO          ; Number - GOTO that line
0B98: C33C09   [81]             JP      IFJMP           ; Otherwise do statement
                        
0B9B: 2B       [ 6]     MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
0B9C: CD5509   [23]             CALL    GETCHR          ; Get next character
0B9F: CAFD0B   [10|10]  PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
0BA2: C8       [ 5|11]  PRNTLP: RET     Z               ; End of list - Exit
0BA3: FEA5     [12]             CP      ZTAB            ; "TAB(" token?
0BA5: CA300C   [22|22]          JP      Z,DOTAB         ; Yes - Do TAB routine
0BA8: FEA8     [29]             CP      ZSPC            ; "SPC(" token?
0BAA: CA300C   [39|39]          JP      Z,DOTAB         ; Yes - Do SPC routine
0BAD: E5       [50]             PUSH    HL              ; Save code string address
0BAE: FE2C     [57]             CP      ','             ; Comma?
0BB0: CA190C   [67|67]          JP      Z,DOCOM         ; Yes - Move to next zone
0BB3: FE3B     [74]             CP      59 ;";"         ; Semi-colon?
0BB5: CA530C   [84|84]          JP      Z,NEXITM        ; Do semi-colon routine
0BB8: C1       [94]             POP     BC              ; Code string address to BC
0BB9: CDD40D   [111]            CALL    EVAL            ; Evaluate expression
0BBC: E5       [122]            PUSH    HL              ; Save code string address
0BBD: 3AF220   [135]            LD      A,(TYPE)        ; Get variable type
0BC0: B7       [139]            OR      A               ; Is it a string variable?
0BC1: C2E90B   [149|149]        JP      NZ,PRNTST       ; Yes - Output string contents
0BC4: CD4919   [166]            CALL    NUMASC          ; Convert number to text
0BC7: CD5912   [183]            CALL    CRTST           ; Create temporary string
0BCA: 3620     [193]            LD      (HL),' '        ; Followed by a space
0BCC: 2A2921   [209]            LD      HL,(FPREG)      ; Get length of output
0BCF: 34       [220]            INC     (HL)            ; Plus 1 for the space
0BD0: 2A2921   [236]            LD      HL,(FPREG)      ; < Not needed >
0BD3: 3A8720   [249]            LD      A,(LWIDTH)      ; Get width of line
0BD6: 47       [253]            LD      B,A             ; To B
0BD7: 04       [257]            INC     B               ; Width 255 (No limit)?
0BD8: CAE50B   [267|267]        JP      Z,PRNTNB        ; Yes - Output number string
0BDB: 04       [271]            INC     B               ; Adjust it
0BDC: 3AF020   [284]            LD      A,(CURPOS)      ; Get cursor position
0BDF: 86       [291]            ADD     A,(HL)          ; Add length of string
0BE0: 3D       [295]            DEC     A               ; Adjust it
0BE1: B8       [299]            CP      B               ; Will output fit on this line?
0BE2: D4FD0B   [309|316]        CALL    NC,PRNTCRLF     ; No - CRLF first
0BE5: CD9E12   [17]     PRNTNB: CALL    PRS1            ; Output string at (HL)
0BE8: AF       [21]             XOR     A               ; Skip CALL by setting 'z' flag
0BE9: C49E12   [10|17]  PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
0BEC: E1       [20]             POP     HL              ; Restore code string address
0BED: C39B0B   [30]             JP      MRPRNT          ; See if more to PRINT
                        
0BF0: 3AF020   [13]     STTLIN: LD      A,(CURPOS)      ; Make sure on new line
0BF3: B7       [17]             OR      A               ; Already at start?
0BF4: C8       [22|28]          RET     Z               ; Yes - Do nothing
0BF5: C3FD0B   [32]             JP      PRNTCRLF        ; Start a new line
                        
0BF8: 3600     [10]     ENDINP: LD      (HL),0          ; Mark end of buffer
0BFA: 21A520   [20]             LD      HL,BUFFER-1     ; Point to buffer
0BFD: 3E0D     [ 7]     PRNTCRLF: LD    A,CR            ; Load a CR
0BFF: CDD607   [24]             CALL    OUTC            ; Output character
0C02: 3E0A     [31]             LD      A,LF            ; Load a LF
0C04: CDD607   [48]             CALL    OUTC            ; Output character
0C07: AF       [ 4]     DONULL: XOR     A               ; Set to position 0
0C08: 32F020   [17]             LD      (CURPOS),A      ; Store it
0C0B: 3A8620   [30]             LD      A,(NULLS)       ; Get number of nulls
0C0E: 3D       [ 4]     NULLP:  DEC     A               ; Count them
0C0F: C8       [ 9|15]          RET     Z               ; Return if done
0C10: F5       [20]             PUSH    AF              ; Save count
0C11: AF       [24]             XOR     A               ; Load a null
0C12: CDD607   [41]             CALL    OUTC            ; Output it
0C15: F1       [51]             POP     AF              ; Restore count
0C16: C30E0C   [61]             JP      NULLP           ; Keep counting
                        
0C19: 3A8820   [13]     DOCOM:  LD      A,(COMMAN)      ; Get comma width
0C1C: 47       [17]             LD      B,A             ; Save in B
0C1D: 3AF020   [30]             LD      A,(CURPOS)      ; Get current position
0C20: B8       [34]             CP      B               ; Within the limit?
0C21: D4FD0B   [44|51]          CALL    NC,PRNTCRLF     ; No - output CRLF
0C24: D2530C   [54|54]          JP      NC,NEXITM       ; Get next item
0C27: D60E     [ 7]     ZONELP: SUB     14              ; Next zone of 14 characters
0C29: D2270C   [17|17]          JP      NC,ZONELP       ; Repeat if more zones
0C2C: 2F       [21]             CPL                     ; Number of spaces to output
0C2D: C3480C   [31]             JP      ASPCS           ; Output them
                        
0C30: F5       [11]     DOTAB:  PUSH    AF              ; Save token
0C31: CD2015   [28]             CALL    FNDNUM          ; Evaluate expression
0C34: CDCB07   [45]             CALL    CHKSYN          ; Make sure ")" follows
0C37: 29                        .BYTE   ")"
0C38: 2B       [51]             DEC     HL              ; Back space on to ")"
0C39: F1       [61]             POP     AF              ; Restore token
0C3A: D6A8     [68]             SUB     ZSPC            ; Was it "SPC(" ?
0C3C: E5       [79]             PUSH    HL              ; Save code string address
0C3D: CA430C   [89|89]          JP      Z,DOSPC         ; Yes - Do 'E' spaces
0C40: 3AF020   [102]            LD      A,(CURPOS)      ; Get current position
0C43: 2F       [ 4]     DOSPC:  CPL                     ; Number of spaces to print to
0C44: 83       [ 8]             ADD     A,E             ; Total number to print
0C45: D2530C   [18|18]          JP      NC,NEXITM       ; TAB < Current POS(X)
0C48: 3C       [ 4]     ASPCS:  INC     A               ; Output A spaces
0C49: 47       [ 8]             LD      B,A             ; Save number to print
0C4A: 3E20     [15]             LD      A,' '           ; Space
0C4C: CDD607   [17]     SPCLP:  CALL    OUTC            ; Output character in A
0C4F: 05       [21]             DEC     B               ; Count them
0C50: C24C0C   [31|31]          JP      NZ,SPCLP        ; Repeat if more
0C53: E1       [10]     NEXITM: POP     HL              ; Restore code string address
0C54: CD5509   [27]             CALL    GETCHR          ; Get next character
0C57: C3A20B   [37]             JP      PRNTLP          ; More to print
                        
0C5A: 3F526564          REDO:   .BYTE   "?Redo from start",CR,LF,0
0C5E: 6F206672          
0C62: 6F6D2073          
0C66: 74617274          
0C6A: 0D0A00            
                        
0C6D: 3A1221   [13]     BADINP: LD      A,(READFG)      ; READ or INPUT?
0C70: B7       [17]             OR      A
0C71: C2F704   [27|27]          JP      NZ,DATSNR       ; READ - ?SN Error
0C74: C1       [37]             POP     BC              ; Throw away code string addr
0C75: 215A0C   [47]             LD      HL,REDO         ; "Redo from start" message
0C78: CD9B12   [64]             CALL    PRS             ; Output string
0C7B: C34806   [74]             JP      DOAGN           ; Do last INPUT again
                        
0C7E: CD0612   [17]     INPUT:  CALL    IDTEST          ; Test for illegal direct
0C81: 7E       [24]             LD      A,(HL)          ; Get character after "INPUT"
0C82: FE22     [31]             CP      '"'             ; Is there a prompt string?
0C84: 3E00     [38]             LD      A,0             ; Clear A and leave flags
0C86: 328A20   [51]             LD      (CTLOFG),A      ; Enable output
0C89: C2980C   [61|61]          JP      NZ,NOPMPT       ; No prompt - get input
0C8C: CD5A12   [78]             CALL    QTSTR           ; Get string terminated by '"'
0C8F: CDCB07   [95]             CALL    CHKSYN          ; Check for ';' after prompt
0C92: 3B                        .BYTE   ';'
0C93: E5       [106]            PUSH    HL              ; Save code string address
0C94: CD9E12   [123]            CALL    PRS1            ; Output prompt string
0C97: 3E                        .BYTE   3EH             ; Skip "PUSH HL"
0C98: E5       [11]     NOPMPT: PUSH    HL              ; Save code string address
0C99: CD4C06   [28]             CALL    PROMPT          ; Get input with "? " prompt
0C9C: C1       [38]             POP     BC              ; Restore code string address
0C9D: DAA409   [48|48]          JP      C,INPBRK        ; Break pressed - Exit
0CA0: 23       [54]             INC     HL              ; Next byte
0CA1: 7E       [61]             LD      A,(HL)          ; Get it
0CA2: B7       [65]             OR      A               ; End of line?
0CA3: 2B       [71]             DEC     HL              ; Back again
0CA4: C5       [82]             PUSH    BC              ; Re-save code string address
0CA5: CAEB0A   [92|92]          JP      Z,NXTDTA        ; Yes - Find next DATA stmt
0CA8: 362C     [102]            LD      (HL),','        ; Store comma as separator
0CAA: C3B20C   [112]            JP      NXTITM          ; Get next item
                        
0CAD: E5       [11]     READ:   PUSH    HL              ; Save code string address
0CAE: 2A2121   [27]             LD      HL,(NXTDAT)     ; Next DATA statement
0CB1: F6                        .BYTE   0F6H            ; Flag "READ"
0CB2: AF       [ 4]     NXTITM: XOR     A               ; Flag "INPUT"
0CB3: 321221   [17]             LD      (READFG),A      ; Save "READ"/"INPUT" flag
0CB6: E3       [36]             EX      (SP),HL         ; Get code str' , Save pointer
0CB7: C3BE0C   [46]             JP      GTVLUS          ; Get values
                        
0CBA: CDCB07   [17]     NEDMOR: CALL    CHKSYN          ; Check for comma between items
0CBD: 2C                        .BYTE      ','
0CBE: CDB80F   [17]     GTVLUS: CALL    GETVAR          ; Get variable name
0CC1: E3       [36]             EX      (SP),HL         ; Save code str" , Get pointer
0CC2: D5       [47]             PUSH    DE              ; Save variable address
0CC3: 7E       [54]             LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
0CC4: FE2C     [61]             CP      ','             ; Comma?
0CC6: CAE60C   [71|71]          JP      Z,ANTVLU        ; Yes - Get another value
0CC9: 3A1221   [84]             LD      A,(READFG)      ; Is it READ?
0CCC: B7       [88]             OR      A
0CCD: C2530D   [98|98]          JP      NZ,FDTLP        ; Yes - Find next DATA stmt
0CD0: 3E3F     [105]            LD      A,'?'           ; More INPUT needed
0CD2: CDD607   [122]            CALL    OUTC            ; Output character
0CD5: CD4C06   [139]            CALL    PROMPT          ; Get INPUT with prompt
0CD8: D1       [149]            POP     DE              ; Variable address
0CD9: C1       [159]            POP     BC              ; Code string address
0CDA: DAA409   [169|169]        JP      C,INPBRK        ; Break pressed
0CDD: 23       [175]            INC     HL              ; Point to next DATA byte
0CDE: 7E       [182]            LD      A,(HL)          ; Get byte
0CDF: B7       [186]            OR      A               ; Is it zero (No input) ?
0CE0: 2B       [192]            DEC     HL              ; Back space INPUT pointer
0CE1: C5       [203]            PUSH    BC              ; Save code string address
0CE2: CAEB0A   [213|213]        JP      Z,NXTDTA        ; Find end of buffer
0CE5: D5       [224]            PUSH    DE              ; Save variable address
0CE6: 3AF220   [13]     ANTVLU: LD      A,(TYPE)        ; Check data type
0CE9: B7       [17]             OR      A               ; Is it numeric?
0CEA: CA100D   [27|27]          JP      Z,INPBIN        ; Yes - Convert to binary
0CED: CD5509   [44]             CALL    GETCHR          ; Get next character
0CF0: 57       [48]             LD      D,A             ; Save input character
0CF1: 47       [52]             LD      B,A             ; Again
0CF2: FE22     [59]             CP      '"'             ; Start of literal sting?
0CF4: CA040D   [69|69]          JP      Z,STRENT        ; Yes - Create string entry
0CF7: 3A1221   [82]             LD      A,(READFG)      ; "READ" or "INPUT" ?
0CFA: B7       [86]             OR      A
0CFB: 57       [90]             LD      D,A             ; Save 00 if "INPUT"
0CFC: CA010D   [100|100]        JP      Z,ITMSEP        ; "INPUT" - End with 00
0CFF: 163A     [107]            LD      D,':'           ; "DATA" - End with 00 or ':'
0D01: 062C     [ 7]     ITMSEP: LD      B,','           ; Item separator
0D03: 2B       [13]             DEC     HL              ; Back space for DTSTR
0D04: CD5D12   [17]     STRENT: CALL    DTSTR           ; Get string terminated by D
0D07: EB       [21]             EX      DE,HL           ; String address to DE
0D08: 211B0D   [31]             LD      HL,LTSTND       ; Where to go after LETSTR
0D0B: E3       [50]             EX      (SP),HL         ; Save HL , get input pointer
0D0C: D5       [61]             PUSH    DE              ; Save address of string
0D0D: C31E0B   [71]             JP      LETSTR          ; Assign string to variable
                        
0D10: CD5509   [17]     INPBIN: CALL    GETCHR          ; Get next character
0D13: CDAB18   [34]             CALL    ASCTFP          ; Convert ASCII to FP number
0D16: E3       [53]             EX      (SP),HL         ; Save input ptr, Get var addr
0D17: CDFC17   [70]             CALL    FPTHL           ; Move FPREG to variable
0D1A: E1       [80]             POP     HL              ; Restore input pointer
0D1B: 2B       [ 6]     LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
0D1C: CD5509   [23]             CALL    GETCHR          ; Get next character
0D1F: CA270D   [33|33]          JP      Z,MORDT         ; End of line - More needed?
0D22: FE2C     [40]             CP      ','             ; Another value?
0D24: C26D0C   [50|50]          JP      NZ,BADINP       ; No - Bad input
0D27: E3       [19]     MORDT:  EX      (SP),HL         ; Get code string address
0D28: 2B       [25]             DEC     HL              ; DEC 'cos GETCHR INCs
0D29: CD5509   [42]             CALL    GETCHR          ; Get next character
0D2C: C2BA0C   [52|52]          JP      NZ,NEDMOR       ; More needed - Get it
0D2F: D1       [62]             POP     DE              ; Restore DATA pointer
0D30: 3A1221   [75]             LD      A,(READFG)      ; "READ" or "INPUT" ?
0D33: B7       [79]             OR      A
0D34: EB       [83]             EX      DE,HL           ; DATA pointer to HL
0D35: C27B09   [93|93]          JP      NZ,UPDATA       ; Update DATA pointer if "READ"
0D38: D5       [104]            PUSH    DE              ; Save code string address
0D39: B6       [111]            OR      (HL)            ; More input given?
0D3A: 21420D   [121]            LD      HL,EXTIG        ; "?Extra ignored" message
0D3D: C49B12   [131|138]        CALL    NZ,PRS          ; Output string if extra given
0D40: E1       [141]            POP     HL              ; Restore code string address
0D41: C9       [151]            RET
                        
0D42: 3F457874          EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
0D46: 72612069          
0D4A: 676E6F72          
0D4E: 65640D0A          
0D52: 00                
                        
0D53: CDEC0A   [17]     FDTLP:  CALL    DATA            ; Get next statement
0D56: B7       [21]             OR      A               ; End of line?
0D57: C26C0D   [31|31]          JP      NZ,FANDT        ; No - See if DATA statement
0D5A: 23       [37]             INC     HL
0D5B: 7E       [44]             LD      A,(HL)          ; End of program?
0D5C: 23       [50]             INC     HL
0D5D: B6       [57]             OR      (HL)            ; 00 00 Ends program
0D5E: 1E06     [64]             LD      E,OD            ; ?OD Error
0D60: CA1105   [74|74]          JP      Z,ERROR         ; Yes - Out of DATA
0D63: 23       [80]             INC     HL
0D64: 5E       [87]             LD      E,(HL)          ; LSB of line number
0D65: 23       [93]             INC     HL
0D66: 56       [100]            LD      D,(HL)          ; MSB of line number
0D67: EB       [104]            EX      DE,HL
0D68: 220E21   [120]            LD      (DATLIN),HL     ; Set line of current DATA item
0D6B: EB       [124]            EX      DE,HL
0D6C: CD5509   [17]     FANDT:  CALL    GETCHR          ; Get next character
0D6F: FE83     [24]             CP      ZDATA           ; "DATA" token
0D71: C2530D   [34|34]          JP      NZ,FDTLP        ; No "DATA" - Keep looking
0D74: C3E60C   [44]             JP      ANTVLU          ; Found - Convert input
                        
0D77: 110000   [10]     NEXT:   LD      DE,0            ; In case no index given
0D7A: C4B80F   [10|17]  NEXT1:  CALL    NZ,GETVAR       ; Get index address
0D7D: 221321   [26]             LD      (BRKLIN),HL     ; Save code string address
0D80: CDA604   [43]             CALL    BAKSTK          ; Look for "FOR" block
0D83: C20305   [53|53]          JP      NZ,NFERR        ; No "FOR" - ?NF Error
0D86: F9       [59]             LD      SP,HL           ; Clear nested loops
0D87: D5       [70]             PUSH    DE              ; Save index address
0D88: 7E       [77]             LD      A,(HL)          ; Get sign of STEP
0D89: 23       [83]             INC     HL
0D8A: F5       [94]             PUSH    AF              ; Save sign of STEP
0D8B: D5       [105]            PUSH    DE              ; Save index address
0D8C: CDE217   [122]            CALL    PHLTFP          ; Move index value to FPREG
0D8F: E3       [141]            EX      (SP),HL         ; Save address of TO value
0D90: E5       [152]            PUSH    HL              ; Save address of index
0D91: CD4F15   [169]            CALL    ADDPHL          ; Add STEP to index value
0D94: E1       [179]            POP     HL              ; Restore address of index
0D95: CDFC17   [196]            CALL    FPTHL           ; Move value to index variable
0D98: E1       [206]            POP     HL              ; Restore address of TO value
0D99: CDF317   [223]            CALL    LOADFP          ; Move TO value to BCDE
0D9C: E5       [234]            PUSH    HL              ; Save address of line of FOR
0D9D: CD1F18   [251]            CALL    CMPNUM          ; Compare index with TO value
0DA0: E1       [261]            POP     HL              ; Restore address of line num
0DA1: C1       [271]            POP     BC              ; Address of sign of STEP
0DA2: 90       [275]            SUB     B               ; Compare with expected sign
0DA3: CDF317   [292]            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
0DA6: CAB20D   [302|302]        JP      Z,KILFOR        ; Loop finished - Terminate it
0DA9: EB       [306]            EX      DE,HL           ; Loop statement line number
0DAA: 22A120   [322]            LD      (LINEAT),HL     ; Set loop line number
0DAD: 69       [326]            LD      L,C             ; Set code string to loop
0DAE: 60       [330]            LD      H,B
0DAF: C31109   [340]            JP      PUTFID          ; Put back "FOR" and continue
                        
0DB2: F9       [ 6]     KILFOR: LD      SP,HL           ; Remove "FOR" block
0DB3: 2A1321   [22]             LD      HL,(BRKLIN)     ; Code string after "NEXT"
0DB6: 7E       [29]             LD      A,(HL)          ; Get next byte in code string
0DB7: FE2C     [36]             CP      ','             ; More NEXTs ?
0DB9: C21509   [46|46]          JP      NZ,RUNCNT       ; No - Do next statement
0DBC: CD5509   [63]             CALL    GETCHR          ; Position to index name
0DBF: CD7A0D   [80]             CALL    NEXT1           ; Re-enter NEXT routine
                        ; < will not RETurn to here , Exit to RUNCNT or Loop >
                        
0DC2: CDD40D   [17]     GETNUM: CALL    EVAL            ; Get a numeric expression
0DC5: F6                TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
0DC6: 37       [ 4]     TSTSTR: SCF                     ; Set carry (string)
0DC7: 3AF220   [13]     CHKTYP: LD      A,(TYPE)        ; Check types match
0DCA: 8F       [17]             ADC     A,A             ; Expected + actual
0DCB: B7       [21]             OR      A               ; Clear carry , set parity
0DCC: E8       [26|32]          RET     PE              ; Even parity - Types match
0DCD: C30F05   [36]             JP      TMERR           ; Different types - Error
                        
0DD0: CDCB07   [17]     OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
0DD3: 28                        .BYTE   "("
0DD4: 2B       [ 6]     EVAL:   DEC     HL              ; Evaluate expression & save
0DD5: 1600     [13]             LD      D,0             ; Precedence value
0DD7: D5       [11]     EVAL1:  PUSH    DE              ; Save precedence
0DD8: 0E01     [18]             LD      C,1
0DDA: CDDA04   [35]             CALL    CHKSTK          ; Check for 1 level of stack
0DDD: CD4B0E   [52]             CALL    OPRND           ; Get next expression value
0DE0: 221521   [16]     EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
0DE3: 2A1521   [16]     EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
0DE6: C1       [26]             POP     BC              ; Precedence value and operator
0DE7: 78       [30]             LD      A,B             ; Get precedence value
0DE8: FE78     [37]             CP      78H             ; "AND" or "OR" ?
0DEA: D4C50D   [47|54]          CALL    NC,TSTNUM       ; No - Make sure it's a number
0DED: 7E       [54]             LD      A,(HL)          ; Get next operator / function
0DEE: 1600     [61]             LD      D,0             ; Clear Last relation
0DF0: D6B3     [ 7]     RLTLP:  SUB     ZGTR            ; ">" Token
0DF2: DA0C0E   [17|17]          JP      C,FOPRND        ; + - * / ^ AND OR - Test it
0DF5: FE03     [24]             CP      ZLTH+1-ZGTR     ; < = >
0DF7: D20C0E   [34|34]          JP      NC,FOPRND       ; Function - Call it
0DFA: FE01     [41]             CP      ZEQUAL-ZGTR     ; "="
0DFC: 17       [45]             RLA                     ; <- Test for legal
0DFD: AA       [49]             XOR     D               ; <- combinations of < = >
0DFE: BA       [53]             CP      D               ; <- by combining last token
0DFF: 57       [57]             LD      D,A             ; <- with current one
0E00: DAFD04   [67|67]          JP      C,SNERR         ; Error if "<<' '==" or ">>"
0E03: 220A21   [83]             LD      (CUROPR),HL     ; Save address of current token
0E06: CD5509   [100]            CALL    GETCHR          ; Get next character
0E09: C3F00D   [110]            JP      RLTLP           ; Treat the two as one
                        
0E0C: 7A       [ 4]     FOPRND: LD      A,D             ; < = > found ?
0E0D: B7       [ 8]             OR      A
0E0E: C2330F   [18|18]          JP      NZ,TSTRED       ; Yes - Test for reduction
0E11: 7E       [25]             LD      A,(HL)          ; Get operator token
0E12: 220A21   [41]             LD      (CUROPR),HL     ; Save operator address
0E15: D6AC     [48]             SUB     ZPLUS           ; Operator or function?
0E17: D8       [53|59]          RET     C               ; Neither - Exit
0E18: FE07     [60]             CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
0E1A: D0       [65|71]          RET     NC              ; No - Exit
0E1B: 5F       [69]             LD      E,A             ; Coded operator
0E1C: 3AF220   [82]             LD      A,(TYPE)        ; Get data type
0E1F: 3D       [86]             DEC     A               ; FF = numeric , 00 = string
0E20: B3       [90]             OR      E               ; Combine with coded operator
0E21: 7B       [94]             LD      A,E             ; Get coded operator
0E22: CA9113   [104|104]        JP      Z,CONCAT        ; String concatenation
0E25: 07       [108]            RLCA                    ; Times 2
0E26: 83       [112]            ADD     A,E             ; Times 3
0E27: 5F       [116]            LD      E,A             ; To DE (D is 0)
0E28: 21EF03   [126]            LD      HL,PRITAB       ; Precedence table
0E2B: 19       [137]            ADD     HL,DE           ; To the operator concerned
0E2C: 78       [141]            LD      A,B             ; Last operator precedence
0E2D: 56       [148]            LD      D,(HL)          ; Get evaluation precedence
0E2E: BA       [152]            CP      D               ; Compare with eval precedence
0E2F: D0       [157|163]        RET     NC              ; Exit if higher precedence
0E30: 23       [163]            INC     HL              ; Point to routine address
0E31: CDC50D   [180]            CALL    TSTNUM          ; Make sure it's a number
                        
0E34: C5       [11]     STKTHS: PUSH    BC              ; Save last precedence & token
0E35: 01E30D   [21]             LD      BC,EVAL3        ; Where to go on prec' break
0E38: C5       [32]             PUSH    BC              ; Save on stack for return
0E39: 43       [36]             LD      B,E             ; Save operator
0E3A: 4A       [40]             LD      C,D             ; Save precedence
0E3B: CDD517   [57]             CALL    STAKFP          ; Move value to stack
0E3E: 58       [61]             LD      E,B             ; Restore operator
0E3F: 51       [65]             LD      D,C             ; Restore precedence
0E40: 4E       [72]             LD      C,(HL)          ; Get LSB of routine address
0E41: 23       [78]             INC     HL
0E42: 46       [85]             LD      B,(HL)          ; Get MSB of routine address
0E43: 23       [91]             INC     HL
0E44: C5       [102]            PUSH    BC              ; Save routine address
0E45: 2A0A21   [118]            LD      HL,(CUROPR)     ; Address of current operator
0E48: C3D70D   [128]            JP      EVAL1           ; Loop until prec' break
                        
0E4B: AF       [ 4]     OPRND:  XOR     A               ; Get operand routine
0E4C: 32F220   [17]             LD      (TYPE),A        ; Set numeric expected
0E4F: CD5509   [34]             CALL    GETCHR          ; Get next character
0E52: 1E24     [41]             LD      E,MO            ; ?MO Error
0E54: CA1105   [51|51]          JP      Z,ERROR         ; No operand - Error
0E57: DAAB18   [61|61]          JP      C,ASCTFP        ; Number - Get value
0E5A: CDF309   [78]             CALL    CHKLTR          ; See if a letter
0E5D: D2B20E   [88|88]          JP      NC,CONVAR       ; Letter - Find variable
0E60: FE26     [95]             CP		'&'				; &H = HEX, &B = BINARY
0E62: 2012     [102|107]        JR		NZ, NOTAMP
0E64: CD5509   [119]            CALL    GETCHR          ; Get next character
0E67: FE48     [126]            CP      'H'             ; Hex number indicated? [function added]
0E69: CAEF1C   [136|136]        JP      Z,HEXTFP        ; Convert Hex to FPREG
0E6C: FE42     [143]            CP      'B'             ; Binary number indicated? [function added]
0E6E: CA5F1D   [153|153]        JP      Z,BINTFP        ; Convert Bin to FPREG
0E71: 1E02     [160]            LD      E,SN            ; If neither then a ?SN Error
0E73: CA1105   [170|170]        JP      Z,ERROR         ; 
0E76: FEAC     [ 7]     NOTAMP: CP      ZPLUS           ; '+' Token ?
0E78: CA4B0E   [17|17]          JP      Z,OPRND         ; Yes - Look for operand
0E7B: FE2E     [24]             CP      '.'             ; '.' ?
0E7D: CAAB18   [34|34]          JP      Z,ASCTFP        ; Yes - Create FP number
0E80: FEAD     [41]             CP      ZMINUS          ; '-' Token ?
0E82: CAA10E   [51|51]          JP      Z,MINUS         ; Yes - Do minus
0E85: FE22     [58]             CP      '"'             ; Literal string ?
0E87: CA5A12   [68|68]          JP      Z,QTSTR         ; Get string terminated by '"'
0E8A: FEAA     [75]             CP      ZNOT            ; "NOT" Token ?
0E8C: CA930F   [85|85]          JP      Z,EVNOT         ; Yes - Eval NOT expression
0E8F: FEA7     [92]             CP      ZFN             ; "FN" Token ?
0E91: CABE11   [102|102]        JP      Z,DOFN          ; Yes - Do FN routine
0E94: D6B6     [109]            SUB     ZSGN            ; Is it a function?
0E96: D2C30E   [119|119]        JP      NC,FNOFST       ; Yes - Evaluate function
0E99: CDD00D   [17]     EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
0E9C: CDCB07   [34]             CALL    CHKSYN          ; Make sure ")" follows
0E9F: 29                        .BYTE   ")"
0EA0: C9       [44]             RET
                        
0EA1: 167D     [ 7]     MINUS:  LD      D,7DH           ; '-' precedence
0EA3: CDD70D   [24]             CALL    EVAL1           ; Evaluate until prec' break
0EA6: 2A1521   [40]             LD      HL,(NXTOPR)     ; Get next operator address
0EA9: E5       [51]             PUSH    HL              ; Save next operator address
0EAA: CDCD17   [68]             CALL    INVSGN          ; Negate value
0EAD: CDC50D   [17]     RETNUM: CALL    TSTNUM          ; Make sure it's a number
0EB0: E1       [27]             POP     HL              ; Restore next operator address
0EB1: C9       [37]             RET
                        
0EB2: CDB80F   [17]     CONVAR: CALL    GETVAR          ; Get variable address to DE
0EB5: E5       [11]     FRMEVL: PUSH    HL              ; Save code string address
0EB6: EB       [15]             EX      DE,HL           ; Variable address to HL
0EB7: 222921   [31]             LD      (FPREG),HL      ; Save address of variable
0EBA: 3AF220   [44]             LD      A,(TYPE)        ; Get type
0EBD: B7       [48]             OR      A               ; Numeric?
0EBE: CCE217   [58|65]          CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
0EC1: E1       [68]             POP     HL              ; Restore code string address
0EC2: C9       [78]             RET
                        
0EC3: 0600     [ 7]     FNOFST: LD      B,0             ; Get address of function
0EC5: 07       [11]             RLCA                    ; Double function offset
0EC6: 4F       [15]             LD      C,A             ; BC = Offset in function table
0EC7: C5       [26]             PUSH    BC              ; Save adjusted token value
0EC8: CD5509   [43]             CALL    GETCHR          ; Get next character
0ECB: 79       [47]             LD      A,C             ; Get adjusted token value
0ECC: FE31     [54]             CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
0ECE: DAEA0E   [64|64]          JP      C,FNVAL         ; No - Do function
0ED1: CDD00D   [81]             CALL    OPNPAR          ; Evaluate expression  (X,...
0ED4: CDCB07   [98]             CALL    CHKSYN          ; Make sure ',' follows
0ED7: 2C                        .BYTE      ','
0ED8: CDC60D   [115]            CALL    TSTSTR          ; Make sure it's a string
0EDB: EB       [119]            EX      DE,HL           ; Save code string address
0EDC: 2A2921   [135]            LD      HL,(FPREG)      ; Get address of string
0EDF: E3       [154]            EX      (SP),HL         ; Save address of string
0EE0: E5       [165]            PUSH    HL              ; Save adjusted token value
0EE1: EB       [169]            EX      DE,HL           ; Restore code string address
0EE2: CD2315   [186]            CALL    GETINT          ; Get integer 0-255
0EE5: EB       [190]            EX      DE,HL           ; Save code string address
0EE6: E3       [209]            EX      (SP),HL         ; Save integer,HL = adj' token
0EE7: C3F20E   [219]            JP      GOFUNC          ; Jump to string function
                        
0EEA: CD990E   [17]     FNVAL:  CALL    EVLPAR          ; Evaluate expression
0EED: E3       [36]             EX      (SP),HL         ; HL = Adjusted token value
0EEE: 11AD0E   [46]             LD      DE,RETNUM       ; Return number from function
0EF1: D5       [57]             PUSH    DE              ; Save on stack
0EF2: 014E02   [10]     GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
0EF5: 09       [21]             ADD     HL,BC           ; Point to right address
0EF6: 4E       [28]             LD      C,(HL)          ; Get LSB of address
0EF7: 23       [34]             INC     HL              ;
0EF8: 66       [41]             LD      H,(HL)          ; Get MSB of address
0EF9: 69       [45]             LD      L,C             ; Address to HL
0EFA: E9       [49]             JP      (HL)            ; Jump to function
                        
0EFB: 15       [ 4]     SGNEXP: DEC     D               ; Dee to flag negative exponent
0EFC: FEAD     [11]             CP      ZMINUS          ; '-' token ?
0EFE: C8       [16|22]          RET     Z               ; Yes - Return
0EFF: FE2D     [23]             CP      '-'             ; '-' ASCII ?
0F01: C8       [28|34]          RET     Z               ; Yes - Return
0F02: 14       [32]             INC     D               ; Inc to flag positive exponent
0F03: FE2B     [39]             CP      '+'             ; '+' ASCII ?
0F05: C8       [44|50]          RET     Z               ; Yes - Return
0F06: FEAC     [51]             CP      ZPLUS           ; '+' token ?
0F08: C8       [56|62]          RET     Z               ; Yes - Return
0F09: 2B       [62]             DEC     HL              ; DEC 'cos GETCHR INCs
0F0A: C9       [72]             RET                     ; Return "NZ"
                        
0F0B: F6                POR:    .BYTE      0F6H            ; Flag "OR"
0F0C: AF       [ 4]     PAND:   XOR     A               ; Flag "AND"
0F0D: F5       [15]             PUSH    AF              ; Save "AND" / "OR" flag
0F0E: CDC50D   [32]             CALL    TSTNUM          ; Make sure it's a number
0F11: CD070A   [49]             CALL    DEINT           ; Get integer -32768 to 32767
0F14: F1       [59]             POP     AF              ; Restore "AND" / "OR" flag
0F15: EB       [63]             EX      DE,HL           ; <- Get last
0F16: C1       [73]             POP     BC              ; <-  value
0F17: E3       [92]             EX      (SP),HL         ; <-  from
0F18: EB       [96]             EX      DE,HL           ; <-  stack
0F19: CDE517   [113]            CALL    FPBCDE          ; Move last value to FPREG
0F1C: F5       [124]            PUSH    AF              ; Save "AND" / "OR" flag
0F1D: CD070A   [141]            CALL    DEINT           ; Get integer -32768 to 32767
0F20: F1       [151]            POP     AF              ; Restore "AND" / "OR" flag
0F21: C1       [161]            POP     BC              ; Get value
0F22: 79       [165]            LD      A,C             ; Get LSB
0F23: 217C11   [175]            LD      HL,ACPASS       ; Address of save AC as current
0F26: C22E0F   [185|185]        JP      NZ,POR1         ; Jump if OR
0F29: A3       [189]            AND     E               ; "AND" LSBs
0F2A: 4F       [193]            LD      C,A             ; Save LSB
0F2B: 78       [197]            LD      A,B             ; Get MBS
0F2C: A2       [201]            AND     D               ; "AND" MSBs
0F2D: E9       [205]            JP      (HL)            ; Save AC as current (ACPASS)
                        
0F2E: B3       [ 4]     POR1:   OR      E               ; "OR" LSBs
0F2F: 4F       [ 8]             LD      C,A             ; Save LSB
0F30: 78       [12]             LD      A,B             ; Get MSB
0F31: B2       [16]             OR      D               ; "OR" MSBs
0F32: E9       [20]             JP      (HL)            ; Save AC as current (ACPASS)
                        
0F33: 21450F   [10]     TSTRED: LD      HL,CMPLOG       ; Logical compare routine
0F36: 3AF220   [23]             LD      A,(TYPE)        ; Get data type
0F39: 1F       [27]             RRA                     ; Carry set = string
0F3A: 7A       [31]             LD      A,D             ; Get last precedence value
0F3B: 17       [35]             RLA                     ; Times 2 plus carry
0F3C: 5F       [39]             LD      E,A             ; To E
0F3D: 1664     [46]             LD      D,64H           ; Relational precedence
0F3F: 78       [50]             LD      A,B             ; Get current precedence
0F40: BA       [54]             CP      D               ; Compare with last
0F41: D0       [59|65]          RET     NC              ; Eval if last was rel' or log'
0F42: C3340E   [69]             JP      STKTHS          ; Stack this one and get next
                        
0F45: 470F              CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
0F47: 79       [ 4]     CMPLG1: LD      A,C             ; Get data type
0F48: B7       [ 8]             OR      A
0F49: 1F       [12]             RRA
0F4A: C1       [22]             POP     BC              ; Get last expression to BCDE
0F4B: D1       [32]             POP     DE
0F4C: F5       [43]             PUSH    AF              ; Save status
0F4D: CDC70D   [60]             CALL    CHKTYP          ; Check that types match
0F50: 21890F   [70]             LD      HL,CMPRES       ; Result to comparison
0F53: E5       [81]             PUSH    HL              ; Save for RETurn
0F54: CA1F18   [91|91]          JP      Z,CMPNUM        ; Compare values if numeric
0F57: AF       [95]             XOR     A               ; Compare two strings
0F58: 32F220   [108]            LD      (TYPE),A        ; Set type to numeric
0F5B: D5       [119]            PUSH    DE              ; Save string name
0F5C: CDDE13   [136]            CALL    GSTRCU          ; Get current string
0F5F: 7E       [143]            LD      A,(HL)          ; Get length of string
0F60: 23       [149]            INC     HL
0F61: 23       [155]            INC     HL
0F62: 4E       [162]            LD      C,(HL)          ; Get LSB of address
0F63: 23       [168]            INC     HL
0F64: 46       [175]            LD      B,(HL)          ; Get MSB of address
0F65: D1       [185]            POP     DE              ; Restore string name
0F66: C5       [196]            PUSH    BC              ; Save address of string
0F67: F5       [207]            PUSH    AF              ; Save length of string
0F68: CDE213   [224]            CALL    GSTRDE          ; Get second string
0F6B: CDF317   [241]            CALL    LOADFP          ; Get address of second string
0F6E: F1       [251]            POP     AF              ; Restore length of string 1
0F6F: 57       [255]            LD      D,A             ; Length to D
0F70: E1       [265]            POP     HL              ; Restore address of string 1
0F71: 7B       [ 4]     CMPSTR: LD      A,E             ; Bytes of string 2 to do
0F72: B2       [ 8]             OR      D               ; Bytes of string 1 to do
0F73: C8       [13|19]          RET     Z               ; Exit if all bytes compared
0F74: 7A       [17]             LD      A,D             ; Get bytes of string 1 to do
0F75: D601     [24]             SUB     1
0F77: D8       [29|35]          RET     C               ; Exit if end of string 1
0F78: AF       [33]             XOR     A
0F79: BB       [37]             CP      E               ; Bytes of string 2 to do
0F7A: 3C       [41]             INC     A
0F7B: D0       [46|52]          RET     NC              ; Exit if end of string 2
0F7C: 15       [50]             DEC     D               ; Count bytes in string 1
0F7D: 1D       [54]             DEC     E               ; Count bytes in string 2
0F7E: 0A       [61]             LD      A,(BC)          ; Byte in string 2
0F7F: BE       [68]             CP      (HL)            ; Compare to byte in string 1
0F80: 23       [74]             INC     HL              ; Move up string 1
0F81: 03       [80]             INC     BC              ; Move up string 2
0F82: CA710F   [90|90]          JP      Z,CMPSTR        ; Same - Try next bytes
0F85: 3F       [94]             CCF                     ; Flag difference (">" or "<")
0F86: C3AF17   [104]            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
                        
0F89: 3C       [ 4]     CMPRES: INC     A               ; Increment current value
0F8A: 8F       [ 8]             ADC     A,A             ; Double plus carry
0F8B: C1       [18]             POP     BC              ; Get other value
0F8C: A0       [22]             AND     B               ; Combine them
0F8D: C6FF     [29]             ADD     A,-1            ; Carry set if different
0F8F: 9F       [33]             SBC     A,A             ; 00 - Equal , FF - Different
0F90: C3B617   [43]             JP      FLGREL          ; Set current value & continue
                        
0F93: 165A     [ 7]     EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
0F95: CDD70D   [24]             CALL    EVAL1           ; Eval until precedence break
0F98: CDC50D   [41]             CALL    TSTNUM          ; Make sure it's a number
0F9B: CD070A   [58]             CALL    DEINT           ; Get integer -32768 - 32767
0F9E: 7B       [62]             LD      A,E             ; Get LSB
0F9F: 2F       [66]             CPL                     ; Invert LSB
0FA0: 4F       [70]             LD      C,A             ; Save "NOT" of LSB
0FA1: 7A       [74]             LD      A,D             ; Get MSB
0FA2: 2F       [78]             CPL                     ; Invert MSB
0FA3: CD7C11   [95]             CALL    ACPASS          ; Save AC as current
0FA6: C1       [105]            POP     BC              ; Clean up stack
0FA7: C3E30D   [115]            JP      EVAL3           ; Continue evaluation
                        
0FAA: 2B       [ 6]     DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
0FAB: CD5509   [23]             CALL    GETCHR          ; Get next character
0FAE: C8       [28|34]          RET     Z               ; End of DIM statement
0FAF: CDCB07   [45]             CALL    CHKSYN          ; Make sure ',' follows
0FB2: 2C                        .BYTE      ','
0FB3: 01AA0F   [10]     DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
0FB6: C5       [21]             PUSH    BC              ; Save on stack
0FB7: F6                        .BYTE      0F6H            ; Flag "Create" variable
0FB8: AF       [ 4]     GETVAR: XOR     A               ; Find variable address,to DE
0FB9: 32F120   [17]             LD      (LCRFLG),A      ; Set locate / create flag
0FBC: 46       [24]             LD      B,(HL)          ; Get First byte of name
0FBD: CDF309   [17]     GTFNAM: CALL    CHKLTR          ; See if a letter
0FC0: DAFD04   [27|27]          JP      C,SNERR         ; ?SN Error if not a letter
0FC3: AF       [31]             XOR     A
0FC4: 4F       [35]             LD      C,A             ; Clear second byte of name
0FC5: 32F220   [48]             LD      (TYPE),A        ; Set type to numeric
0FC8: CD5509   [65]             CALL    GETCHR          ; Get next character
0FCB: DAD40F   [75|75]          JP      C,SVNAM2        ; Numeric - Save in name
0FCE: CDF309   [92]             CALL    CHKLTR          ; See if a letter
0FD1: DAE10F   [102|102]        JP      C,CHARTY        ; Not a letter - Check type
0FD4: 4F       [ 4]     SVNAM2: LD      C,A             ; Save second byte of name
0FD5: CD5509   [17]     ENDNAM: CALL    GETCHR          ; Get next character
0FD8: DAD50F   [27|27]          JP      C,ENDNAM        ; Numeric - Get another
0FDB: CDF309   [44]             CALL    CHKLTR          ; See if a letter
0FDE: D2D50F   [54|54]          JP      NC,ENDNAM       ; Letter - Get another
0FE1: D624     [ 7]     CHARTY: SUB     '$'             ; String variable?
0FE3: C2F00F   [17|17]          JP      NZ,NOTSTR       ; No - Numeric variable
0FE6: 3C       [21]             INC     A               ; A = 1 (string type)
0FE7: 32F220   [34]             LD      (TYPE),A        ; Set type to string
0FEA: 0F       [38]             RRCA                    ; A = 80H , Flag for string
0FEB: 81       [42]             ADD     A,C             ; 2nd byte of name has bit 7 on
0FEC: 4F       [46]             LD      C,A             ; Resave second byte on name
0FED: CD5509   [63]             CALL    GETCHR          ; Get next character
0FF0: 3A1021   [13]     NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
0FF3: 3D       [17]             DEC     A
0FF4: CA9D10   [27|27]          JP      Z,ARLDSV        ; Yes - Get array name
0FF7: F20010   [37|37]          JP      P,NSCFOR        ; No array with "FOR" or "FN"
0FFA: 7E       [44]             LD      A,(HL)          ; Get byte again
0FFB: D628     [51]             SUB     '('             ; Subscripted variable?
0FFD: CA7510   [61|61]          JP      Z,SBSCPT        ; Yes - Sort out subscript
                        
1000: AF       [ 4]     NSCFOR: XOR     A               ; Simple variable
1001: 321021   [17]             LD      (FORFLG),A      ; Clear "FOR" flag
1004: E5       [28]             PUSH    HL              ; Save code string address
1005: 50       [32]             LD      D,B             ; DE = Variable name to find
1006: 59       [36]             LD      E,C
1007: 2A2321   [52]             LD      HL,(FNRGNM)     ; FN argument name
100A: CDC507   [69]             CALL    CPDEHL          ; Is it the FN argument?
100D: 112521   [79]             LD      DE,FNARG        ; Point to argument value
1010: CAE516   [89|89]          JP      Z,POPHRT        ; Yes - Return FN argument value
1013: 2A1D21   [105]            LD      HL,(VAREND)     ; End of variables
1016: EB       [109]            EX      DE,HL           ; Address of end of search
1017: 2A1B21   [125]            LD      HL,(PROGND)     ; Start of variables address
101A: CDC507   [17]     FNDVAR: CALL    CPDEHL          ; End of variable list table?
101D: CA3310   [27|27]          JP      Z,CFEVAL        ; Yes - Called from EVAL?
1020: 79       [31]             LD      A,C             ; Get second byte of name
1021: 96       [38]             SUB     (HL)            ; Compare with name in list
1022: 23       [44]             INC     HL              ; Move on to first byte
1023: C22810   [54|54]          JP      NZ,FNTHR        ; Different - Find another
1026: 78       [58]             LD      A,B             ; Get first byte of name
1027: 96       [65]             SUB     (HL)            ; Compare with name in list
1028: 23       [ 6]     FNTHR:  INC     HL              ; Move on to LSB of value
1029: CA6710   [16|16]          JP      Z,RETADR        ; Found - Return address
102C: 23       [22]             INC     HL              ; <- Skip
102D: 23       [28]             INC     HL              ; <- over
102E: 23       [34]             INC     HL              ; <- F.P.
102F: 23       [40]             INC     HL              ; <- value
1030: C31A10   [50]             JP      FNDVAR          ; Keep looking
                        
1033: E1       [10]     CFEVAL: POP     HL              ; Restore code string address
1034: E3       [29]             EX      (SP),HL         ; Get return address
1035: D5       [40]             PUSH    DE              ; Save address of variable
1036: 11B50E   [50]             LD      DE,FRMEVL       ; Return address in EVAL
1039: CDC507   [67]             CALL    CPDEHL          ; Called from EVAL ?
103C: D1       [77]             POP     DE              ; Restore address of variable
103D: CA6A10   [87|87]          JP      Z,RETNUL        ; Yes - Return null variable
1040: E3       [106]            EX      (SP),HL         ; Put back return
1041: E5       [117]            PUSH    HL              ; Save code string address
1042: C5       [128]            PUSH    BC              ; Save variable name
1043: 010600   [138]            LD      BC,6            ; 2 byte name plus 4 byte data
1046: 2A1F21   [154]            LD      HL,(ARREND)     ; End of arrays
1049: E5       [165]            PUSH    HL              ; Save end of arrays
104A: 09       [176]            ADD     HL,BC           ; Move up 6 bytes
104B: C1       [186]            POP     BC              ; Source address in BC
104C: E5       [197]            PUSH    HL              ; Save new end address
104D: CDC904   [214]            CALL    MOVUP           ; Move arrays up
1050: E1       [224]            POP     HL              ; Restore new end address
1051: 221F21   [240]            LD      (ARREND),HL     ; Set new end address
1054: 60       [244]            LD      H,B             ; End of variables to HL
1055: 69       [248]            LD      L,C
1056: 221D21   [264]            LD      (VAREND),HL     ; Set new end address
                        
1059: 2B       [ 6]     ZEROLP: DEC     HL              ; Back through to zero variable
105A: 3600     [16]             LD      (HL),0          ; Zero byte in variable
105C: CDC507   [33]             CALL    CPDEHL          ; Done them all?
105F: C25910   [43|43]          JP      NZ,ZEROLP       ; No - Keep on going
1062: D1       [53]             POP     DE              ; Get variable name
1063: 73       [60]             LD      (HL),E          ; Store second character
1064: 23       [66]             INC     HL
1065: 72       [73]             LD      (HL),D          ; Store first character
1066: 23       [79]             INC     HL
1067: EB       [ 4]     RETADR: EX      DE,HL           ; Address of variable in DE
1068: E1       [14]             POP     HL              ; Restore code string address
1069: C9       [24]             RET
                        
106A: 322C21   [13]     RETNUL: LD      (FPEXP),A       ; Set result to zero
106D: 219904   [23]             LD      HL,ZERBYT       ; Also set a null string
1070: 222921   [39]             LD      (FPREG),HL      ; Save for EVAL
1073: E1       [49]             POP     HL              ; Restore code string address
1074: C9       [59]             RET
                        
1075: E5       [11]     SBSCPT: PUSH    HL              ; Save code string address
1076: 2AF120   [27]             LD      HL,(LCRFLG)     ; Locate/Create and Type
1079: E3       [46]             EX      (SP),HL         ; Save and get code string
107A: 57       [50]             LD      D,A             ; Zero number of dimensions
107B: D5       [11]     SCPTLP: PUSH    DE              ; Save number of dimensions
107C: C5       [22]             PUSH    BC              ; Save array name
107D: CDFB09   [39]             CALL    FPSINT          ; Get subscript (0-32767)
1080: C1       [49]             POP     BC              ; Restore array name
1081: F1       [59]             POP     AF              ; Get number of dimensions
1082: EB       [63]             EX      DE,HL
1083: E3       [82]             EX      (SP),HL         ; Save subscript value
1084: E5       [93]             PUSH    HL              ; Save LCRFLG and TYPE
1085: EB       [97]             EX      DE,HL
1086: 3C       [101]            INC     A               ; Count dimensions
1087: 57       [105]            LD      D,A             ; Save in D
1088: 7E       [112]            LD      A,(HL)          ; Get next byte in code string
1089: FE2C     [119]            CP      ','             ; Comma (more to come)?
108B: CA7B10   [129|129]        JP      Z,SCPTLP        ; Yes - More subscripts
108E: CDCB07   [146]            CALL    CHKSYN          ; Make sure ")" follows
1091: 29                        .BYTE      ")"
1092: 221521   [162]            LD      (NXTOPR),HL     ; Save code string address
1095: E1       [172]            POP     HL              ; Get LCRFLG and TYPE
1096: 22F120   [188]            LD      (LCRFLG),HL     ; Restore Locate/create & type
1099: 1E00     [195]            LD      E,0             ; Flag not CSAVE* or CLOAD*
109B: D5       [206]            PUSH    DE              ; Save number of dimensions (D)
109C: 11                        .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
                        
109D: E5       [11]     ARLDSV: PUSH    HL              ; Save code string address
109E: F5       [22]             PUSH    AF              ; A = 00 , Flags set = Z,N
109F: 2A1D21   [38]             LD      HL,(VAREND)     ; Start of arrays
10A2: 3E                        .BYTE      3EH             ; Skip "ADD HL,DE"
10A3: 19       [11]     FNDARY: ADD     HL,DE           ; Move to next array start
10A4: EB       [15]             EX      DE,HL
10A5: 2A1F21   [31]             LD      HL,(ARREND)     ; End of arrays
10A8: EB       [35]             EX      DE,HL           ; Current array pointer
10A9: CDC507   [52]             CALL    CPDEHL          ; End of arrays found?
10AC: CAD510   [62|62]          JP      Z,CREARY        ; Yes - Create array
10AF: 7E       [69]             LD      A,(HL)          ; Get second byte of name
10B0: B9       [73]             CP      C               ; Compare with name given
10B1: 23       [79]             INC     HL              ; Move on
10B2: C2B710   [89|89]          JP      NZ,NXTARY       ; Different - Find next array
10B5: 7E       [96]             LD      A,(HL)          ; Get first byte of name
10B6: B8       [100]            CP      B               ; Compare with name given
10B7: 23       [ 6]     NXTARY: INC     HL              ; Move on
10B8: 5E       [13]             LD      E,(HL)          ; Get LSB of next array address
10B9: 23       [19]             INC     HL
10BA: 56       [26]             LD      D,(HL)          ; Get MSB of next array address
10BB: 23       [32]             INC     HL
10BC: C2A310   [42|42]          JP      NZ,FNDARY       ; Not found - Keep looking
10BF: 3AF120   [55]             LD      A,(LCRFLG)      ; Found Locate or Create it?
10C2: B7       [59]             OR      A
10C3: C20605   [69|69]          JP      NZ,DDERR        ; Create - ?DD Error
10C6: F1       [79]             POP     AF              ; Locate - Get number of dim'ns
10C7: 44       [83]             LD      B,H             ; BC Points to array dim'ns
10C8: 4D       [87]             LD      C,L
10C9: CAE516   [97|97]          JP      Z,POPHRT        ; Jump if array load/save
10CC: 96       [104]            SUB     (HL)            ; Same number of dimensions?
10CD: CA3311   [114|114]        JP      Z,FINDEL        ; Yes - Find element
10D0: 1E10     [ 7]     BSERR:  LD      E,BS            ; ?BS Error
10D2: C31105   [17]             JP      ERROR           ; Output error
                        
10D5: 110400   [10]     CREARY: LD      DE,4            ; 4 Bytes per entry
10D8: F1       [20]             POP     AF              ; Array to save or 0 dim'ns?
10D9: CA1C0A   [30|30]          JP      Z,FCERR         ; Yes - ?FC Error
10DC: 71       [37]             LD      (HL),C          ; Save second byte of name
10DD: 23       [43]             INC     HL
10DE: 70       [50]             LD      (HL),B          ; Save first byte of name
10DF: 23       [56]             INC     HL
10E0: 4F       [60]             LD      C,A             ; Number of dimensions to C
10E1: CDDA04   [77]             CALL    CHKSTK          ; Check if enough memory
10E4: 23       [83]             INC     HL              ; Point to number of dimensions
10E5: 23       [89]             INC     HL
10E6: 220A21   [105]            LD      (CUROPR),HL     ; Save address of pointer
10E9: 71       [112]            LD      (HL),C          ; Set number of dimensions
10EA: 23       [118]            INC     HL
10EB: 3AF120   [131]            LD      A,(LCRFLG)      ; Locate of Create?
10EE: 17       [135]            RLA                     ; Carry set = Create
10EF: 79       [139]            LD      A,C             ; Get number of dimensions
10F0: 010B00   [10]     CRARLP: LD      BC,10+1         ; Default dimension size 10
10F3: D2F810   [20|20]          JP      NC,DEFSIZ       ; Locate - Set default size
10F6: C1       [30]             POP     BC              ; Get specified dimension size
10F7: 03       [36]             INC     BC              ; Include zero element
10F8: 71       [ 7]     DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
10F9: 23       [13]             INC     HL
10FA: 70       [20]             LD      (HL),B          ; Save MSB of dimension size
10FB: 23       [26]             INC     HL
10FC: F5       [37]             PUSH    AF              ; Save num' of dim'ns an status
10FD: E5       [48]             PUSH    HL              ; Save address of dim'n size
10FE: CD9018   [65]             CALL    MLDEBC          ; Multiply DE by BC to find
1101: EB       [69]             EX      DE,HL           ; amount of mem needed (to DE)
1102: E1       [79]             POP     HL              ; Restore address of dimension
1103: F1       [89]             POP     AF              ; Restore number of dimensions
1104: 3D       [93]             DEC     A               ; Count them
1105: C2F010   [103|103]        JP      NZ,CRARLP       ; Do next dimension if more
1108: F5       [114]            PUSH    AF              ; Save locate/create flag
1109: 42       [118]            LD      B,D             ; MSB of memory needed
110A: 4B       [122]            LD      C,E             ; LSB of memory needed
110B: EB       [126]            EX      DE,HL
110C: 19       [137]            ADD     HL,DE           ; Add bytes to array start
110D: DAF204   [147|147]        JP      C,OMERR         ; Too big - Error
1110: CDE304   [164]            CALL    ENFMEM          ; See if enough memory
1113: 221F21   [180]            LD      (ARREND),HL     ; Save new end of array
                        
1116: 2B       [ 6]     ZERARY: DEC     HL              ; Back through array data
1117: 3600     [16]             LD      (HL),0          ; Set array element to zero
1119: CDC507   [33]             CALL    CPDEHL          ; All elements zeroed?
111C: C21611   [43|43]          JP      NZ,ZERARY       ; No - Keep on going
111F: 03       [49]             INC     BC              ; Number of bytes + 1
1120: 57       [53]             LD      D,A             ; A=0
1121: 2A0A21   [69]             LD      HL,(CUROPR)     ; Get address of array
1124: 5E       [76]             LD      E,(HL)          ; Number of dimensions
1125: EB       [80]             EX      DE,HL           ; To HL
1126: 29       [91]             ADD     HL,HL           ; Two bytes per dimension size
1127: 09       [102]            ADD     HL,BC           ; Add number of bytes
1128: EB       [106]            EX      DE,HL           ; Bytes needed to DE
1129: 2B       [112]            DEC     HL
112A: 2B       [118]            DEC     HL
112B: 73       [125]            LD      (HL),E          ; Save LSB of bytes needed
112C: 23       [131]            INC     HL
112D: 72       [138]            LD      (HL),D          ; Save MSB of bytes needed
112E: 23       [144]            INC     HL
112F: F1       [154]            POP     AF              ; Locate / Create?
1130: DA5711   [164|164]        JP      C,ENDDIM        ; A is 0 , End if create
1133: 47       [ 4]     FINDEL: LD      B,A             ; Find array element
1134: 4F       [ 8]             LD      C,A
1135: 7E       [15]             LD      A,(HL)          ; Number of dimensions
1136: 23       [21]             INC     HL
1137: 16                        .BYTE      16H             ; Skip "POP HL"
1138: E1       [10]     FNDELP: POP     HL              ; Address of next dim' size
1139: 5E       [17]             LD      E,(HL)          ; Get LSB of dim'n size
113A: 23       [23]             INC     HL
113B: 56       [30]             LD      D,(HL)          ; Get MSB of dim'n size
113C: 23       [36]             INC     HL
113D: E3       [55]             EX      (SP),HL         ; Save address - Get index
113E: F5       [66]             PUSH    AF              ; Save number of dim'ns
113F: CDC507   [83]             CALL    CPDEHL          ; Dimension too large?
1142: D2D010   [93|93]          JP      NC,BSERR        ; Yes - ?BS Error
1145: E5       [104]            PUSH    HL              ; Save index
1146: CD9018   [121]            CALL    MLDEBC          ; Multiply previous by size
1149: D1       [131]            POP     DE              ; Index supplied to DE
114A: 19       [142]            ADD     HL,DE           ; Add index to pointer
114B: F1       [152]            POP     AF              ; Number of dimensions
114C: 3D       [156]            DEC     A               ; Count them
114D: 44       [160]            LD      B,H             ; MSB of pointer
114E: 4D       [164]            LD      C,L             ; LSB of pointer
114F: C23811   [174|174]        JP      NZ,FNDELP       ; More - Keep going
1152: 29       [185]            ADD     HL,HL           ; 4 Bytes per element
1153: 29       [196]            ADD     HL,HL
1154: C1       [206]            POP     BC              ; Start of array
1155: 09       [217]            ADD     HL,BC           ; Point to element
1156: EB       [221]            EX      DE,HL           ; Address of element to DE
1157: 2A1521   [16]     ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
115A: C9       [26]             RET
                        
115B: 2A1F21   [16]     FRE:    LD      HL,(ARREND)     ; Start of free memory
115E: EB       [20]             EX      DE,HL           ; To DE
115F: 210000   [30]             LD      HL,0            ; End of free memory
1162: 39       [41]             ADD     HL,SP           ; Current stack value
1163: 3AF220   [54]             LD      A,(TYPE)        ; Dummy argument type
1166: B7       [58]             OR      A
1167: CA7711   [68|68]          JP      Z,FRENUM        ; Numeric - Free variable space
116A: CDDE13   [85]             CALL    GSTRCU          ; Current string to pool
116D: CDDE12   [102]            CALL    GARBGE          ; Garbage collection
1170: 2A9F20   [118]            LD      HL,(STRSPC)     ; Bottom of string space in use
1173: EB       [122]            EX      DE,HL           ; To DE
1174: 2A0821   [138]            LD      HL,(STRBOT)     ; Bottom of string space
1177: 7D       [ 4]     FRENUM: LD      A,L             ; Get LSB of end
1178: 93       [ 8]             SUB     E               ; Subtract LSB of beginning
1179: 4F       [12]             LD      C,A             ; Save difference if C
117A: 7C       [16]             LD      A,H             ; Get MSB of end
117B: 9A       [20]             SBC     A,D             ; Subtract MSB of beginning
117C: 41       [ 4]     ACPASS: LD      B,C             ; Return integer AC
117D: 50       [ 4]     ABPASS: LD      D,B             ; Return integer AB
117E: 1E00     [11]             LD      E,0
1180: 21F220   [21]             LD      HL,TYPE         ; Point to type
1183: 73       [28]             LD      (HL),E          ; Set type to numeric
1184: 0690     [35]             LD      B,80H+16        ; 16 bit integer
1186: C3BB17   [45]             JP      RETINT          ; Return the integr
                        
1189: 3AF020   [13]     POS:    LD      A,(CURPOS)      ; Get cursor position
118C: 47       [ 4]     PASSA:  LD      B,A             ; Put A into AB
118D: AF       [ 8]             XOR     A               ; Zero A
118E: C37D11   [18]             JP      ABPASS          ; Return integer AB
                        
1191: CD1412   [17]     DEF:    CALL    CHEKFN          ; Get "FN" and name
1194: CD0612   [34]             CALL    IDTEST          ; Test for illegal direct
1197: 01EC0A   [44]             LD      BC,DATA         ; To get next statement
119A: C5       [55]             PUSH    BC              ; Save address for RETurn
119B: D5       [66]             PUSH    DE              ; Save address of function ptr
119C: CDCB07   [83]             CALL    CHKSYN          ; Make sure "(" follows
119F: 28                        .BYTE      "("
11A0: CDB80F   [100]            CALL    GETVAR          ; Get argument variable name
11A3: E5       [111]            PUSH    HL              ; Save code string address
11A4: EB       [115]            EX      DE,HL           ; Argument address to HL
11A5: 2B       [121]            DEC     HL
11A6: 56       [128]            LD      D,(HL)          ; Get first byte of arg name
11A7: 2B       [134]            DEC     HL
11A8: 5E       [141]            LD      E,(HL)          ; Get second byte of arg name
11A9: E1       [151]            POP     HL              ; Restore code string address
11AA: CDC50D   [168]            CALL    TSTNUM          ; Make sure numeric argument
11AD: CDCB07   [185]            CALL    CHKSYN          ; Make sure ")" follows
11B0: 29                        .BYTE      ")"
11B1: CDCB07   [202]            CALL    CHKSYN          ; Make sure "=" follows
11B4: B4                        .BYTE      ZEQUAL          ; "=" token
11B5: 44       [206]            LD      B,H             ; Code string address to BC
11B6: 4D       [210]            LD      C,L
11B7: E3       [229]            EX      (SP),HL         ; Save code str , Get FN ptr
11B8: 71       [236]            LD      (HL),C          ; Save LSB of FN code string
11B9: 23       [242]            INC     HL
11BA: 70       [249]            LD      (HL),B          ; Save MSB of FN code string
11BB: C35312   [259]            JP      SVSTAD          ; Save address and do function
                        
11BE: CD1412   [17]     DOFN:   CALL    CHEKFN          ; Make sure FN follows
11C1: D5       [28]             PUSH    DE              ; Save function pointer address
11C2: CD990E   [45]             CALL    EVLPAR          ; Evaluate expression in "()"
11C5: CDC50D   [62]             CALL    TSTNUM          ; Make sure numeric result
11C8: E3       [81]             EX      (SP),HL         ; Save code str , Get FN ptr
11C9: 5E       [88]             LD      E,(HL)          ; Get LSB of FN code string
11CA: 23       [94]             INC     HL
11CB: 56       [101]            LD      D,(HL)          ; Get MSB of FN code string
11CC: 23       [107]            INC     HL
11CD: 7A       [111]            LD      A,D             ; And function DEFined?
11CE: B3       [115]            OR      E
11CF: CA0905   [125|125]        JP      Z,UFERR         ; No - ?UF Error
11D2: 7E       [132]            LD      A,(HL)          ; Get LSB of argument address
11D3: 23       [138]            INC     HL
11D4: 66       [145]            LD      H,(HL)          ; Get MSB of argument address
11D5: 6F       [149]            LD      L,A             ; HL = Arg variable address
11D6: E5       [160]            PUSH    HL              ; Save it
11D7: 2A2321   [176]            LD      HL,(FNRGNM)     ; Get old argument name
11DA: E3       [195]            EX      (SP),HL ;       ; Save old , Get new
11DB: 222321   [211]            LD      (FNRGNM),HL     ; Set new argument name
11DE: 2A2721   [227]            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
11E1: E5       [238]            PUSH    HL              ; Save it
11E2: 2A2521   [254]            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
11E5: E5       [265]            PUSH    HL              ; Save it
11E6: 212521   [275]            LD      HL,FNARG        ; HL = Value of argument
11E9: D5       [286]            PUSH    DE              ; Save FN code string address
11EA: CDFC17   [303]            CALL    FPTHL           ; Move FPREG to argument
11ED: E1       [313]            POP     HL              ; Get FN code string address
11EE: CDC20D   [330]            CALL    GETNUM          ; Get value from function
11F1: 2B       [336]            DEC     HL              ; DEC 'cos GETCHR INCs
11F2: CD5509   [353]            CALL    GETCHR          ; Get next character
11F5: C2FD04   [363|363]        JP      NZ,SNERR        ; Bad character in FN - Error
11F8: E1       [373]            POP     HL              ; Get MSB,EXP of old arg
11F9: 222521   [389]            LD      (FNARG),HL      ; Restore it
11FC: E1       [399]            POP     HL              ; Get LSB,NLSB of old arg
11FD: 222721   [415]            LD      (FNARG+2),HL    ; Restore it
1200: E1       [425]            POP     HL              ; Get name of old arg
1201: 222321   [441]            LD      (FNRGNM),HL     ; Restore it
1204: E1       [451]            POP     HL              ; Restore code string address
1205: C9       [461]            RET
                        
1206: E5       [11]     IDTEST: PUSH    HL              ; Save code string address
1207: 2AA120   [27]             LD      HL,(LINEAT)     ; Get current line number
120A: 23       [33]             INC     HL              ; -1 means direct statement
120B: 7C       [37]             LD      A,H
120C: B5       [41]             OR      L
120D: E1       [51]             POP     HL              ; Restore code string address
120E: C0       [56|62]          RET     NZ              ; Return if in program
120F: 1E16     [63]             LD      E,ID            ; ?ID Error
1211: C31105   [73]             JP      ERROR
                        
1214: CDCB07   [17]     CHEKFN: CALL    CHKSYN          ; Make sure FN follows
1217: A7                        .BYTE      ZFN             ; "FN" token
1218: 3E80     [24]             LD      A,80H
121A: 321021   [37]             LD      (FORFLG),A      ; Flag FN name to find
121D: B6       [44]             OR      (HL)            ; FN name has bit 7 set
121E: 47       [48]             LD      B,A             ; in first byte of name
121F: CDBD0F   [65]             CALL    GTFNAM          ; Get FN name
1222: C3C50D   [75]             JP      TSTNUM          ; Make sure numeric function
                        
1225: CDC50D   [17]     STR:    CALL    TSTNUM          ; Make sure it's a number
1228: CD4919   [34]             CALL    NUMASC          ; Turn number into text
122B: CD5912   [17]     STR1:   CALL    CRTST           ; Create string entry for it
122E: CDDE13   [34]             CALL    GSTRCU          ; Current string to pool
1231: 013914   [44]             LD      BC,TOPOOL       ; Save in string pool
1234: C5       [55]             PUSH    BC              ; Save address on stack
                        
1235: 7E       [ 7]     SAVSTR: LD      A,(HL)          ; Get string length
1236: 23       [13]             INC     HL
1237: 23       [19]             INC     HL
1238: E5       [30]             PUSH    HL              ; Save pointer to string
1239: CDB412   [47]             CALL    TESTR           ; See if enough string space
123C: E1       [57]             POP     HL              ; Restore pointer to string
123D: 4E       [64]             LD      C,(HL)          ; Get LSB of address
123E: 23       [70]             INC     HL
123F: 46       [77]             LD      B,(HL)          ; Get MSB of address
1240: CD4D12   [94]             CALL    CRTMST          ; Create string entry
1243: E5       [105]            PUSH    HL              ; Save pointer to MSB of addr
1244: 6F       [109]            LD      L,A             ; Length of string
1245: CDD113   [126]            CALL    TOSTRA          ; Move to string area
1248: D1       [136]            POP     DE              ; Restore pointer to MSB
1249: C9       [146]            RET
                        
124A: CDB412   [17]     MKTMST: CALL    TESTR           ; See if enough string space
124D: 210421   [10]     CRTMST: LD      HL,TMPSTR       ; Temporary string
1250: E5       [21]             PUSH    HL              ; Save it
1251: 77       [28]             LD      (HL),A          ; Save length of string
1252: 23       [34]             INC     HL
1253: 23       [ 6]     SVSTAD: INC     HL
1254: 73       [13]             LD      (HL),E          ; Save LSB of address
1255: 23       [19]             INC     HL
1256: 72       [26]             LD      (HL),D          ; Save MSB of address
1257: E1       [36]             POP     HL              ; Restore pointer
1258: C9       [46]             RET
                        
1259: 2B       [ 6]     CRTST:  DEC     HL              ; DEC - INCed after
125A: 0622     [ 7]     QTSTR:  LD      B,'"'           ; Terminating quote
125C: 50       [11]             LD      D,B             ; Quote to D
125D: E5       [11]     DTSTR:  PUSH    HL              ; Save start
125E: 0EFF     [18]             LD      C,-1            ; Set counter to -1
1260: 23       [ 6]     QTSTLP: INC     HL              ; Move on
1261: 7E       [13]             LD      A,(HL)          ; Get byte
1262: 0C       [17]             INC     C               ; Count bytes
1263: B7       [21]             OR      A               ; End of line?
1264: CA6F12   [31|31]          JP      Z,CRTSTE        ; Yes - Create string entry
1267: BA       [35]             CP      D               ; Terminator D found?
1268: CA6F12   [45|45]          JP      Z,CRTSTE        ; Yes - Create string entry
126B: B8       [49]             CP      B               ; Terminator B found?
126C: C26012   [59|59]          JP      NZ,QTSTLP       ; No - Keep looking
126F: FE22     [ 7]     CRTSTE: CP      '"'             ; End with '"'?
1271: CC5509   [17|24]          CALL    Z,GETCHR        ; Yes - Get next character
1274: E3       [36]             EX      (SP),HL         ; Starting quote
1275: 23       [42]             INC     HL              ; First byte of string
1276: EB       [46]             EX      DE,HL           ; To DE
1277: 79       [50]             LD      A,C             ; Get length
1278: CD4D12   [67]             CALL    CRTMST          ; Create string entry
127B: 110421   [10]     TSTOPL: LD      DE,TMPSTR       ; Temporary string
127E: 2AF620   [26]             LD      HL,(TMSTPT)     ; Temporary string pool pointer
1281: 222921   [42]             LD      (FPREG),HL      ; Save address of string ptr
1284: 3E01     [49]             LD      A,1
1286: 32F220   [62]             LD      (TYPE),A        ; Set type to string
1289: CDFF17   [79]             CALL    DETHL4          ; Move string to pool
128C: CDC507   [96]             CALL    CPDEHL          ; Out of string pool?
128F: 22F620   [112]            LD      (TMSTPT),HL     ; Save new pointer
1292: E1       [122]            POP     HL              ; Restore code string address
1293: 7E       [129]            LD      A,(HL)          ; Get next code byte
1294: C0       [134|140]        RET     NZ              ; Return if pool OK
1295: 1E1E     [141]            LD      E,ST            ; ?ST Error
1297: C31105   [151]            JP      ERROR           ; String pool overflow
                        
129A: 23       [ 6]     PRNUMS: INC     HL              ; Skip leading space
129B: CD5912   [17]     PRS:    CALL    CRTST           ; Create string entry for it
129E: CDDE13   [17]     PRS1:   CALL    GSTRCU          ; Current string to pool
12A1: CDF317   [34]             CALL    LOADFP          ; Move string block to BCDE
12A4: 1C       [38]             INC     E               ; Length + 1
12A5: 1D       [ 4]     PRSLP:  DEC     E               ; Count characters
12A6: C8       [ 9|15]          RET     Z               ; End of string
12A7: 0A       [16]             LD      A,(BC)          ; Get byte to output
12A8: CDD607   [33]             CALL    OUTC            ; Output character in A
12AB: FE0D     [40]             CP      CR              ; Return?
12AD: CC070C   [50|57]          CALL    Z,DONULL        ; Yes - Do nulls
12B0: 03       [56]             INC     BC              ; Next byte in string
12B1: C3A512   [66]             JP      PRSLP           ; More characters to output
                        
12B4: B7       [ 4]     TESTR:  OR      A               ; Test if enough room
12B5: 0E                        .BYTE      0EH             ; No garbage collection done
12B6: F1       [10]     GRBDON: POP     AF              ; Garbage collection done
12B7: F5       [21]             PUSH    AF              ; Save status
12B8: 2A9F20   [37]             LD      HL,(STRSPC)     ; Bottom of string space in use
12BB: EB       [41]             EX      DE,HL           ; To DE
12BC: 2A0821   [57]             LD      HL,(STRBOT)     ; Bottom of string area
12BF: 2F       [61]             CPL                     ; Negate length (Top down)
12C0: 4F       [65]             LD      C,A             ; -Length to BC
12C1: 06FF     [72]             LD      B,-1            ; BC = -ve length of string
12C3: 09       [83]             ADD     HL,BC           ; Add to bottom of space in use
12C4: 23       [89]             INC     HL              ; Plus one for 2's complement
12C5: CDC507   [106]            CALL    CPDEHL          ; Below string RAM area?
12C8: DAD212   [116|116]        JP      C,TESTOS        ; Tidy up if not done else err
12CB: 220821   [132]            LD      (STRBOT),HL     ; Save new bottom of area
12CE: 23       [138]            INC     HL              ; Point to first byte of string
12CF: EB       [142]            EX      DE,HL           ; Address to DE
12D0: F1       [10]     POPAF:  POP     AF              ; Throw away status push
12D1: C9       [20]             RET
                        
12D2: F1       [10]     TESTOS: POP     AF              ; Garbage collect been done?
12D3: 1E1A     [17]             LD      E,OS            ; ?OS Error
12D5: CA1105   [27|27]          JP      Z,ERROR         ; Yes - Not enough string apace
12D8: BF       [31]             CP      A               ; Flag garbage collect done
12D9: F5       [42]             PUSH    AF              ; Save status
12DA: 01B612   [52]             LD      BC,GRBDON       ; Garbage collection done
12DD: C5       [63]             PUSH    BC              ; Save for RETurn
12DE: 2AF420   [16]     GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
12E1: 220821   [16]     GARBLP: LD      (STRBOT),HL     ; Reset string pointer
12E4: 210000   [26]             LD      HL,0
12E7: E5       [37]             PUSH    HL              ; Flag no string found
12E8: 2A9F20   [53]             LD      HL,(STRSPC)     ; Get bottom of string space
12EB: E5       [64]             PUSH    HL              ; Save bottom of string space
12EC: 21F820   [74]             LD      HL,TMSTPL       ; Temporary string pool
12EF: EB       [ 4]     GRBLP:  EX      DE,HL
12F0: 2AF620   [20]             LD      HL,(TMSTPT)     ; Temporary string pool pointer
12F3: EB       [24]             EX      DE,HL
12F4: CDC507   [41]             CALL    CPDEHL          ; Temporary string pool done?
12F7: 01EF12   [51]             LD      BC,GRBLP        ; Loop until string pool done
12FA: C24313   [61|61]          JP      NZ,STPOOL       ; No - See if in string area
12FD: 2A1B21   [77]             LD      HL,(PROGND)     ; Start of simple variables
1300: EB       [ 4]     SMPVAR: EX      DE,HL
1301: 2A1D21   [20]             LD      HL,(VAREND)     ; End of simple variables
1304: EB       [24]             EX      DE,HL
1305: CDC507   [41]             CALL    CPDEHL          ; All simple strings done?
1308: CA1613   [51|51]          JP      Z,ARRLP         ; Yes - Do string arrays
130B: 7E       [58]             LD      A,(HL)          ; Get type of variable
130C: 23       [64]             INC     HL
130D: 23       [70]             INC     HL
130E: B7       [74]             OR      A               ; "S" flag set if string
130F: CD4613   [91]             CALL    STRADD          ; See if string in string area
1312: C30013   [101]            JP      SMPVAR          ; Loop until simple ones done
                        
1315: C1       [10]     GNXARY: POP     BC              ; Scrap address of this array
1316: EB       [ 4]     ARRLP:  EX      DE,HL
1317: 2A1F21   [20]             LD      HL,(ARREND)     ; End of string arrays
131A: EB       [24]             EX      DE,HL
131B: CDC507   [41]             CALL    CPDEHL          ; All string arrays done?
131E: CA6C13   [51|51]          JP      Z,SCNEND        ; Yes - Move string if found
1321: CDF317   [68]             CALL    LOADFP          ; Get array name to BCDE
1324: 7B       [72]             LD      A,E             ; Get type of array     
1325: E5       [83]             PUSH    HL              ; Save address of num of dim'ns
1326: 09       [94]             ADD     HL,BC           ; Start of next array
1327: B7       [98]             OR      A               ; Test type of array
1328: F21513   [108|108]        JP      P,GNXARY        ; Numeric array - Ignore it
132B: 220A21   [124]            LD      (CUROPR),HL     ; Save address of next array
132E: E1       [134]            POP     HL              ; Get address of num of dim'ns
132F: 4E       [141]            LD      C,(HL)          ; BC = Number of dimensions
1330: 0600     [148]            LD      B,0
1332: 09       [159]            ADD     HL,BC           ; Two bytes per dimension size
1333: 09       [170]            ADD     HL,BC
1334: 23       [176]            INC     HL              ; Plus one for number of dim'ns
1335: EB       [ 4]     GRBARY: EX      DE,HL
1336: 2A0A21   [20]             LD      HL,(CUROPR)     ; Get address of next array
1339: EB       [24]             EX      DE,HL
133A: CDC507   [41]             CALL    CPDEHL          ; Is this array finished?
133D: CA1613   [51|51]          JP      Z,ARRLP         ; Yes - Get next one
1340: 013513   [61]             LD      BC,GRBARY       ; Loop until array all done
1343: C5       [11]     STPOOL: PUSH    BC              ; Save return address
1344: F680     [18]             OR      80H             ; Flag string type
1346: 7E       [ 7]     STRADD: LD      A,(HL)          ; Get string length
1347: 23       [13]             INC     HL
1348: 23       [19]             INC     HL
1349: 5E       [26]             LD      E,(HL)          ; Get LSB of string address
134A: 23       [32]             INC     HL
134B: 56       [39]             LD      D,(HL)          ; Get MSB of string address
134C: 23       [45]             INC     HL
134D: F0       [50|56]          RET     P               ; Not a string - Return
134E: B7       [54]             OR      A               ; Set flags on string length
134F: C8       [59|65]          RET     Z               ; Null string - Return
1350: 44       [63]             LD      B,H             ; Save variable pointer
1351: 4D       [67]             LD      C,L
1352: 2A0821   [83]             LD      HL,(STRBOT)     ; Bottom of new area
1355: CDC507   [100]            CALL    CPDEHL          ; String been done?
1358: 60       [104]            LD      H,B             ; Restore variable pointer
1359: 69       [108]            LD      L,C
135A: D8       [113|119]        RET     C               ; String done - Ignore
135B: E1       [123]            POP     HL              ; Return address
135C: E3       [142]            EX      (SP),HL         ; Lowest available string area
135D: CDC507   [159]            CALL    CPDEHL          ; String within string area?
1360: E3       [178]            EX      (SP),HL         ; Lowest available string area
1361: E5       [189]            PUSH    HL              ; Re-save return address
1362: 60       [193]            LD      H,B             ; Restore variable pointer
1363: 69       [197]            LD      L,C
1364: D0       [202|208]        RET     NC              ; Outside string area - Ignore
1365: C1       [212]            POP     BC              ; Get return , Throw 2 away
1366: F1       [222]            POP     AF              ; 
1367: F1       [232]            POP     AF              ; 
1368: E5       [243]            PUSH    HL              ; Save variable pointer
1369: D5       [254]            PUSH    DE              ; Save address of current
136A: C5       [265]            PUSH    BC              ; Put back return address
136B: C9       [275]            RET                     ; Go to it
                        
136C: D1       [10]     SCNEND: POP     DE              ; Addresses of strings
136D: E1       [20]             POP     HL              ; 
136E: 7D       [24]             LD      A,L             ; HL = 0 if no more to do
136F: B4       [28]             OR      H
1370: C8       [33|39]          RET     Z               ; No more to do - Return
1371: 2B       [39]             DEC     HL
1372: 46       [46]             LD      B,(HL)          ; MSB of address of string
1373: 2B       [52]             DEC     HL
1374: 4E       [59]             LD      C,(HL)          ; LSB of address of string
1375: E5       [70]             PUSH    HL              ; Save variable address
1376: 2B       [76]             DEC     HL
1377: 2B       [82]             DEC     HL
1378: 6E       [89]             LD      L,(HL)          ; HL = Length of string
1379: 2600     [96]             LD      H,0
137B: 09       [107]            ADD     HL,BC           ; Address of end of string+1
137C: 50       [111]            LD      D,B             ; String address to DE
137D: 59       [115]            LD      E,C
137E: 2B       [121]            DEC     HL              ; Last byte in string
137F: 44       [125]            LD      B,H             ; Address to BC
1380: 4D       [129]            LD      C,L
1381: 2A0821   [145]            LD      HL,(STRBOT)     ; Current bottom of string area
1384: CDCC04   [162]            CALL    MOVSTR          ; Move string to new address
1387: E1       [172]            POP     HL              ; Restore variable address
1388: 71       [179]            LD      (HL),C          ; Save new LSB of address
1389: 23       [185]            INC     HL
138A: 70       [192]            LD      (HL),B          ; Save new MSB of address
138B: 69       [196]            LD      L,C             ; Next string area+1 to HL
138C: 60       [200]            LD      H,B
138D: 2B       [206]            DEC     HL              ; Next string area address
138E: C3E112   [216]            JP      GARBLP          ; Look for more strings
                        
1391: C5       [11]     CONCAT: PUSH    BC              ; Save prec' opr & code string
1392: E5       [22]             PUSH    HL              ; 
1393: 2A2921   [38]             LD      HL,(FPREG)      ; Get first string
1396: E3       [57]             EX      (SP),HL         ; Save first string
1397: CD4B0E   [74]             CALL    OPRND           ; Get second string
139A: E3       [93]             EX      (SP),HL         ; Restore first string
139B: CDC60D   [110]            CALL    TSTSTR          ; Make sure it's a string
139E: 7E       [117]            LD      A,(HL)          ; Get length of second string
139F: E5       [128]            PUSH    HL              ; Save first string
13A0: 2A2921   [144]            LD      HL,(FPREG)      ; Get second string
13A3: E5       [155]            PUSH    HL              ; Save second string
13A4: 86       [162]            ADD     A,(HL)          ; Add length of second string
13A5: 1E1C     [169]            LD      E,LS            ; ?LS Error
13A7: DA1105   [179|179]        JP      C,ERROR         ; String too long - Error
13AA: CD4A12   [196]            CALL    MKTMST          ; Make temporary string
13AD: D1       [206]            POP     DE              ; Get second string to DE
13AE: CDE213   [223]            CALL    GSTRDE          ; Move to string pool if needed
13B1: E3       [242]            EX      (SP),HL         ; Get first string
13B2: CDE113   [259]            CALL    GSTRHL          ; Move to string pool if needed
13B5: E5       [270]            PUSH    HL              ; Save first string
13B6: 2A0621   [286]            LD      HL,(TMPSTR+2)   ; Temporary string address
13B9: EB       [290]            EX      DE,HL           ; To DE
13BA: CDC813   [307]            CALL    SSTSA           ; First string to string area
13BD: CDC813   [324]            CALL    SSTSA           ; Second string to string area
13C0: 21E00D   [334]            LD      HL,EVAL2        ; Return to evaluation loop
13C3: E3       [353]            EX      (SP),HL         ; Save return,get code string
13C4: E5       [364]            PUSH    HL              ; Save code string address
13C5: C37B12   [374]            JP      TSTOPL          ; To temporary string to pool
                        
13C8: E1       [10]     SSTSA:  POP     HL              ; Return address
13C9: E3       [29]             EX      (SP),HL         ; Get string block,save return
13CA: 7E       [36]             LD      A,(HL)          ; Get length of string
13CB: 23       [42]             INC     HL
13CC: 23       [48]             INC     HL
13CD: 4E       [55]             LD      C,(HL)          ; Get LSB of string address
13CE: 23       [61]             INC     HL
13CF: 46       [68]             LD      B,(HL)          ; Get MSB of string address
13D0: 6F       [72]             LD      L,A             ; Length to L
13D1: 2C       [ 4]     TOSTRA: INC     L               ; INC - DECed after
13D2: 2D       [ 4]     TSALP:  DEC     L               ; Count bytes moved
13D3: C8       [ 9|15]          RET     Z               ; End of string - Return
13D4: 0A       [16]             LD      A,(BC)          ; Get source
13D5: 12       [23]             LD      (DE),A          ; Save destination
13D6: 03       [29]             INC     BC              ; Next source
13D7: 13       [35]             INC     DE              ; Next destination
13D8: C3D213   [45]             JP      TSALP           ; Loop until string moved
                        
13DB: CDC60D   [17]     GETSTR: CALL    TSTSTR          ; Make sure it's a string
13DE: 2A2921   [16]     GSTRCU: LD      HL,(FPREG)      ; Get current string
13E1: EB       [ 4]     GSTRHL: EX      DE,HL           ; Save DE
13E2: CDFC13   [17]     GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
13E5: EB       [21]             EX      DE,HL           ; Restore DE
13E6: C0       [26|32]          RET     NZ              ; No - Return
13E7: D5       [37]             PUSH    DE              ; Save string
13E8: 50       [41]             LD      D,B             ; String block address to DE
13E9: 59       [45]             LD      E,C
13EA: 1B       [51]             DEC     DE              ; Point to length
13EB: 4E       [58]             LD      C,(HL)          ; Get string length
13EC: 2A0821   [74]             LD      HL,(STRBOT)     ; Current bottom of string area
13EF: CDC507   [91]             CALL    CPDEHL          ; Last one in string area?
13F2: C2FA13   [101|101]        JP      NZ,POPHL        ; No - Return
13F5: 47       [105]            LD      B,A             ; Clear B (A=0)
13F6: 09       [116]            ADD     HL,BC           ; Remove string from str' area
13F7: 220821   [132]            LD      (STRBOT),HL     ; Save new bottom of str' area
13FA: E1       [10]     POPHL:  POP     HL              ; Restore string
13FB: C9       [20]             RET
                        
13FC: 2AF620   [16]     BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
13FF: 2B       [22]             DEC     HL              ; Back
1400: 46       [29]             LD      B,(HL)          ; Get MSB of address
1401: 2B       [35]             DEC     HL              ; Back
1402: 4E       [42]             LD      C,(HL)          ; Get LSB of address
1403: 2B       [48]             DEC     HL              ; Back
1404: 2B       [54]             DEC     HL              ; Back
1405: CDC507   [71]             CALL    CPDEHL          ; String last in string pool?
1408: C0       [76|82]          RET     NZ              ; Yes - Leave it
1409: 22F620   [92]             LD      (TMSTPT),HL     ; Save new string pool top
140C: C9       [102]            RET
                        
140D: 018C11   [10]     LEN:    LD      BC,PASSA        ; To return integer A
1410: C5       [21]             PUSH    BC              ; Save address
1411: CDDB13   [17]     GETLEN: CALL    GETSTR          ; Get string and its length
1414: AF       [21]             XOR     A
1415: 57       [25]             LD      D,A             ; Clear D
1416: 32F220   [38]             LD      (TYPE),A        ; Set type to numeric
1419: 7E       [45]             LD      A,(HL)          ; Get length of string
141A: B7       [49]             OR      A               ; Set status flags
141B: C9       [59]             RET
                        
141C: 018C11   [10]     ASC:    LD      BC,PASSA        ; To return integer A
141F: C5       [21]             PUSH    BC              ; Save address
1420: CD1114   [17]     GTFLNM: CALL    GETLEN          ; Get length of string
1423: CA1C0A   [27|27]          JP      Z,FCERR         ; Null string - Error
1426: 23       [33]             INC     HL
1427: 23       [39]             INC     HL
1428: 5E       [46]             LD      E,(HL)          ; Get LSB of address
1429: 23       [52]             INC     HL
142A: 56       [59]             LD      D,(HL)          ; Get MSB of address
142B: 1A       [66]             LD      A,(DE)          ; Get first byte of string
142C: C9       [76]             RET
                        
142D: 3E01     [ 7]     CHR:    LD      A,1             ; One character string
142F: CD4A12   [24]             CALL    MKTMST          ; Make a temporary string
1432: CD2615   [41]             CALL    MAKINT          ; Make it integer A
1435: 2A0621   [57]             LD      HL,(TMPSTR+2)   ; Get address of string
1438: 73       [64]             LD      (HL),E          ; Save character
1439: C1       [10]     TOPOOL: POP     BC              ; Clean up stack
143A: C37B12   [20]             JP      TSTOPL          ; Temporary string to pool
                        
143D: CDD614   [17]     LEFT:   CALL    LFRGNM          ; Get number and ending ")"
1440: AF       [21]             XOR     A               ; Start at first byte in string
1441: E3       [19]     RIGHT1: EX      (SP),HL         ; Save code string,Get string
1442: 4F       [23]             LD      C,A             ; Starting position in string
1443: E5       [11]     MID1:   PUSH    HL              ; Save string block address
1444: 7E       [18]             LD      A,(HL)          ; Get length of string
1445: B8       [22]             CP      B               ; Compare with number given
1446: DA4B14   [32|32]          JP      C,ALLFOL        ; All following bytes required
1449: 78       [36]             LD      A,B             ; Get new length
144A: 11                        .BYTE      11H             ; Skip "LD C,0"
144B: 0E00     [ 7]     ALLFOL: LD      C,0             ; First byte of string
144D: C5       [18]             PUSH    BC              ; Save position in string
144E: CDB412   [35]             CALL    TESTR           ; See if enough string space
1451: C1       [45]             POP     BC              ; Get position in string
1452: E1       [55]             POP     HL              ; Restore string block address
1453: E5       [66]             PUSH    HL              ; And re-save it
1454: 23       [72]             INC     HL
1455: 23       [78]             INC     HL
1456: 46       [85]             LD      B,(HL)          ; Get LSB of address
1457: 23       [91]             INC     HL
1458: 66       [98]             LD      H,(HL)          ; Get MSB of address
1459: 68       [102]            LD      L,B             ; HL = address of string
145A: 0600     [109]            LD      B,0             ; BC = starting address
145C: 09       [120]            ADD     HL,BC           ; Point to that byte
145D: 44       [124]            LD      B,H             ; BC = source string
145E: 4D       [128]            LD      C,L
145F: CD4D12   [145]            CALL    CRTMST          ; Create a string entry
1462: 6F       [149]            LD      L,A             ; Length of new string
1463: CDD113   [166]            CALL    TOSTRA          ; Move string to string area
1466: D1       [176]            POP     DE              ; Clear stack
1467: CDE213   [193]            CALL    GSTRDE          ; Move to string pool if needed
146A: C37B12   [203]            JP      TSTOPL          ; Temporary string to pool
                        
146D: CDD614   [17]     RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
1470: D1       [27]             POP     DE              ; Get string length
1471: D5       [38]             PUSH    DE              ; And re-save
1472: 1A       [45]             LD      A,(DE)          ; Get length
1473: 90       [49]             SUB     B               ; Move back N bytes
1474: C34114   [59]             JP      RIGHT1          ; Go and get sub-string
                        
1477: EB       [ 4]     MID:    EX      DE,HL           ; Get code string address
1478: 7E       [11]             LD      A,(HL)          ; Get next byte ',' or ")"
1479: CDDB14   [28]             CALL    MIDNUM          ; Get number supplied
147C: 04       [32]             INC     B               ; Is it character zero?
147D: 05       [36]             DEC     B
147E: CA1C0A   [46|46]          JP      Z,FCERR         ; Yes - Error
1481: C5       [57]             PUSH    BC              ; Save starting position
1482: 1EFF     [64]             LD      E,255           ; All of string
1484: FE29     [71]             CP      ')'             ; Any length given?
1486: CA9014   [81|81]          JP      Z,RSTSTR        ; No - Rest of string
1489: CDCB07   [98]             CALL    CHKSYN          ; Make sure ',' follows
148C: 2C                        .BYTE      ','
148D: CD2315   [115]            CALL    GETINT          ; Get integer 0-255
1490: CDCB07   [17]     RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
1493: 29                        .BYTE      ")"
1494: F1       [27]             POP     AF              ; Restore starting position
1495: E3       [46]             EX      (SP),HL         ; Get string,8ave code string
1496: 014314   [56]             LD      BC,MID1         ; Continuation of MID$ routine
1499: C5       [67]             PUSH    BC              ; Save for return
149A: 3D       [71]             DEC     A               ; Starting position-1
149B: BE       [78]             CP      (HL)            ; Compare with length
149C: 0600     [85]             LD      B,0             ; Zero bytes length
149E: D0       [90|96]          RET     NC              ; Null string if start past end
149F: 4F       [94]             LD      C,A             ; Save starting position-1
14A0: 7E       [101]            LD      A,(HL)          ; Get length of string
14A1: 91       [105]            SUB     C               ; Subtract start
14A2: BB       [109]            CP      E               ; Enough string for it?
14A3: 47       [113]            LD      B,A             ; Save maximum length available
14A4: D8       [118|124]        RET     C               ; Truncate string if needed
14A5: 43       [122]            LD      B,E             ; Set specified length
14A6: C9       [132]            RET                     ; Go and create string
                        
14A7: CD1114   [17]     VAL:    CALL    GETLEN          ; Get length of string
14AA: CAC415   [27|27]          JP      Z,RESZER        ; Result zero
14AD: 5F       [31]             LD      E,A             ; Save length
14AE: 23       [37]             INC     HL
14AF: 23       [43]             INC     HL
14B0: 7E       [50]             LD      A,(HL)          ; Get LSB of address
14B1: 23       [56]             INC     HL
14B2: 66       [63]             LD      H,(HL)          ; Get MSB of address
14B3: 6F       [67]             LD      L,A             ; HL = String address
14B4: E5       [78]             PUSH    HL              ; Save string address
14B5: 19       [89]             ADD     HL,DE
14B6: 46       [96]             LD      B,(HL)          ; Get end of string+1 byte
14B7: 72       [103]            LD      (HL),D          ; Zero it to terminate
14B8: E3       [122]            EX      (SP),HL         ; Save string end,get start
14B9: C5       [133]            PUSH    BC              ; Save end+1 byte
14BA: 7E       [140]            LD      A,(HL)          ; Get starting byte
14BB: FE24     [147]        CP	'$'		; Hex number indicated? [function added]
14BD: C2C514   [157|157]    JP	NZ,VAL1
14C0: CDEF1C   [174]        CALL	HEXTFP		; Convert Hex to FPREG
14C3: 180D     [186]        JR	VAL3
14C5: FE25     [ 7]     VAL1:	CP	'%'		; Binary number indicated? [function added]
14C7: C2CF14   [17|17]      JP	NZ,VAL2
14CA: CD5F1D   [34]         CALL	BINTFP		; Convert Bin to FPREG
14CD: 1803     [46]         JR	VAL3
14CF: CDAB18   [17]     VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
14D2: C1       [10]     VAL3:   POP     BC              ; Restore end+1 byte
14D3: E1       [20]             POP     HL              ; Restore end+1 address
14D4: 70       [27]             LD      (HL),B          ; Put back original byte
14D5: C9       [37]             RET
                        
14D6: EB       [ 4]     LFRGNM: EX      DE,HL           ; Code string address to HL
14D7: CDCB07   [21]             CALL    CHKSYN          ; Make sure ")" follows
14DA: 29                        .BYTE      ")"
14DB: C1       [10]     MIDNUM: POP     BC              ; Get return address
14DC: D1       [20]             POP     DE              ; Get number supplied
14DD: C5       [31]             PUSH    BC              ; Re-save return address
14DE: 43       [35]             LD      B,E             ; Number to B
14DF: C9       [45]             RET
                        
14E0: CD2615   [17]     INP:    CALL    MAKINT          ; Make it integer A

14E6: CD8320   [47]             CALL    INPSUB          ; Get input from port
14E9: C38C11   [57]             JP      PASSA           ; Return integer A
                        
14EC: CD1015   [17]     POUT:   CALL    SETIO           ; Set up port number
14EF: C34B20   [27]             JP      OUTSUB          ; Output data and return
                        
14F2: CD1015   [17]     WAIT:   CALL    SETIO           ; Set up port number
14F5: F5       [28]             PUSH    AF              ; Save AND mask
14F6: 1E00     [35]             LD      E,0             ; Assume zero if none given
14F8: 2B       [41]             DEC     HL              ; DEC 'cos GETCHR INCs
14F9: CD5509   [58]             CALL    GETCHR          ; Get next character
14FC: CA0615   [68|68]          JP      Z,NOXOR         ; No XOR byte given
14FF: CDCB07   [85]             CALL    CHKSYN          ; Make sure ',' follows
1502: 2C                        .BYTE      ','
1503: CD2315   [102]            CALL    GETINT          ; Get integer 0-255 to XOR with
1506: C1       [10]     NOXOR:  POP     BC              ; Restore AND mask
1507: CD8320   [17]     WAITLP: CALL    INPSUB          ; Get input
150A: AB       [21]             XOR     E               ; Flip selected bits
150B: A0       [25]             AND     B               ; Result non-zero?
150C: CA0715   [35|35]          JP      Z,WAITLP        ; No = keep waiting
150F: C9       [45]             RET
                        
1510: CD2315   [17]     SETIO:  CALL    GETINT          ; Get integer 0-255
1513: 328420   [30]             LD      (INPORT),A      ; Set input port
1516: 324C20   [43]             LD      (OTPORT),A      ; Set output port
1519: CDCB07   [60]             CALL    CHKSYN          ; Make sure ',' follows
151C: 2C                        .BYTE      ','
151D: C32315   [70]             JP      GETINT          ; Get integer 0-255 and return
                        
1520: CD5509   [17]     FNDNUM: CALL    GETCHR          ; Get next character
1523: CDC20D   [17]     GETINT: CALL    GETNUM          ; Get a number from 0 to 255
1526: CD010A   [17]     MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
1529: 7A       [21]             LD      A,D             ; Get MSB of number
152A: B7       [25]             OR      A               ; Zero?
152B: C21C0A   [35|35]          JP      NZ,FCERR        ; No - Error
152E: 2B       [41]             DEC     HL              ; DEC 'cos GETCHR INCs
152F: CD5509   [58]             CALL    GETCHR          ; Get next character
1532: 7B       [62]             LD      A,E             ; Get number to A
1533: C9       [72]             RET
                        
1534: CD070A   [17]     PEEK:   CALL    DEINT           ; Get memory address
1537: 1A       [24]             LD      A,(DE)          ; Get byte in memory
1538: C38C11   [34]             JP      PASSA           ; Return integer A
                        
153B: CDC20D   [17]     POKE:   CALL    GETNUM          ; Get memory address
153E: CD070A   [34]             CALL    DEINT           ; Get integer -32768 to 3276
1541: D5       [45]             PUSH    DE              ; Save memory address
1542: CDCB07   [62]             CALL    CHKSYN          ; Make sure ',' follows
1545: 2C                        .BYTE      ','
1546: CD2315   [79]             CALL    GETINT          ; Get integer 0-255
1549: D1       [89]             POP     DE              ; Restore memory address
154A: 12       [96]             LD      (DE),A          ; Load it into memory
154B: C9       [106]            RET
                        
154C: 21221A   [10]     ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
154F: CDF317   [17]     ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
1552: C35E15   [27]             JP      FPADD           ; Add BCDE to FPREG
                        
1555: CDF317   [17]     SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
1558: 21                        .BYTE      21H             ; Skip "POP BC" and "POP DE"
1559: C1       [10]     PSUB:   POP     BC              ; Get FP number from stack
155A: D1       [20]             POP     DE
155B: CDCD17   [17]     SUBCDE: CALL    INVSGN          ; Negate FPREG
155E: 78       [ 4]     FPADD:  LD      A,B             ; Get FP exponent
155F: B7       [ 8]             OR      A               ; Is number zero?
1560: C8       [13|19]          RET     Z               ; Yes - Nothing to add
1561: 3A2C21   [26]             LD      A,(FPEXP)       ; Get FPREG exponent
1564: B7       [30]             OR      A               ; Is this number zero?
1565: CAE517   [40|40]          JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
1568: 90       [44]             SUB     B               ; BCDE number larger?
1569: D27815   [54|54]          JP      NC,NOSWAP       ; No - Don't swap them
156C: 2F       [58]             CPL                     ; Two's complement
156D: 3C       [62]             INC     A               ;  FP exponent
156E: EB       [66]             EX      DE,HL
156F: CDD517   [83]             CALL    STAKFP          ; Put FPREG on stack
1572: EB       [87]             EX      DE,HL
1573: CDE517   [104]            CALL    FPBCDE          ; Move BCDE to FPREG
1576: C1       [114]            POP     BC              ; Restore number from stack
1577: D1       [124]            POP     DE
1578: FE19     [ 7]     NOSWAP: CP      24+1            ; Second number insignificant?
157A: D0       [12|18]          RET     NC              ; Yes - First number is result
157B: F5       [23]             PUSH    AF              ; Save number of bits to scale
157C: CD0A18   [40]             CALL    SIGNS           ; Set MSBs & sign of result
157F: 67       [44]             LD      H,A             ; Save sign of result
1580: F1       [54]             POP     AF              ; Restore scaling factor
1581: CD2316   [71]             CALL    SCALE           ; Scale BCDE to same exponent
1584: B4       [75]             OR      H               ; Result to be positive?
1585: 212921   [85]             LD      HL,FPREG        ; Point to FPREG
1588: F29E15   [95|95]          JP      P,MINCDE        ; No - Subtract FPREG from CDE
158B: CD0316   [112]            CALL    PLUCDE          ; Add FPREG to CDE
158E: D2E415   [122|122]        JP      NC,RONDUP       ; No overflow - Round it up
1591: 23       [128]            INC     HL              ; Point to exponent
1592: 34       [139]            INC     (HL)            ; Increment it
1593: CA0C05   [149|149]        JP      Z,OVERR         ; Number overflowed - Error
1596: 2E01     [156]            LD      L,1             ; 1 bit to shift right
1598: CD3916   [173]            CALL    SHRT1           ; Shift result right
159B: C3E415   [183]            JP      RONDUP          ; Round it up
                        
159E: AF       [ 4]     MINCDE: XOR     A               ; Clear A and carry
159F: 90       [ 8]             SUB     B               ; Negate exponent
15A0: 47       [12]             LD      B,A             ; Re-save exponent
15A1: 7E       [19]             LD      A,(HL)          ; Get LSB of FPREG
15A2: 9B       [23]             SBC     A, E            ; Subtract LSB of BCDE
15A3: 5F       [27]             LD      E,A             ; Save LSB of BCDE
15A4: 23       [33]             INC     HL
15A5: 7E       [40]             LD      A,(HL)          ; Get NMSB of FPREG
15A6: 9A       [44]             SBC     A,D             ; Subtract NMSB of BCDE
15A7: 57       [48]             LD      D,A             ; Save NMSB of BCDE
15A8: 23       [54]             INC     HL
15A9: 7E       [61]             LD      A,(HL)          ; Get MSB of FPREG
15AA: 99       [65]             SBC     A,C             ; Subtract MSB of BCDE
15AB: 4F       [69]             LD      C,A             ; Save MSB of BCDE
15AC: DC0F16   [10|17]  CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
                        
15AF: 68       [ 4]     BNORM:  LD      L,B             ; L = Exponent
15B0: 63       [ 8]             LD      H,E             ; H = LSB
15B1: AF       [12]             XOR     A
15B2: 47       [ 4]     BNRMLP: LD      B,A             ; Save bit count
15B3: 79       [ 8]             LD      A,C             ; Get MSB
15B4: B7       [12]             OR      A               ; Is it zero?
15B5: C2D115   [22|22]          JP      NZ,PNORM        ; No - Do it bit at a time
15B8: 4A       [26]             LD      C,D             ; MSB = NMSB
15B9: 54       [30]             LD      D,H             ; NMSB= LSB
15BA: 65       [34]             LD      H,L             ; LSB = VLSB
15BB: 6F       [38]             LD      L,A             ; VLSB= 0
15BC: 78       [42]             LD      A,B             ; Get exponent
15BD: D608     [49]             SUB     8               ; Count 8 bits
15BF: FEE0     [56]             CP      -24-8           ; Was number zero?
15C1: C2B215   [66|66]          JP      NZ,BNRMLP       ; No - Keep normalising
15C4: AF       [ 4]     RESZER: XOR     A               ; Result is zero
15C5: 322C21   [13]     SAVEXP: LD      (FPEXP),A       ; Save result as zero
15C8: C9       [23]             RET
                        
15C9: 05       [ 4]     NORMAL: DEC     B               ; Count bits
15CA: 29       [15]             ADD     HL,HL           ; Shift HL left
15CB: 7A       [19]             LD      A,D             ; Get NMSB
15CC: 17       [23]             RLA                     ; Shift left with last bit
15CD: 57       [27]             LD      D,A             ; Save NMSB
15CE: 79       [31]             LD      A,C             ; Get MSB
15CF: 8F       [35]             ADC     A,A             ; Shift left with last bit
15D0: 4F       [39]             LD      C,A             ; Save MSB
15D1: F2C915   [10|10]  PNORM:  JP      P,NORMAL        ; Not done - Keep going
15D4: 78       [14]             LD      A,B             ; Number of bits shifted
15D5: 5C       [18]             LD      E,H             ; Save HL in EB
15D6: 45       [22]             LD      B,L
15D7: B7       [26]             OR      A               ; Any shifting done?
15D8: CAE415   [36|36]          JP      Z,RONDUP        ; No - Round it up
15DB: 212C21   [46]             LD      HL,FPEXP        ; Point to exponent
15DE: 86       [53]             ADD     A,(HL)          ; Add shifted bits
15DF: 77       [60]             LD      (HL),A          ; Re-save exponent
15E0: D2C415   [70|70]          JP      NC,RESZER       ; Underflow - Result is zero
15E3: C8       [75|81]          RET     Z               ; Result is zero
15E4: 78       [ 4]     RONDUP: LD      A,B             ; Get VLSB of number
15E5: 212C21   [10]     RONDB:  LD      HL,FPEXP        ; Point to exponent
15E8: B7       [14]             OR      A               ; Any rounding?
15E9: FCF615   [24|31]          CALL    M,FPROND        ; Yes - Round number up
15EC: 46       [31]             LD      B,(HL)          ; B = Exponent
15ED: 23       [37]             INC     HL
15EE: 7E       [44]             LD      A,(HL)          ; Get sign of result
15EF: E680     [51]             AND     10000000B       ; Only bit 7 needed
15F1: A9       [55]             XOR     C               ; Set correct sign
15F2: 4F       [59]             LD      C,A             ; Save correct sign in number
15F3: C3E517   [69]             JP      FPBCDE          ; Move BCDE to FPREG
                        
15F6: 1C       [ 4]     FPROND: INC     E               ; Round LSB
15F7: C0       [ 9|15]          RET     NZ              ; Return if ok
15F8: 14       [13]             INC     D               ; Round NMSB
15F9: C0       [18|24]          RET     NZ              ; Return if ok
15FA: 0C       [22]             INC     C               ; Round MSB
15FB: C0       [27|33]          RET     NZ              ; Return if ok
15FC: 0E80     [34]             LD      C,80H           ; Set normal value
15FE: 34       [45]             INC     (HL)            ; Increment exponent
15FF: C0       [50|56]          RET     NZ              ; Return if ok
1600: C30C05   [60]             JP      OVERR           ; Overflow error
                        
1603: 7E       [ 7]     PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
1604: 83       [11]             ADD     A,E             ; Add LSB of BCDE
1605: 5F       [15]             LD      E,A             ; Save LSB of BCDE
1606: 23       [21]             INC     HL
1607: 7E       [28]             LD      A,(HL)          ; Get NMSB of FPREG
1608: 8A       [32]             ADC     A,D             ; Add NMSB of BCDE
1609: 57       [36]             LD      D,A             ; Save NMSB of BCDE
160A: 23       [42]             INC     HL
160B: 7E       [49]             LD      A,(HL)          ; Get MSB of FPREG
160C: 89       [53]             ADC     A,C             ; Add MSB of BCDE
160D: 4F       [57]             LD      C,A             ; Save MSB of BCDE
160E: C9       [67]             RET
                        
160F: 212D21   [10]     COMPL:  LD      HL,SGNRES       ; Sign of result
1612: 7E       [17]             LD      A,(HL)          ; Get sign of result
1613: 2F       [21]             CPL                     ; Negate it
1614: 77       [28]             LD      (HL),A          ; Put it back
1615: AF       [32]             XOR     A
1616: 6F       [36]             LD      L,A             ; Set L to zero
1617: 90       [40]             SUB     B               ; Negate exponent,set carry
1618: 47       [44]             LD      B,A             ; Re-save exponent
1619: 7D       [48]             LD      A,L             ; Load zero
161A: 9B       [52]             SBC     A,E             ; Negate LSB
161B: 5F       [56]             LD      E,A             ; Re-save LSB
161C: 7D       [60]             LD      A,L             ; Load zero
161D: 9A       [64]             SBC     A,D             ; Negate NMSB
161E: 57       [68]             LD      D,A             ; Re-save NMSB
161F: 7D       [72]             LD      A,L             ; Load zero
1620: 99       [76]             SBC     A,C             ; Negate MSB
1621: 4F       [80]             LD      C,A             ; Re-save MSB
1622: C9       [90]             RET
                        
1623: 0600     [ 7]     SCALE:  LD      B,0             ; Clear underflow
1625: D608     [ 7]     SCALLP: SUB     8               ; 8 bits (a whole byte)?
1627: DA3216   [17|17]          JP      C,SHRITE        ; No - Shift right A bits
162A: 43       [21]             LD      B,E             ; <- Shift
162B: 5A       [25]             LD      E,D             ; <- right
162C: 51       [29]             LD      D,C             ; <- eight
162D: 0E00     [36]             LD      C,0             ; <- bits
162F: C32516   [46]             JP      SCALLP          ; More bits to shift
                        
1632: C609     [ 7]     SHRITE: ADD     A,8+1           ; Adjust count
1634: 6F       [11]             LD      L,A             ; Save bits to shift
1635: AF       [ 4]     SHRLP:  XOR     A               ; Flag for all done
1636: 2D       [ 8]             DEC     L               ; All shifting done?
1637: C8       [13|19]          RET     Z               ; Yes - Return
1638: 79       [17]             LD      A,C             ; Get MSB
1639: 1F       [ 4]     SHRT1:  RRA                     ; Shift it right
163A: 4F       [ 8]             LD      C,A             ; Re-save
163B: 7A       [12]             LD      A,D             ; Get NMSB
163C: 1F       [16]             RRA                     ; Shift right with last bit
163D: 57       [20]             LD      D,A             ; Re-save it
163E: 7B       [24]             LD      A,E             ; Get LSB
163F: 1F       [28]             RRA                     ; Shift right with last bit
1640: 5F       [32]             LD      E,A             ; Re-save it
1641: 78       [36]             LD      A,B             ; Get underflow
1642: 1F       [40]             RRA                     ; Shift right with last bit
1643: 47       [44]             LD      B,A             ; Re-save underflow
1644: C33516   [54]             JP      SHRLP           ; More bits to do
                        
1647: 00000081          UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
                        
164B: 03                LOGTAB: .BYTE      3                       ; Table used by LOG
164C: AA561980                  .BYTE      0AAH,056H,019H,080H     ; 0.59898
1650: F1227680                  .BYTE      0F1H,022H,076H,080H     ; 0.96147
1654: 45AA3882                  .BYTE      045H,0AAH,038H,082H     ; 2.88539
                        
1658: CDA417   [17]     LOG:    CALL    TSTSGN          ; Test sign of value
165B: B7       [21]             OR      A
165C: EA1C0A   [31|31]          JP      PE,FCERR        ; ?FC Error if <= zero
165F: 212C21   [41]             LD      HL,FPEXP        ; Point to exponent
1662: 7E       [48]             LD      A,(HL)          ; Get exponent
1663: 013580   [58]             LD      BC,8035H        ; BCDE = SQR(1/2)
1666: 11F304   [68]             LD      DE,04F3H
1669: 90       [72]             SUB     B               ; Scale value to be < 1
166A: F5       [83]             PUSH    AF              ; Save scale factor
166B: 70       [90]             LD      (HL),B          ; Save new exponent
166C: D5       [101]            PUSH    DE              ; Save SQR(1/2)
166D: C5       [112]            PUSH    BC
166E: CD5E15   [129]            CALL    FPADD           ; Add SQR(1/2) to value
1671: C1       [139]            POP     BC              ; Restore SQR(1/2)
1672: D1       [149]            POP     DE
1673: 04       [153]            INC     B               ; Make it SQR(2)
1674: CDFA16   [170]            CALL    DVBCDE          ; Divide by SQR(2)
1677: 214716   [180]            LD      HL,UNITY        ; Point to 1.
167A: CD5515   [197]            CALL    SUBPHL          ; Subtract FPREG from 1
167D: 214B16   [207]            LD      HL,LOGTAB       ; Coefficient table
1680: CDEC1A   [224]            CALL    SUMSER          ; Evaluate sum of series
1683: 018080   [234]            LD      BC,8080H        ; BCDE = -0.5
1686: 110000   [244]            LD      DE,0000H
1689: CD5E15   [261]            CALL    FPADD           ; Subtract 0.5 from FPREG
168C: F1       [271]            POP     AF              ; Restore scale factor
168D: CD1F19   [288]            CALL    RSCALE          ; Re-scale number
1690: 013180   [10]     MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
1693: 111872   [20]             LD      DE,7218H
1696: 21                        .BYTE      21H             ; Skip "POP BC" and "POP DE"
                        
1697: C1       [10]     MULT:   POP     BC              ; Get number from stack
1698: D1       [20]             POP     DE
1699: CDA417   [17]     FPMULT: CALL    TSTSGN          ; Test sign of FPREG
169C: C8       [22|28]          RET     Z               ; Return zero if zero
169D: 2E00     [29]             LD      L,0             ; Flag add exponents
169F: CD6217   [46]             CALL    ADDEXP          ; Add exponents
16A2: 79       [50]             LD      A,C             ; Get MSB of multiplier
16A3: 323B21   [63]             LD      (MULVAL),A      ; Save MSB of multiplier
16A6: EB       [67]             EX      DE,HL
16A7: 223C21   [83]             LD      (MULVAL+1),HL   ; Save rest of multiplier
16AA: 010000   [93]             LD      BC,0            ; Partial product (BCDE) = zero
16AD: 50       [97]             LD      D,B
16AE: 58       [101]            LD      E,B
16AF: 21AF15   [111]            LD      HL,BNORM        ; Address of normalise
16B2: E5       [122]            PUSH    HL              ; Save for return
16B3: 21BB16   [132]            LD      HL,MULT8        ; Address of 8 bit multiply
16B6: E5       [143]            PUSH    HL              ; Save for NMSB,MSB
16B7: E5       [154]            PUSH    HL              ; 
16B8: 212921   [164]            LD      HL,FPREG        ; Point to number
16BB: 7E       [ 7]     MULT8:  LD      A,(HL)          ; Get LSB of number
16BC: 23       [13]             INC     HL              ; Point to NMSB
16BD: B7       [17]             OR      A               ; Test LSB
16BE: CAE716   [27|27]          JP      Z,BYTSFT        ; Zero - shift to next byte
16C1: E5       [38]             PUSH    HL              ; Save address of number
16C2: 2E08     [45]             LD      L,8             ; 8 bits to multiply by
16C4: 1F       [ 4]     MUL8LP: RRA                     ; Shift LSB right
16C5: 67       [ 8]             LD      H,A             ; Save LSB
16C6: 79       [12]             LD      A,C             ; Get MSB
16C7: D2D516   [22|22]          JP      NC,NOMADD       ; Bit was zero - Don't add
16CA: E5       [33]             PUSH    HL              ; Save LSB and count
16CB: 2A3C21   [49]             LD      HL,(MULVAL+1)   ; Get LSB and NMSB
16CE: 19       [60]             ADD     HL,DE           ; Add NMSB and LSB
16CF: EB       [64]             EX      DE,HL           ; Leave sum in DE
16D0: E1       [74]             POP     HL              ; Restore MSB and count
16D1: 3A3B21   [87]             LD      A,(MULVAL)      ; Get MSB of multiplier
16D4: 89       [91]             ADC     A,C             ; Add MSB
16D5: 1F       [ 4]     NOMADD: RRA                     ; Shift MSB right
16D6: 4F       [ 8]             LD      C,A             ; Re-save MSB
16D7: 7A       [12]             LD      A,D             ; Get NMSB
16D8: 1F       [16]             RRA                     ; Shift NMSB right
16D9: 57       [20]             LD      D,A             ; Re-save NMSB
16DA: 7B       [24]             LD      A,E             ; Get LSB
16DB: 1F       [28]             RRA                     ; Shift LSB right
16DC: 5F       [32]             LD      E,A             ; Re-save LSB
16DD: 78       [36]             LD      A,B             ; Get VLSB
16DE: 1F       [40]             RRA                     ; Shift VLSB right
16DF: 47       [44]             LD      B,A             ; Re-save VLSB
16E0: 2D       [48]             DEC     L               ; Count bits multiplied
16E1: 7C       [52]             LD      A,H             ; Get LSB of multiplier
16E2: C2C416   [62|62]          JP      NZ,MUL8LP       ; More - Do it
16E5: E1       [10]     POPHRT: POP     HL              ; Restore address of number
16E6: C9       [20]             RET
                        
16E7: 43       [ 4]     BYTSFT: LD      B,E             ; Shift partial product left
16E8: 5A       [ 8]             LD      E,D
16E9: 51       [12]             LD      D,C
16EA: 4F       [16]             LD      C,A
16EB: C9       [26]             RET
                        
16EC: CDD517   [17]     DIV10:  CALL    STAKFP          ; Save FPREG on stack
16EF: 012084   [27]             LD      BC,8420H        ; BCDE = 10.
16F2: 110000   [37]             LD      DE,0000H
16F5: CDE517   [54]             CALL    FPBCDE          ; Move 10 to FPREG
                        
16F8: C1       [10]     DIV:    POP     BC              ; Get number from stack
16F9: D1       [20]             POP     DE
16FA: CDA417   [17]     DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
16FD: CA0005   [27|27]          JP      Z,DZERR         ; Error if division by zero
1700: 2EFF     [34]             LD      L,-1            ; Flag subtract exponents
1702: CD6217   [51]             CALL    ADDEXP          ; Subtract exponents
1705: 34       [62]             INC     (HL)            ; Add 2 to exponent to adjust
1706: 34       [73]             INC     (HL)
1707: 2B       [79]             DEC     HL              ; Point to MSB
1708: 7E       [86]             LD      A,(HL)          ; Get MSB of dividend
1709: 325720   [99]             LD      (DIV3),A        ; Save for subtraction
170C: 2B       [105]            DEC     HL
170D: 7E       [112]            LD      A,(HL)          ; Get NMSB of dividend
170E: 325320   [125]            LD      (DIV2),A        ; Save for subtraction
1711: 2B       [131]            DEC     HL
1712: 7E       [138]            LD      A,(HL)          ; Get MSB of dividend
1713: 324F20   [151]            LD      (DIV1),A        ; Save for subtraction
1716: 41       [155]            LD      B,C             ; Get MSB
1717: EB       [159]            EX      DE,HL           ; NMSB,LSB to HL
1718: AF       [163]            XOR     A
1719: 4F       [167]            LD      C,A             ; Clear MSB of quotient
171A: 57       [171]            LD      D,A             ; Clear NMSB of quotient
171B: 5F       [175]            LD      E,A             ; Clear LSB of quotient
171C: 325A20   [188]            LD      (DIV4),A        ; Clear overflow count
171F: E5       [11]     DIVLP:  PUSH    HL              ; Save divisor
1720: C5       [22]             PUSH    BC
1721: 7D       [26]             LD      A,L             ; Get LSB of number
1722: CD4E20   [43]             CALL    DIVSUP          ; Subt' divisor from dividend
1725: DE00     [50]             SBC     A,0             ; Count for overflows
1727: 3F       [54]             CCF
1728: D23217   [64|64]          JP      NC,RESDIV       ; Restore divisor if borrow
172B: 325A20   [77]             LD      (DIV4),A        ; Re-save overflow count
172E: F1       [87]             POP     AF              ; Scrap divisor
172F: F1       [97]             POP     AF
1730: 37       [101]            SCF                     ; Set carry to
1731: D2                        .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
                        
1732: C1       [10]     RESDIV: POP     BC              ; Restore divisor
1733: E1       [20]             POP     HL
1734: 79       [24]             LD      A,C             ; Get MSB of quotient
1735: 3C       [28]             INC     A
1736: 3D       [32]             DEC     A
1737: 1F       [36]             RRA                     ; Bit 0 to bit 7
1738: FAE515   [46|46]          JP      M,RONDB         ; Done - Normalise result
173B: 17       [50]             RLA                     ; Restore carry
173C: 7B       [54]             LD      A,E             ; Get LSB of quotient
173D: 17       [58]             RLA                     ; Double it
173E: 5F       [62]             LD      E,A             ; Put it back
173F: 7A       [66]             LD      A,D             ; Get NMSB of quotient
1740: 17       [70]             RLA                     ; Double it
1741: 57       [74]             LD      D,A             ; Put it back
1742: 79       [78]             LD      A,C             ; Get MSB of quotient
1743: 17       [82]             RLA                     ; Double it
1744: 4F       [86]             LD      C,A             ; Put it back
1745: 29       [97]             ADD     HL,HL           ; Double NMSB,LSB of divisor
1746: 78       [101]            LD      A,B             ; Get MSB of divisor
1747: 17       [105]            RLA                     ; Double it
1748: 47       [109]            LD      B,A             ; Put it back
1749: 3A5A20   [122]            LD      A,(DIV4)        ; Get VLSB of quotient
174C: 17       [126]            RLA                     ; Double it
174D: 325A20   [139]            LD      (DIV4),A        ; Put it back
1750: 79       [143]            LD      A,C             ; Get MSB of quotient
1751: B2       [147]            OR      D               ; Merge NMSB
1752: B3       [151]            OR      E               ; Merge LSB
1753: C21F17   [161|161]        JP      NZ,DIVLP        ; Not done - Keep dividing
1756: E5       [172]            PUSH    HL              ; Save divisor
1757: 212C21   [182]            LD      HL,FPEXP        ; Point to exponent
175A: 35       [193]            DEC     (HL)            ; Divide by 2
175B: E1       [203]            POP     HL              ; Restore divisor
175C: C21F17   [213|213]        JP      NZ,DIVLP        ; Ok - Keep going
175F: C30C05   [223]            JP      OVERR           ; Overflow error
                        
1762: 78       [ 4]     ADDEXP: LD      A,B             ; Get exponent of dividend
1763: B7       [ 8]             OR      A               ; Test it
1764: CA8617   [18|18]          JP      Z,OVTST3        ; Zero - Result zero
1767: 7D       [22]             LD      A,L             ; Get add/subtract flag
1768: 212C21   [32]             LD      HL,FPEXP        ; Point to exponent
176B: AE       [39]             XOR     (HL)            ; Add or subtract it
176C: 80       [43]             ADD     A,B             ; Add the other exponent
176D: 47       [47]             LD      B,A             ; Save new exponent
176E: 1F       [51]             RRA                     ; Test exponent for overflow
176F: A8       [55]             XOR     B
1770: 78       [59]             LD      A,B             ; Get exponent
1771: F28517   [69|69]          JP      P,OVTST2        ; Positive - Test for overflow
1774: C680     [76]             ADD     A,80H           ; Add excess 128
1776: 77       [83]             LD      (HL),A          ; Save new exponent
1777: CAE516   [93|93]          JP      Z,POPHRT        ; Zero - Result zero
177A: CD0A18   [110]            CALL    SIGNS           ; Set MSBs and sign of result
177D: 77       [117]            LD      (HL),A          ; Save new exponent
177E: 2B       [123]            DEC     HL              ; Point to MSB
177F: C9       [133]            RET
                        
1780: CDA417   [17]     OVTST1: CALL    TSTSGN          ; Test sign of FPREG
1783: 2F       [21]             CPL                     ; Invert sign
1784: E1       [31]             POP     HL              ; Clean up stack
1785: B7       [ 4]     OVTST2: OR      A               ; Test if new exponent zero
1786: E1       [10]     OVTST3: POP     HL              ; Clear off return address
1787: F2C415   [20|20]          JP      P,RESZER        ; Result zero
178A: C30C05   [30]             JP      OVERR           ; Overflow error
                        
178D: CDF017   [17]     MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
1790: 78       [21]             LD      A,B             ; Get exponent
1791: B7       [25]             OR      A               ; Is it zero?
1792: C8       [30|36]          RET     Z               ; Yes - Result is zero
1793: C602     [37]             ADD     A,2             ; Multiply by 4
1795: DA0C05   [47|47]          JP      C,OVERR         ; Overflow - ?OV Error
1798: 47       [51]             LD      B,A             ; Re-save exponent
1799: CD5E15   [68]             CALL    FPADD           ; Add BCDE to FPREG (Times 5)
179C: 212C21   [78]             LD      HL,FPEXP        ; Point to exponent
179F: 34       [89]             INC     (HL)            ; Double number (Times 10)
17A0: C0       [94|100]         RET     NZ              ; Ok - Return
17A1: C30C05   [104]            JP      OVERR           ; Overflow error
                        
17A4: 3A2C21   [13]     TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
17A7: B7       [17]             OR      A
17A8: C8       [22|28]          RET     Z               ; RETurn if number is zero
17A9: 3A2B21   [35]             LD      A,(FPREG+2)     ; Get MSB of FPREG
17AC: FE                        .BYTE      0FEH            ; Test sign
17AD: 2F       [ 4]     RETREL: CPL                     ; Invert sign
17AE: 17       [ 8]             RLA                     ; Sign bit to carry
17AF: 9F       [ 4]     FLGDIF: SBC     A,A             ; Carry to all bits of A
17B0: C0       [ 9|15]          RET     NZ              ; Return -1 if negative
17B1: 3C       [13]             INC     A               ; Bump to +1
17B2: C9       [23]             RET                     ; Positive - Return +1
                        
17B3: CDA417   [17]     SGN:    CALL    TSTSGN          ; Test sign of FPREG
17B6: 0688     [ 7]     FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
17B8: 110000   [17]             LD      DE,0            ; Zero NMSB and LSB
17BB: 212C21   [10]     RETINT: LD      HL,FPEXP        ; Point to exponent
17BE: 4F       [14]             LD      C,A             ; CDE = MSB,NMSB and LSB
17BF: 70       [21]             LD      (HL),B          ; Save exponent
17C0: 0600     [28]             LD      B,0             ; CDE = integer to normalise
17C2: 23       [34]             INC     HL              ; Point to sign of result
17C3: 3680     [44]             LD      (HL),80H        ; Set sign of result
17C5: 17       [48]             RLA                     ; Carry = sign of integer
17C6: C3AC15   [58]             JP      CONPOS          ; Set sign of result
                        
17C9: CDA417   [17]     ABS:    CALL    TSTSGN          ; Test sign of FPREG
17CC: F0       [22|28]          RET     P               ; Return if positive
17CD: 212B21   [10]     INVSGN: LD      HL,FPREG+2      ; Point to MSB
17D0: 7E       [17]             LD      A,(HL)          ; Get sign of mantissa
17D1: EE80     [24]             XOR     80H             ; Invert sign of mantissa
17D3: 77       [31]             LD      (HL),A          ; Re-save sign of mantissa
17D4: C9       [41]             RET
                        
17D5: EB       [ 4]     STAKFP: EX      DE,HL           ; Save code string address
17D6: 2A2921   [20]             LD      HL,(FPREG)      ; LSB,NLSB of FPREG
17D9: E3       [39]             EX      (SP),HL         ; Stack them,get return
17DA: E5       [50]             PUSH    HL              ; Re-save return
17DB: 2A2B21   [66]             LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
17DE: E3       [85]             EX      (SP),HL         ; Stack them,get return
17DF: E5       [96]             PUSH    HL              ; Re-save return
17E0: EB       [100]            EX      DE,HL           ; Restore code string address
17E1: C9       [110]            RET
                        
17E2: CDF317   [17]     PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
17E5: EB       [ 4]     FPBCDE: EX      DE,HL           ; Save code string address
17E6: 222921   [20]             LD      (FPREG),HL      ; Save LSB,NLSB of number
17E9: 60       [24]             LD      H,B             ; Exponent of number
17EA: 69       [28]             LD      L,C             ; MSB of number
17EB: 222B21   [44]             LD      (FPREG+2),HL    ; Save MSB and exponent
17EE: EB       [48]             EX      DE,HL           ; Restore code string address
17EF: C9       [58]             RET
                        
17F0: 212921   [10]     BCDEFP: LD      HL,FPREG        ; Point to FPREG
17F3: 5E       [ 7]     LOADFP: LD      E,(HL)          ; Get LSB of number
17F4: 23       [13]             INC     HL
17F5: 56       [20]             LD      D,(HL)          ; Get NMSB of number
17F6: 23       [26]             INC     HL
17F7: 4E       [33]             LD      C,(HL)          ; Get MSB of number
17F8: 23       [39]             INC     HL
17F9: 46       [46]             LD      B,(HL)          ; Get exponent of number
17FA: 23       [ 6]     INCHL:  INC     HL              ; Used for conditional "INC HL"
17FB: C9       [16]             RET
                        
17FC: 112921   [10]     FPTHL:  LD      DE,FPREG        ; Point to FPREG
17FF: 0604     [ 7]     DETHL4: LD      B,4             ; 4 bytes to move
1801: 1A       [ 7]     DETHLB: LD      A,(DE)          ; Get source
1802: 77       [14]             LD      (HL),A          ; Save destination
1803: 13       [20]             INC     DE              ; Next source
1804: 23       [26]             INC     HL              ; Next destination
1805: 05       [30]             DEC     B               ; Count bytes
1806: C20118   [40|40]          JP      NZ,DETHLB       ; Loop if more
1809: C9       [50]             RET
                        
180A: 212B21   [10]     SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
180D: 7E       [17]             LD      A,(HL)          ; Get MSB
180E: 07       [21]             RLCA                    ; Old sign to carry
180F: 37       [25]             SCF                     ; Set MSBit
1810: 1F       [29]             RRA                     ; Set MSBit of MSB
1811: 77       [36]             LD      (HL),A          ; Save new MSB
1812: 3F       [40]             CCF                     ; Complement sign
1813: 1F       [44]             RRA                     ; Old sign to carry
1814: 23       [50]             INC     HL
1815: 23       [56]             INC     HL
1816: 77       [63]             LD      (HL),A          ; Set sign of result
1817: 79       [67]             LD      A,C             ; Get MSB
1818: 07       [71]             RLCA                    ; Old sign to carry
1819: 37       [75]             SCF                     ; Set MSBit
181A: 1F       [79]             RRA                     ; Set MSBit of MSB
181B: 4F       [83]             LD      C,A             ; Save MSB
181C: 1F       [87]             RRA
181D: AE       [94]             XOR     (HL)            ; New sign of result
181E: C9       [104]            RET
                        
181F: 78       [ 4]     CMPNUM: LD      A,B             ; Get exponent of number
1820: B7       [ 8]             OR      A
1821: CAA417   [18|18]          JP      Z,TSTSGN        ; Zero - Test sign of FPREG
1824: 21AD17   [28]             LD      HL,RETREL       ; Return relation routine
1827: E5       [39]             PUSH    HL              ; Save for return
1828: CDA417   [56]             CALL    TSTSGN          ; Test sign of FPREG
182B: 79       [60]             LD      A,C             ; Get MSB of number
182C: C8       [65|71]          RET     Z               ; FPREG zero - Number's MSB
182D: 212B21   [75]             LD      HL,FPREG+2      ; MSB of FPREG
1830: AE       [82]             XOR     (HL)            ; Combine signs
1831: 79       [86]             LD      A,C             ; Get MSB of number
1832: F8       [91|97]          RET     M               ; Exit if signs different
1833: CD3918   [108]            CALL    CMPFP           ; Compare FP numbers
1836: 1F       [112]            RRA                     ; Get carry to sign
1837: A9       [116]            XOR     C               ; Combine with MSB of number
1838: C9       [126]            RET
                        
1839: 23       [ 6]     CMPFP:  INC     HL              ; Point to exponent
183A: 78       [10]             LD      A,B             ; Get exponent
183B: BE       [17]             CP      (HL)            ; Compare exponents
183C: C0       [22|28]          RET     NZ              ; Different
183D: 2B       [28]             DEC     HL              ; Point to MBS
183E: 79       [32]             LD      A,C             ; Get MSB
183F: BE       [39]             CP      (HL)            ; Compare MSBs
1840: C0       [44|50]          RET     NZ              ; Different
1841: 2B       [50]             DEC     HL              ; Point to NMSB
1842: 7A       [54]             LD      A,D             ; Get NMSB
1843: BE       [61]             CP      (HL)            ; Compare NMSBs
1844: C0       [66|72]          RET     NZ              ; Different
1845: 2B       [72]             DEC     HL              ; Point to LSB
1846: 7B       [76]             LD      A,E             ; Get LSB
1847: 96       [83]             SUB     (HL)            ; Compare LSBs
1848: C0       [88|94]          RET     NZ              ; Different
1849: E1       [98]             POP     HL              ; Drop RETurn
184A: E1       [108]            POP     HL              ; Drop another RETurn
184B: C9       [118]            RET
                        
184C: 47       [ 4]     FPINT:  LD      B,A             ; <- Move
184D: 4F       [ 8]             LD      C,A             ; <- exponent
184E: 57       [12]             LD      D,A             ; <- to all
184F: 5F       [16]             LD      E,A             ; <- bits
1850: B7       [20]             OR      A               ; Test exponent
1851: C8       [25|31]          RET     Z               ; Zero - Return zero
1852: E5       [36]             PUSH    HL              ; Save pointer to number
1853: CDF017   [53]             CALL    BCDEFP          ; Move FPREG to BCDE
1856: CD0A18   [70]             CALL    SIGNS           ; Set MSBs & sign of result
1859: AE       [77]             XOR     (HL)            ; Combine with sign of FPREG
185A: 67       [81]             LD      H,A             ; Save combined signs
185B: FC7018   [91|98]          CALL    M,DCBCDE        ; Negative - Decrement BCDE
185E: 3E98     [98]             LD      A,80H+24        ; 24 bits
1860: 90       [102]            SUB     B               ; Bits to shift
1861: CD2316   [119]            CALL    SCALE           ; Shift BCDE
1864: 7C       [123]            LD      A,H             ; Get combined sign
1865: 17       [127]            RLA                     ; Sign to carry
1866: DCF615   [137|144]        CALL    C,FPROND        ; Negative - Round number up
1869: 0600     [144]            LD      B,0             ; Zero exponent
186B: DC0F16   [154|161]        CALL    C,COMPL         ; If negative make positive
186E: E1       [164]            POP     HL              ; Restore pointer to number
186F: C9       [174]            RET
                        
1870: 1B       [ 6]     DCBCDE: DEC     DE              ; Decrement BCDE
1871: 7A       [10]             LD      A,D             ; Test LSBs
1872: A3       [14]             AND     E
1873: 3C       [18]             INC     A
1874: C0       [23|29]          RET     NZ              ; Exit if LSBs not FFFF
1875: 0B       [29]             DEC     BC              ; Decrement MSBs
1876: C9       [39]             RET
                        
1877: 212C21   [10]     INT:    LD      HL,FPEXP        ; Point to exponent
187A: 7E       [17]             LD      A,(HL)          ; Get exponent
187B: FE98     [24]             CP      80H+24          ; Integer accuracy only?
187D: 3A2921   [37]             LD      A,(FPREG)       ; Get LSB
1880: D0       [42|48]          RET     NC              ; Yes - Already integer
1881: 7E       [49]             LD      A,(HL)          ; Get exponent
1882: CD4C18   [66]             CALL    FPINT           ; F.P to integer
1885: 3698     [76]             LD      (HL),80H+24     ; Save 24 bit integer
1887: 7B       [80]             LD      A,E             ; Get LSB of number
1888: F5       [91]             PUSH    AF              ; Save LSB
1889: 79       [95]             LD      A,C             ; Get MSB of number
188A: 17       [99]             RLA                     ; Sign to carry
188B: CDAC15   [116]            CALL    CONPOS          ; Set sign of result
188E: F1       [126]            POP     AF              ; Restore LSB of number
188F: C9       [136]            RET
                        
1890: 210000   [10]     MLDEBC: LD      HL,0            ; Clear partial product
1893: 78       [14]             LD      A,B             ; Test multiplier
1894: B1       [18]             OR      C
1895: C8       [23|29]          RET     Z               ; Return zero if zero
1896: 3E10     [30]             LD      A,16            ; 16 bits
1898: 29       [11]     MLDBLP: ADD     HL,HL           ; Shift P.P left
1899: DAD010   [21|21]          JP      C,BSERR         ; ?BS Error if overflow
189C: EB       [25]             EX      DE,HL
189D: 29       [36]             ADD     HL,HL           ; Shift multiplier left
189E: EB       [40]             EX      DE,HL
189F: D2A618   [50|50]          JP      NC,NOMLAD       ; Bit was zero - No add
18A2: 09       [61]             ADD     HL,BC           ; Add multiplicand
18A3: DAD010   [71|71]          JP      C,BSERR         ; ?BS Error if overflow
18A6: 3D       [ 4]     NOMLAD: DEC     A               ; Count bits
18A7: C29818   [14|14]          JP      NZ,MLDBLP       ; More
18AA: C9       [24]             RET
                        
18AB: FE2D     [ 7]     ASCTFP: CP      '-'             ; Negative?
18AD: F5       [18]             PUSH    AF              ; Save it and flags
18AE: CAB718   [28|28]          JP      Z,CNVNUM        ; Yes - Convert number
18B1: FE2B     [35]             CP      '+'             ; Positive?
18B3: CAB718   [45|45]          JP      Z,CNVNUM        ; Yes - Convert number
18B6: 2B       [51]             DEC     HL              ; DEC 'cos GETCHR INCs
18B7: CDC415   [17]     CNVNUM: CALL    RESZER          ; Set result to zero
18BA: 47       [21]             LD      B,A             ; Digits after point counter
18BB: 57       [25]             LD      D,A             ; Sign of exponent
18BC: 5F       [29]             LD      E,A             ; Exponent of ten
18BD: 2F       [33]             CPL
18BE: 4F       [37]             LD      C,A             ; Before or after point flag
18BF: CD5509   [17]     MANLP:  CALL    GETCHR          ; Get next character
18C2: DA0819   [27|27]          JP      C,ADDIG         ; Digit - Add to number
18C5: FE2E     [34]             CP      '.'
18C7: CAE318   [44|44]          JP      Z,DPOINT        ; '.' - Flag point
18CA: FE45     [51]             CP      'E'
18CC: C2E718   [61|61]          JP      NZ,CONEXP       ; Not 'E' - Scale number
18CF: CD5509   [78]             CALL    GETCHR          ; Get next character
18D2: CDFB0E   [95]             CALL    SGNEXP          ; Get sign of exponent
18D5: CD5509   [17]     EXPLP:  CALL    GETCHR          ; Get next character
18D8: DA2A19   [27|27]          JP      C,EDIGIT        ; Digit - Add to exponent
18DB: 14       [31]             INC     D               ; Is sign negative?
18DC: C2E718   [41|41]          JP      NZ,CONEXP       ; No - Scale number
18DF: AF       [45]             XOR     A
18E0: 93       [49]             SUB     E               ; Negate exponent
18E1: 5F       [53]             LD      E,A             ; And re-save it
18E2: 0C       [57]             INC     C               ; Flag end of number
18E3: 0C       [ 4]     DPOINT: INC     C               ; Flag point passed
18E4: CABF18   [14|14]          JP      Z,MANLP         ; Zero - Get another digit
18E7: E5       [11]     CONEXP: PUSH    HL              ; Save code string address
18E8: 7B       [15]             LD      A,E             ; Get exponent
18E9: 90       [19]             SUB     B               ; Subtract digits after point
18EA: F40019   [10|17]  SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
18ED: F2F618   [20|20]          JP      P,ENDCON        ; Positive - All done
18F0: F5       [31]             PUSH    AF              ; Save number of times to /10
18F1: CDEC16   [48]             CALL    DIV10           ; Divide by 10
18F4: F1       [58]             POP     AF              ; Restore count
18F5: 3C       [62]             INC     A               ; Count divides
                        
18F6: C2EA18   [10|10]  ENDCON: JP      NZ,SCALMI       ; More to do
18F9: D1       [20]             POP     DE              ; Restore code string address
18FA: F1       [30]             POP     AF              ; Restore sign of number
18FB: CCCD17   [40|47]          CALL    Z,INVSGN        ; Negative - Negate number
18FE: EB       [44]             EX      DE,HL           ; Code string address to HL
18FF: C9       [54]             RET
                        
1900: C8       [ 5|11]  SCALPL: RET     Z               ; Exit if no scaling needed
1901: F5       [11]     MULTEN: PUSH    AF              ; Save count
1902: CD8D17   [28]             CALL    MLSP10          ; Multiply number by 10
1905: F1       [38]             POP     AF              ; Restore count
1906: 3D       [42]             DEC     A               ; Count multiplies
1907: C9       [52]             RET
                        
1908: D5       [11]     ADDIG:  PUSH    DE              ; Save sign of exponent
1909: 57       [15]             LD      D,A             ; Save digit
190A: 78       [19]             LD      A,B             ; Get digits after point
190B: 89       [23]             ADC     A,C             ; Add one if after point
190C: 47       [27]             LD      B,A             ; Re-save counter
190D: C5       [38]             PUSH    BC              ; Save point flags
190E: E5       [49]             PUSH    HL              ; Save code string address
190F: D5       [60]             PUSH    DE              ; Save digit
1910: CD8D17   [77]             CALL    MLSP10          ; Multiply number by 10
1913: F1       [87]             POP     AF              ; Restore digit
1914: D630     [94]             SUB     '0'             ; Make it absolute
1916: CD1F19   [111]            CALL    RSCALE          ; Re-scale number
1919: E1       [121]            POP     HL              ; Restore code string address
191A: C1       [131]            POP     BC              ; Restore point flags
191B: D1       [141]            POP     DE              ; Restore sign of exponent
191C: C3BF18   [151]            JP      MANLP           ; Get another digit
                        
191F: CDD517   [17]     RSCALE: CALL    STAKFP          ; Put number on stack
1922: CDB617   [34]             CALL    FLGREL          ; Digit to add to FPREG
1925: C1       [10]     PADD:   POP     BC              ; Restore number
1926: D1       [20]             POP     DE
1927: C35E15   [30]             JP      FPADD           ; Add BCDE to FPREG and return
                        
192A: 7B       [ 4]     EDIGIT: LD      A,E             ; Get digit
192B: 07       [ 8]             RLCA                    ; Times 2
192C: 07       [12]             RLCA                    ; Times 4
192D: 83       [16]             ADD     A,E             ; Times 5
192E: 07       [20]             RLCA                    ; Times 10
192F: 86       [27]             ADD     A,(HL)          ; Add next digit
1930: D630     [34]             SUB     '0'             ; Make it absolute
1932: 5F       [38]             LD      E,A             ; Save new digit
1933: C3D518   [48]             JP      EXPLP           ; Look for another digit
                        
1936: E5       [11]     LINEIN: PUSH    HL              ; Save code string address
1937: 219504   [21]             LD      HL,INMSG        ; Output " in "
193A: CD9B12   [38]             CALL    PRS             ; Output string at HL
193D: E1       [48]             POP     HL              ; Restore code string address
193E: EB       [ 4]     PRNTHL: EX      DE,HL           ; Code string address to DE
193F: AF       [ 8]             XOR     A
1940: 0698     [15]             LD      B,80H+24        ; 24 bits
1942: CDBB17   [32]             CALL    RETINT          ; Return the integer
1945: 219A12   [42]             LD      HL,PRNUMS       ; Print number string
1948: E5       [53]             PUSH    HL              ; Save for return
1949: 212E21   [10]     NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
194C: E5       [21]             PUSH    HL              ; Save for return
194D: CDA417   [38]             CALL    TSTSGN          ; Test sign of FPREG
1950: 3620     [48]             LD      (HL),' '        ; Space at start
1952: F25719   [58|58]          JP      P,SPCFST        ; Positive - Space to start
1955: 362D     [68]             LD      (HL),'-'        ; '-' sign at start
1957: 23       [ 6]     SPCFST: INC     HL              ; First byte of number
1958: 3630     [16]             LD      (HL),'0'        ; '0' if zero
195A: CA0D1A   [26|26]          JP      Z,JSTZER        ; Return '0' if zero
195D: E5       [37]             PUSH    HL              ; Save buffer address
195E: FCCD17   [47|54]          CALL    M,INVSGN        ; Negate FPREG if negative
1961: AF       [51]             XOR     A               ; Zero A
1962: F5       [62]             PUSH    AF              ; Save it
1963: CD131A   [79]             CALL    RNGTST          ; Test number is in range
1966: 014391   [10]     SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
1969: 11F84F   [20]             LD      DE,4FF8H
196C: CD1F18   [37]             CALL    CMPNUM          ; Compare numbers
196F: B7       [41]             OR      A
1970: E28419   [51|51]          JP      PO,INRNG        ; > 99999.9 - Sort it out
1973: F1       [61]             POP     AF              ; Restore count
1974: CD0119   [78]             CALL    MULTEN          ; Multiply by ten
1977: F5       [89]             PUSH    AF              ; Re-save count
1978: C36619   [99]             JP      SIXDIG          ; Test it again
                        
197B: CDEC16   [17]     GTSIXD: CALL    DIV10           ; Divide by 10
197E: F1       [27]             POP     AF              ; Get count
197F: 3C       [31]             INC     A               ; Count divides
1980: F5       [42]             PUSH    AF              ; Re-save count
1981: CD131A   [59]             CALL    RNGTST          ; Test number is in range
1984: CD4C15   [17]     INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
1987: 3C       [21]             INC     A
1988: CD4C18   [38]             CALL    FPINT           ; F.P to integer
198B: CDE517   [55]             CALL    FPBCDE          ; Move BCDE to FPREG
198E: 010603   [65]             LD      BC,0306H        ; 1E+06 to 1E-03 range
1991: F1       [75]             POP     AF              ; Restore count
1992: 81       [79]             ADD     A,C             ; 6 digits before point
1993: 3C       [83]             INC     A               ; Add one
1994: FAA019   [93|93]          JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
1997: FE08     [100]            CP      6+1+1           ; More than 999999 ?
1999: D2A019   [110|110]        JP      NC,MAKNUM       ; Yes - Do it in 'E' form
199C: 3C       [114]            INC     A               ; Adjust for exponent
199D: 47       [118]            LD      B,A             ; Exponent of number
199E: 3E02     [125]            LD      A,2             ; Make it zero after
                        
19A0: 3D       [ 4]     MAKNUM: DEC     A               ; Adjust for digits to do
19A1: 3D       [ 8]             DEC     A
19A2: E1       [18]             POP     HL              ; Restore buffer address
19A3: F5       [29]             PUSH    AF              ; Save count
19A4: 11261A   [39]             LD      DE,POWERS       ; Powers of ten
19A7: 05       [43]             DEC     B               ; Count digits before point
19A8: C2B119   [53|53]          JP      NZ,DIGTXT       ; Not zero - Do number
19AB: 362E     [63]             LD      (HL),'.'        ; Save point
19AD: 23       [69]             INC     HL              ; Move on
19AE: 3630     [79]             LD      (HL),'0'        ; Save zero
19B0: 23       [85]             INC     HL              ; Move on
19B1: 05       [ 4]     DIGTXT: DEC     B               ; Count digits before point
19B2: 362E     [14]             LD      (HL),'.'        ; Save point in case
19B4: CCFA17   [24|31]          CALL    Z,INCHL         ; Last digit - move on
19B7: C5       [35]             PUSH    BC              ; Save digits before point
19B8: E5       [46]             PUSH    HL              ; Save buffer address
19B9: D5       [57]             PUSH    DE              ; Save powers of ten
19BA: CDF017   [74]             CALL    BCDEFP          ; Move FPREG to BCDE
19BD: E1       [84]             POP     HL              ; Powers of ten table
19BE: 062F     [91]             LD      B, '0'-1        ; ASCII '0' - 1
19C0: 04       [ 4]     TRYAGN: INC     B               ; Count subtractions
19C1: 7B       [ 8]             LD      A,E             ; Get LSB
19C2: 96       [15]             SUB     (HL)            ; Subtract LSB
19C3: 5F       [19]             LD      E,A             ; Save LSB
19C4: 23       [25]             INC     HL
19C5: 7A       [29]             LD      A,D             ; Get NMSB
19C6: 9E       [36]             SBC     A,(HL)          ; Subtract NMSB
19C7: 57       [40]             LD      D,A             ; Save NMSB
19C8: 23       [46]             INC     HL
19C9: 79       [50]             LD      A,C             ; Get MSB
19CA: 9E       [57]             SBC     A,(HL)          ; Subtract MSB
19CB: 4F       [61]             LD      C,A             ; Save MSB
19CC: 2B       [67]             DEC     HL              ; Point back to start
19CD: 2B       [73]             DEC     HL
19CE: D2C019   [83|83]          JP      NC,TRYAGN       ; No overflow - Try again
19D1: CD0316   [100]            CALL    PLUCDE          ; Restore number
19D4: 23       [106]            INC     HL              ; Start of next number
19D5: CDE517   [123]            CALL    FPBCDE          ; Move BCDE to FPREG
19D8: EB       [127]            EX      DE,HL           ; Save point in table
19D9: E1       [137]            POP     HL              ; Restore buffer address
19DA: 70       [144]            LD      (HL),B          ; Save digit in buffer
19DB: 23       [150]            INC     HL              ; And move on
19DC: C1       [160]            POP     BC              ; Restore digit count
19DD: 0D       [164]            DEC     C               ; Count digits
19DE: C2B119   [174|174]        JP      NZ,DIGTXT       ; More - Do them
19E1: 05       [178]            DEC     B               ; Any decimal part?
19E2: CAF119   [188|188]        JP      Z,DOEBIT        ; No - Do 'E' bit
19E5: 2B       [ 6]     SUPTLZ: DEC     HL              ; Move back through buffer
19E6: 7E       [13]             LD      A,(HL)          ; Get character
19E7: FE30     [20]             CP      '0'             ; '0' character?
19E9: CAE519   [30|30]          JP      Z,SUPTLZ        ; Yes - Look back for more
19EC: FE2E     [37]             CP      '.'             ; A decimal point?
19EE: C4FA17   [47|54]          CALL    NZ,INCHL        ; Move back over digit
                        
19F1: F1       [10]     DOEBIT: POP     AF              ; Get 'E' flag
19F2: CA101A   [20|20]          JP      Z,NOENED        ; No 'E' needed - End buffer
19F5: 3645     [30]             LD      (HL),'E'        ; Put 'E' in buffer
19F7: 23       [36]             INC     HL              ; And move on
19F8: 362B     [46]             LD      (HL),'+'        ; Put '+' in buffer
19FA: F2011A   [56|56]          JP      P,OUTEXP        ; Positive - Output exponent
19FD: 362D     [66]             LD      (HL),'-'        ; Put '-' in buffer
19FF: 2F       [70]             CPL                     ; Negate exponent
1A00: 3C       [74]             INC     A
1A01: 062F     [ 7]     OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
1A03: 04       [ 4]     EXPTEN: INC     B               ; Count subtractions
1A04: D60A     [11]             SUB     10              ; Tens digit
1A06: D2031A   [21|21]          JP      NC,EXPTEN       ; More to do
1A09: C63A     [28]             ADD     A,'0'+10        ; Restore and make ASCII
1A0B: 23       [34]             INC     HL              ; Move on
1A0C: 70       [41]             LD      (HL),B          ; Save MSB of exponent
1A0D: 23       [ 6]     JSTZER: INC     HL              ;
1A0E: 77       [13]             LD      (HL),A          ; Save LSB of exponent
1A0F: 23       [19]             INC     HL
1A10: 71       [ 7]     NOENED: LD      (HL),C          ; Mark end of buffer
1A11: E1       [17]             POP     HL              ; Restore code string address
1A12: C9       [27]             RET
                        
1A13: 017494   [10]     RNGTST: LD      BC,9474H        ; BCDE = 999999.
1A16: 11F723   [20]             LD      DE,23F7H
1A19: CD1F18   [37]             CALL    CMPNUM          ; Compare numbers
1A1C: B7       [41]             OR      A
1A1D: E1       [51]             POP     HL              ; Return address to HL
1A1E: E27B19   [61|61]          JP      PO,GTSIXD       ; Too big - Divide by ten
1A21: E9       [65]             JP      (HL)            ; Otherwise return to caller
                        
1A22: 00000080          HALF:   .BYTE      00H,00H,00H,80H ; 0.5
                        
1A26: A08601            POWERS: .BYTE      0A0H,086H,001H  ; 100000
1A29: 102700                    .BYTE      010H,027H,000H  ;  10000
1A2C: E80300                    .BYTE      0E8H,003H,000H  ;   1000
1A2F: 640000                    .BYTE      064H,000H,000H  ;    100
1A32: 0A0000                    .BYTE      00AH,000H,000H  ;     10
1A35: 010000                    .BYTE      001H,000H,000H  ;      1
                        
1A38: 21CD17   [10]     NEGAFT: LD  HL,INVSGN           ; Negate result
1A3B: E3       [29]             EX      (SP),HL         ; To be done after caller
1A3C: E9       [33]             JP      (HL)            ; Return to caller
                        
1A3D: CDD517   [17]     SQR:    CALL    STAKFP          ; Put value on stack
1A40: 21221A   [27]             LD      HL,HALF         ; Set power to 1/2
1A43: CDE217   [44]             CALL    PHLTFP          ; Move 1/2 to FPREG
                        
1A46: C1       [10]     POWER:  POP     BC              ; Get base
1A47: D1       [20]             POP     DE
1A48: CDA417   [37]             CALL    TSTSGN          ; Test sign of power
1A4B: 78       [41]             LD      A,B             ; Get exponent of base
1A4C: CA8B1A   [51|51]          JP      Z,EXP           ; Make result 1 if zero
1A4F: F2561A   [61|61]          JP      P,POWER1        ; Positive base - Ok
1A52: B7       [65]             OR      A               ; Zero to negative power?
1A53: CA0005   [75|75]          JP      Z,DZERR         ; Yes - ?/0 Error
1A56: B7       [ 4]     POWER1: OR      A               ; Base zero?
1A57: CAC515   [14|14]          JP      Z,SAVEXP        ; Yes - Return zero
1A5A: D5       [25]             PUSH    DE              ; Save base
1A5B: C5       [36]             PUSH    BC
1A5C: 79       [40]             LD      A,C             ; Get MSB of base
1A5D: F67F     [47]             OR      01111111B       ; Get sign status
1A5F: CDF017   [64]             CALL    BCDEFP          ; Move power to BCDE
1A62: F2731A   [74|74]          JP      P,POWER2        ; Positive base - Ok
1A65: D5       [85]             PUSH    DE              ; Save power
1A66: C5       [96]             PUSH    BC
1A67: CD7718   [113]            CALL    INT             ; Get integer of power
1A6A: C1       [123]            POP     BC              ; Restore power
1A6B: D1       [133]            POP     DE
1A6C: F5       [144]            PUSH    AF              ; MSB of base
1A6D: CD1F18   [161]            CALL    CMPNUM          ; Power an integer?
1A70: E1       [171]            POP     HL              ; Restore MSB of base
1A71: 7C       [175]            LD      A,H             ; but don't affect flags
1A72: 1F       [179]            RRA                     ; Exponent odd or even?
1A73: E1       [10]     POWER2: POP     HL              ; Restore MSB and exponent
1A74: 222B21   [26]             LD      (FPREG+2),HL    ; Save base in FPREG
1A77: E1       [36]             POP     HL              ; LSBs of base
1A78: 222921   [52]             LD      (FPREG),HL      ; Save in FPREG
1A7B: DC381A   [62|69]          CALL    C,NEGAFT        ; Odd power - Negate result
1A7E: CCCD17   [72|79]          CALL    Z,INVSGN        ; Negative base - Negate it
1A81: D5       [83]             PUSH    DE              ; Save power
1A82: C5       [94]             PUSH    BC
1A83: CD5816   [111]            CALL    LOG             ; Get LOG of base
1A86: C1       [121]            POP     BC              ; Restore power
1A87: D1       [131]            POP     DE
1A88: CD9916   [148]            CALL    FPMULT          ; Multiply LOG by power
                        
1A8B: CDD517   [17]     EXP:    CALL    STAKFP          ; Put value on stack
1A8E: 013881   [27]             LD      BC,08138H       ; BCDE = 1/Ln(2)
1A91: 113BAA   [37]             LD      DE,0AA3BH
1A94: CD9916   [54]             CALL    FPMULT          ; Multiply value by 1/LN(2)
1A97: 3A2C21   [67]             LD      A,(FPEXP)       ; Get exponent
1A9A: FE88     [74]             CP      80H+8           ; Is it in range?
1A9C: D28017   [84|84]          JP      NC,OVTST1       ; No - Test for overflow
1A9F: CD7718   [101]            CALL    INT             ; Get INT of FPREG
1AA2: C680     [108]            ADD     A,80H           ; For excess 128
1AA4: C602     [115]            ADD     A,2             ; Exponent > 126?
1AA6: DA8017   [125|125]        JP      C,OVTST1        ; Yes - Test for overflow
1AA9: F5       [136]            PUSH    AF              ; Save scaling factor
1AAA: 214716   [146]            LD      HL,UNITY        ; Point to 1.
1AAD: CD4F15   [163]            CALL    ADDPHL          ; Add 1 to FPREG
1AB0: CD9016   [180]            CALL    MULLN2          ; Multiply by LN(2)
1AB3: F1       [190]            POP     AF              ; Restore scaling factor
1AB4: C1       [200]            POP     BC              ; Restore exponent
1AB5: D1       [210]            POP     DE
1AB6: F5       [221]            PUSH    AF              ; Save scaling factor
1AB7: CD5B15   [238]            CALL    SUBCDE          ; Subtract exponent from FPREG
1ABA: CDCD17   [255]            CALL    INVSGN          ; Negate result
1ABD: 21CB1A   [265]            LD      HL,EXPTAB       ; Coefficient table
1AC0: CDFB1A   [282]            CALL    SMSER1          ; Sum the series
1AC3: 110000   [292]            LD      DE,0            ; Zero LSBs
1AC6: C1       [302]            POP     BC              ; Scaling factor
1AC7: 4A       [306]            LD      C,D             ; Zero MSB
1AC8: C39916   [316]            JP      FPMULT          ; Scale result to correct value
                        
1ACB: 08                EXPTAB: .BYTE      8                       ; Table used by EXP
1ACC: 402E9474                  .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
1AD0: 704F2E77                  .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
1AD4: 6E02887A                  .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
1AD8: E6A02A7C                  .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
1ADC: 50AAAA7E                  .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
1AE0: FFFF7F7F                  .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
1AE4: 00008081                  .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
1AE8: 00000081                  .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
                        
1AEC: CDD517   [17]     SUMSER: CALL    STAKFP          ; Put FPREG on stack
1AEF: 119716   [27]             LD      DE,MULT         ; Multiply by "X"
1AF2: D5       [38]             PUSH    DE              ; To be done after
1AF3: E5       [49]             PUSH    HL              ; Save address of table
1AF4: CDF017   [66]             CALL    BCDEFP          ; Move FPREG to BCDE
1AF7: CD9916   [83]             CALL    FPMULT          ; Square the value
1AFA: E1       [93]             POP     HL              ; Restore address of table
1AFB: CDD517   [17]     SMSER1: CALL    STAKFP          ; Put value on stack
1AFE: 7E       [24]             LD      A,(HL)          ; Get number of coefficients
1AFF: 23       [30]             INC     HL              ; Point to start of table
1B00: CDE217   [47]             CALL    PHLTFP          ; Move coefficient to FPREG
1B03: 06                        .BYTE      06H             ; Skip "POP AF"
1B04: F1       [10]     SUMLP:  POP     AF              ; Restore count
1B05: C1       [20]             POP     BC              ; Restore number
1B06: D1       [30]             POP     DE
1B07: 3D       [34]             DEC     A               ; Cont coefficients
1B08: C8       [39|45]          RET     Z               ; All done
1B09: D5       [50]             PUSH    DE              ; Save number
1B0A: C5       [61]             PUSH    BC
1B0B: F5       [72]             PUSH    AF              ; Save count
1B0C: E5       [83]             PUSH    HL              ; Save address in table
1B0D: CD9916   [100]            CALL    FPMULT          ; Multiply FPREG by BCDE
1B10: E1       [110]            POP     HL              ; Restore address in table
1B11: CDF317   [127]            CALL    LOADFP          ; Number at HL to BCDE
1B14: E5       [138]            PUSH    HL              ; Save address in table
1B15: CD5E15   [155]            CALL    FPADD           ; Add coefficient to FPREG
1B18: E1       [165]            POP     HL              ; Restore address in table
1B19: C3041B   [175]            JP      SUMLP           ; More coefficients
                        
1B1C: CDA417   [17]     RND:    CALL    TSTSGN          ; Test sign of FPREG
1B1F: 215E20   [27]             LD      HL,SEED+2       ; Random number seed
1B22: FA7D1B   [37|37]          JP      M,RESEED        ; Negative - Re-seed
1B25: 217F20   [47]             LD      HL,LSTRND       ; Last random number
1B28: CDE217   [64]             CALL    PHLTFP          ; Move last RND to FPREG
1B2B: 215E20   [74]             LD      HL,SEED+2       ; Random number seed
1B2E: C8       [79|85]          RET     Z               ; Return if RND(0)
1B2F: 86       [86]             ADD     A,(HL)          ; Add (SEED)+2)
1B30: E607     [93]             AND     00000111B       ; 0 to 7
1B32: 0600     [100]            LD      B,0
1B34: 77       [107]            LD      (HL),A          ; Re-save seed
1B35: 23       [113]            INC     HL              ; Move to coefficient table
1B36: 87       [117]            ADD     A,A             ; 4 bytes
1B37: 87       [121]            ADD     A,A             ; per entry
1B38: 4F       [125]            LD      C,A             ; BC = Offset into table
1B39: 09       [136]            ADD     HL,BC           ; Point to coefficient
1B3A: CDF317   [153]            CALL    LOADFP          ; Coefficient to BCDE
1B3D: CD9916   [170]            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
1B40: 3A5D20   [183]            LD      A,(SEED+1)      ; Get (SEED+1)
1B43: 3C       [187]            INC     A               ; Add 1
1B44: E603     [194]            AND     00000011B       ; 0 to 3
1B46: 0600     [201]            LD      B,0
1B48: FE01     [208]            CP      1               ; Is it zero?
1B4A: 88       [212]            ADC     A,B             ; Yes - Make it 1
1B4B: 325D20   [225]            LD      (SEED+1),A      ; Re-save seed
1B4E: 21811B   [235]            LD      HL,RNDTAB-4     ; Addition table
1B51: 87       [239]            ADD     A,A             ; 4 bytes
1B52: 87       [243]            ADD     A,A             ; per entry
1B53: 4F       [247]            LD      C,A             ; BC = Offset into table
1B54: 09       [258]            ADD     HL,BC           ; Point to value
1B55: CD4F15   [275]            CALL    ADDPHL          ; Add value to FPREG
1B58: CDF017   [17]     RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
1B5B: 7B       [21]             LD      A,E             ; Get LSB
1B5C: 59       [25]             LD      E,C             ; LSB = MSB
1B5D: EE4F     [32]             XOR     01001111B       ; Fiddle around
1B5F: 4F       [36]             LD      C,A             ; New MSB
1B60: 3680     [46]             LD      (HL),80H        ; Set exponent
1B62: 2B       [52]             DEC     HL              ; Point to MSB
1B63: 46       [59]             LD      B,(HL)          ; Get MSB
1B64: 3680     [69]             LD      (HL),80H        ; Make value -0.5
1B66: 215C20   [79]             LD      HL,SEED         ; Random number seed
1B69: 34       [90]             INC     (HL)            ; Count seed
1B6A: 7E       [97]             LD      A,(HL)          ; Get seed
1B6B: D6AB     [104]            SUB     171             ; Do it modulo 171
1B6D: C2741B   [114|114]        JP      NZ,RND2         ; Non-zero - Ok
1B70: 77       [121]            LD      (HL),A          ; Zero seed
1B71: 0C       [125]            INC     C               ; Fillde about
1B72: 15       [129]            DEC     D               ; with the
1B73: 1C       [133]            INC     E               ; number
1B74: CDAF15   [17]     RND2:   CALL    BNORM           ; Normalise number
1B77: 217F20   [27]             LD      HL,LSTRND       ; Save random number
1B7A: C3FC17   [37]             JP      FPTHL           ; Move FPREG to last and return
                        
1B7D: 77       [ 7]     RESEED: LD      (HL),A          ; Re-seed random numbers
1B7E: 2B       [13]             DEC     HL
1B7F: 77       [20]             LD      (HL),A
1B80: 2B       [26]             DEC     HL
1B81: 77       [33]             LD      (HL),A
1B82: C3581B   [43]             JP      RND1            ; Return RND seed
                        
1B85: 68B14668          RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
1B89: 99E99269                  .BYTE   099H,0E9H,092H,069H
1B8D: 10D17568                  .BYTE   010H,0D1H,075H,068H
                        
1B91: 21DB1B   [10]     COS:    LD      HL,HALFPI       ; Point to PI/2
1B94: CD4F15   [27]             CALL    ADDPHL          ; Add it to PPREG
1B97: CDD517   [17]     SIN:    CALL    STAKFP          ; Put angle on stack
1B9A: 014983   [27]             LD      BC,8349H        ; BCDE = 2 PI
1B9D: 11DB0F   [37]             LD      DE,0FDBH
1BA0: CDE517   [54]             CALL    FPBCDE          ; Move 2 PI to FPREG
1BA3: C1       [64]             POP     BC              ; Restore angle
1BA4: D1       [74]             POP     DE
1BA5: CDFA16   [91]             CALL    DVBCDE          ; Divide angle by 2 PI
1BA8: CDD517   [108]            CALL    STAKFP          ; Put it on stack
1BAB: CD7718   [125]            CALL    INT             ; Get INT of result
1BAE: C1       [135]            POP     BC              ; Restore number
1BAF: D1       [145]            POP     DE
1BB0: CD5B15   [162]            CALL    SUBCDE          ; Make it 0 <= value < 1
1BB3: 21DF1B   [172]            LD      HL,QUARTR       ; Point to 0.25
1BB6: CD5515   [189]            CALL    SUBPHL          ; Subtract value from 0.25
1BB9: CDA417   [206]            CALL    TSTSGN          ; Test sign of value
1BBC: 37       [210]            SCF                     ; Flag positive
1BBD: F2C71B   [220|220]        JP      P,SIN1          ; Positive - Ok
1BC0: CD4C15   [237]            CALL    ROUND           ; Add 0.5 to value
1BC3: CDA417   [254]            CALL    TSTSGN          ; Test sign of value
1BC6: B7       [258]            OR      A               ; Flag negative
1BC7: F5       [11]     SIN1:   PUSH    AF              ; Save sign
1BC8: F4CD17   [21|28]          CALL    P,INVSGN        ; Negate value if positive
1BCB: 21DF1B   [31]             LD      HL,QUARTR       ; Point to 0.25
1BCE: CD4F15   [48]             CALL    ADDPHL          ; Add 0.25 to value
1BD1: F1       [58]             POP     AF              ; Restore sign
1BD2: D4CD17   [68|75]          CALL    NC,INVSGN       ; Negative - Make positive
1BD5: 21E31B   [78]             LD      HL,SINTAB       ; Coefficient table
1BD8: C3EC1A   [88]             JP      SUMSER          ; Evaluate sum of series
                        
1BDB: DB0F4981          HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
                        
1BDF: 0000007F          QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
                        
1BE3: 05                SINTAB: .BYTE   5                       ; Table used by SIN
1BE4: BAD71E86                  .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
1BE8: 64269987                  .BYTE   064H,026H,099H,087H     ;-76.575
1BEC: 58342387                  .BYTE   058H,034H,023H,087H     ; 81.602
1BF0: E05DA586                  .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
1BF4: DA0F4983                  .BYTE   0DAH,00FH,049H,083H     ;  6.2832
                        
1BF8: CDD517   [17]     TAN:    CALL    STAKFP          ; Put angle on stack
1BFB: CD971B   [34]             CALL    SIN             ; Get SIN of angle
1BFE: C1       [44]             POP     BC              ; Restore angle
1BFF: E1       [54]             POP     HL
1C00: CDD517   [71]             CALL    STAKFP          ; Save SIN of angle
1C03: EB       [75]             EX      DE,HL           ; BCDE = Angle
1C04: CDE517   [92]             CALL    FPBCDE          ; Angle to FPREG
1C07: CD911B   [109]            CALL    COS             ; Get COS of angle
1C0A: C3F816   [119]            JP      DIV             ; TAN = SIN / COS
                        
1C0D: CDA417   [17]     ATN:    CALL    TSTSGN          ; Test sign of value
1C10: FC381A   [27|34]          CALL    M,NEGAFT        ; Negate result after if -ve
1C13: FCCD17   [37|44]          CALL    M,INVSGN        ; Negate value if -ve
1C16: 3A2C21   [50]             LD      A,(FPEXP)       ; Get exponent
1C19: FE81     [57]             CP      81H             ; Number less than 1?
1C1B: DA2A1C   [67|67]          JP      C,ATN1          ; Yes - Get arc tangnt
1C1E: 010081   [77]             LD      BC,8100H        ; BCDE = 1
1C21: 51       [81]             LD      D,C
1C22: 59       [85]             LD      E,C
1C23: CDFA16   [102]            CALL    DVBCDE          ; Get reciprocal of number
1C26: 215515   [112]            LD      HL,SUBPHL       ; Sub angle from PI/2
1C29: E5       [123]            PUSH    HL              ; Save for angle > 1
1C2A: 21341C   [10]     ATN1:   LD      HL,ATNTAB       ; Coefficient table
1C2D: CDEC1A   [27]             CALL    SUMSER          ; Evaluate sum of series
1C30: 21DB1B   [37]             LD      HL,HALFPI       ; PI/2 - angle in case > 1
1C33: C9       [47]             RET                     ; Number > 1 - Sub from PI/2
                        
1C34: 09                ATNTAB: .BYTE   9                       ; Table used by ATN
1C35: 4AD73B78                  .BYTE   04AH,0D7H,03BH,078H     ; 1/17
1C39: 026E847B                  .BYTE   002H,06EH,084H,07BH     ;-1/15
1C3D: FEC12F7C                  .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
1C41: 74319A7D                  .BYTE   074H,031H,09AH,07DH     ;-1/11
1C45: 843D5A7D                  .BYTE   084H,03DH,05AH,07DH     ; 1/9
1C49: C87F917E                  .BYTE   0C8H,07FH,091H,07EH     ;-1/7
1C4D: E4BB4C7E                  .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
1C51: 6CAAAA7F                  .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
1C55: 00000081                  .BYTE   000H,000H,000H,081H     ; 1/1
                        
                        
1C59: C9       [10]     ARET:   RET                     ; A RETurn instruction
                        
1C5A: D7       [11]     GETINP: RST	    10H             ;input a character
1C5B: C9       [21]             RET
                        
1C5C:                   CLS: 
1C5C: 3E0C     [ 7]             LD      A,CS            ; ASCII Clear screen
1C5E: C3961D   [17]             JP      MONOUT          ; Output character
                        
1C61: CD2315   [17]     WIDTH:  CALL    GETINT          ; Get integer 0-255
1C64: 7B       [21]             LD      A,E             ; Width to A
1C65: 328720   [34]             LD      (LWIDTH),A      ; Set width
1C68: C9       [44]             RET
                        
1C69: CDC20D   [17]     LINES:  CALL    GETNUM          ; Get a number
1C6C: CD070A   [34]             CALL    DEINT           ; Get integer -32768 to 32767
1C6F: ED538B20 [54]             LD      (LINESC),DE     ; Set lines counter
1C73: ED538D20 [74]             LD      (LINESN),DE     ; Set lines number
1C77: C9       [84]             RET
                        
1C78: CD070A   [17]     DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
1C7B: D5       [28]             PUSH    DE              ; Save number
1C7C: E1       [38]             POP     HL              ; Number to HL
1C7D: 46       [45]             LD      B,(HL)          ; Get LSB of contents
1C7E: 23       [51]             INC     HL
1C7F: 7E       [58]             LD      A,(HL)          ; Get MSB of contents
1C80: C37D11   [68]             JP      ABPASS          ; Return integer AB
                        
1C83: CDC20D   [17]     DOKE:   CALL    GETNUM          ; Get a number
1C86: CD070A   [34]             CALL    DEINT           ; Get integer -32768 to 32767
1C89: D5       [45]             PUSH    DE              ; Save address
1C8A: CDCB07   [62]             CALL    CHKSYN          ; Make sure ',' follows
1C8D: 2C                        .BYTE      ','
1C8E: CDC20D   [79]             CALL    GETNUM          ; Get a number
1C91: CD070A   [96]             CALL    DEINT           ; Get integer -32768 to 32767
1C94: E3       [115]            EX      (SP),HL         ; Save value,get address
1C95: 73       [122]            LD      (HL),E          ; Save LSB of value
1C96: 23       [128]            INC     HL
1C97: 72       [135]            LD      (HL),D          ; Save MSB of value
1C98: E1       [145]            POP     HL              ; Restore code string address
1C99: C9       [155]            RET
                        
                        
                        ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                        
1C9A: CDC50D   [17]     HEX: 	CALL	TSTNUM          ; Verify it's a number
1C9D: CD070A   [34]             CALL	DEINT           ; Get integer -32768 to 32767
1CA0: C5       [45]             PUSH	BC              ; Save contents of BC
1CA1: 212E21   [55]             LD	    HL,PBUFF
1CA4: 7A       [59]             LD	    A,D             ; Get high order into A
1CA5: FE00     [66]             CP      $0
1CA7: 280C     [73|78]  		JR      Z,HEX2          ; Skip output if both high digits are zero
1CA9: CDD21C   [90]             CALL    BYT2ASC         ; Convert D to ASCII
1CAC: 78       [94]     		LD      A,B
1CAD: FE30     [101]    		CP      '0'
1CAF: 2802     [108|113]		JR      Z,HEX1          ; Don't store high digit if zero
1CB1: 70       [115]            LD	    (HL),B          ; Store it to PBUFF
1CB2: 23       [121]            INC	    HL              ; Next location
1CB3: 71       [ 7]     HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
1CB4: 23       [13]             INC     HL              ; Next location
1CB5: 7B       [ 4]     HEX2:   LD	    A,E             ; Get lower byte
1CB6: CDD21C   [21]             CALL    BYT2ASC         ; Convert E to ASCII
1CB9: 7A       [25]     		LD      A,D
1CBA: FE00     [32]             CP      $0
1CBC: 2005     [39|44]  		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
1CBE: 78       [43]     		LD      A,B
1CBF: FE30     [50]     		CP      '0'             ; If high digit of lower byte is zero then don't print
1CC1: 2802     [57|62]  		JR      Z,HEX4
1CC3: 70       [ 7]     HEX3:   LD      (HL),B          ; to PBUFF+2
1CC4: 23       [13]             INC     HL              ; Next location
1CC5: 71       [ 7]     HEX4:   LD      (HL),C          ; to PBUFF+3
1CC6: 23       [13]             INC     HL              ; PBUFF+4 to zero
1CC7: AF       [17]             XOR     A               ; Terminating character
1CC8: 77       [24]             LD      (HL),A          ; Store zero to terminate
1CC9: 23       [30]             INC     HL              ; Make sure PBUFF is terminated
1CCA: 77       [37]             LD      (HL),A          ; Store the double zero there
1CCB: C1       [47]             POP     BC              ; Get BC back
1CCC: 212E21   [57]             LD      HL,PBUFF        ; Reset to start of PBUFF
1CCF: C32B12   [67]             JP      STR1            ; Convert the PBUFF to a string and return it
                        
1CD2: 47       [ 4]     BYT2ASC	LD      B,A             ; Save original value
1CD3: E60F     [11]             AND     $0F             ; Strip off upper nybble
1CD5: FE0A     [18]             CP      $0A             ; 0-9?
1CD7: 3802     [25|30]          JR      C,ADD30         ; If A-F, add 7 more
1CD9: C607     [32]             ADD     A,$07           ; Bring value up to ASCII A-F
1CDB: C630     [ 7]     ADD30	ADD     A,$30           ; And make ASCII
1CDD: 4F       [11]             LD      C,A             ; Save converted char to C
1CDE: 78       [15]             LD      A,B             ; Retrieve original value
1CDF: 0F       [19]             RRCA                    ; and Rotate it right
1CE0: 0F       [23]             RRCA
1CE1: 0F       [27]             RRCA
1CE2: 0F       [31]             RRCA
1CE3: E60F     [38]             AND     $0F             ; Mask off upper nybble
1CE5: FE0A     [45]             CP      $0A             ; 0-9? < A hex?
1CE7: 3802     [52|57]          JR      C,ADD301        ; Skip Add 7
1CE9: C607     [59]             ADD     A,$07           ; Bring it up to ASCII A-F
1CEB: C630     [ 7]     ADD301	ADD     A,$30           ; And make it full ASCII
1CED: 47       [11]             LD      B,A             ; Store high order byte
1CEE: C9       [21]             RET	
                        
                        ; Convert "&Hnnnn" to FPREG
                        ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                        ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
1CEF: EB       [ 4]     HEXTFP  EX      DE,HL           ; Move code string pointer to DE
1CF0: 210000   [14]             LD      HL,$0000        ; Zero out the value
1CF3: CD081D   [31]             CALL    GETHEX          ; Check the number for valid hex
1CF6: DA281D   [41|41]          JP      C,HXERR         ; First value wasn't hex, HX error
1CF9: 1805     [53]             JR      HEXLP1          ; Convert first character
1CFB: CD081D   [17]     HEXLP   CALL    GETHEX          ; Get second and addtional characters
1CFE: 381F     [24|29]          JR      C,HEXIT         ; Exit if not a hex character
1D00: 29       [11]     HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
1D01: 29       [22]             ADD     HL,HL
1D02: 29       [33]             ADD     HL,HL
1D03: 29       [44]             ADD     HL,HL
1D04: B5       [48]             OR      L               ; Add in D0-D3 into L
1D05: 6F       [52]             LD      L,A             ; Save new value
1D06: 18F3     [64]             JR      HEXLP           ; And continue until all hex characters are in
                        
1D08: 13       [ 6]     GETHEX  INC     DE              ; Next location
1D09: 1A       [13]             LD      A,(DE)          ; Load character at pointer
1D0A: FE20     [20]             CP      ' '
1D0C: CA081D   [30|30]          JP      Z,GETHEX        ; Skip spaces
1D0F: D630     [37]             SUB     $30             ; Get absolute value
1D11: D8       [42|48]          RET     C               ; < "0", error
1D12: FE0A     [49]             CP      $0A
1D14: 3805     [56|61]          JR      C,NOSUB7        ; Is already in the range 0-9
1D16: D607     [63]             SUB     $07             ; Reduce to A-F
1D18: FE0A     [70]             CP      $0A             ; Value should be $0A-$0F at this point
1D1A: D8       [75|81]          RET     C               ; CY set if was :            ; < = > ? @
1D1B: FE10     [ 7]     NOSUB7  CP      $10             ; > Greater than "F"?
1D1D: 3F       [11]             CCF
1D1E: C9       [21]             RET                     ; CY set if it wasn't valid hex
                            
1D1F: EB       [ 4]     HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
1D20: 7A       [ 8]             LD      A,D             ; Load DE into AC
1D21: 4B       [12]             LD      C,E             ; For prep to 
1D22: E5       [23]             PUSH    HL
1D23: CD7C11   [40]             CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
1D26: E1       [50]             POP     HL
1D27: C9       [60]             RET
                        
1D28: 1E26     [ 7]     HXERR:  LD      E,HX            ; ?HEX Error
1D2A: C31105   [17]             JP      ERROR
                        
                        ; BIN$(NN) Convert integer to a 1-16 char binary string
1D2D: CDC50D   [17]     BIN:    CALL    TSTNUM          ; Verify it's a number
1D30: CD070A   [34]             CALL    DEINT           ; Get integer -32768 to 32767
1D33: C5       [11]     BIN2:   PUSH    BC              ; Save contents of BC
1D34: 212E21   [21]             LD      HL,PBUFF
1D37: 0611     [28]             LD      B,17            ; One higher than max char count
1D39:                   ZEROSUP:                        ; Suppress leading zeros
1D39: 05       [ 4]             DEC     B               ; Max 16 chars
1D3A: 78       [ 8]             LD      A,B
1D3B: FE01     [15]             CP      $01
1D3D: 2808     [22|27]          JR      Z,BITOUT        ; Always output at least one character
1D3F: CB13     [30]             RL      E
1D41: CB12     [38]             RL      D
1D43: 30F4     [45|50]          JR      NC,ZEROSUP
1D45: 1804     [57]             JR      BITOUT2
1D47:                   BITOUT:      
1D47: CB13     [ 8]             RL      E
1D49: CB12     [16]             RL      D               ; Top bit now in carry
1D4B:                   BITOUT2:
1D4B: 3E30     [ 7]             LD      A,'0'           ; Char for '0'
1D4D: CE00     [14]             ADC     A,0             ; If carry set then '0' --> '1'
1D4F: 77       [21]             LD      (HL),A
1D50: 23       [27]             INC     HL
1D51: 05       [31]             DEC     B
1D52: 20F3     [38|43]          JR      NZ,BITOUT
1D54: AF       [42]             XOR     A               ; Terminating character
1D55: 77       [49]             LD      (HL),A          ; Store zero to terminate
1D56: 23       [55]             INC     HL              ; Make sure PBUFF is terminated
1D57: 77       [62]             LD      (HL),A          ; Store the double zero there
1D58: C1       [72]             POP     BC
1D59: 212E21   [82]             LD      HL,PBUFF
1D5C: C32B12   [92]             JP      STR1
                        
                        ; Convert "&Bnnnn" to FPREG
                        ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
1D5F: EB       [ 4]     BINTFP: EX      DE,HL           ; Move code string pointer to DE
1D60: 210000   [14]             LD      HL,$0000        ; Zero out the value
1D63: CD7C1D   [31]             CALL    CHKBIN          ; Check the number for valid bin
1D66: DA8A1D   [41|41]          JP      C,BINERR        ; First value wasn't bin, HX error
1D69: D630     [ 7]     BINIT:  SUB     '0'
1D6B: 29       [18]             ADD     HL,HL           ; Rotate HL left
1D6C: B5       [22]             OR      L
1D6D: 6F       [26]             LD      L,A
1D6E: CD7C1D   [43]             CALL    CHKBIN          ; Get second and addtional characters
1D71: 30F6     [50|55]          JR      NC,BINIT        ; Process if a bin character
1D73: EB       [54]             EX      DE,HL           ; Value into DE, Code string into HL
1D74: 7A       [58]             LD      A,D             ; Load DE into AC
1D75: 4B       [62]             LD      C,E             ; For prep to 
1D76: E5       [73]             PUSH    HL
1D77: CD7C11   [90]             CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
1D7A: E1       [100]            POP     HL
1D7B: C9       [110]            RET
                        
                        ; Char is in A, NC if char is 0 or 1
1D7C: 13       [ 6]     CHKBIN: INC     DE
1D7D: 1A       [13]             LD      A,(DE)
1D7E: FE20     [20]             CP      ' '
1D80: CA7C1D   [30|30]          JP      Z,CHKBIN        ; Skip spaces
1D83: FE30     [37]             CP      '0'             ; Set C if < '0'
1D85: D8       [42|48]          RET     C
1D86: FE32     [49]             CP      '2'
1D88: 3F       [53]             CCF                     ; Set C if > '1'
1D89: C9       [63]             RET
                        
1D8A: 1E28     [ 7]     BINERR: LD      E,BN            ; ?BIN Error
1D8C: C31105   [17]             JP      ERROR
                        
                        
1D8F:                   JJUMP1: 
1D8F: DD21FFFF [14]             LD      IX,-1           ; Flag cold start
1D93: C36101   [24]             JP      CSTART          ; Go and initialise
                        
1D96:                   MONOUT: 
1D96: C30800   [10]             JP      $0008           ; output a char
                        
                        
1D99:                   MONITR: 
1D99: C30000   [10]             JP      $0000           ; Restart (Normally Monitor Start)
                        
                        
1D9C: 3E00     [ 7]     INITST: LD      A,0             ; Clear break flag
1D9E: 329220   [20]             LD      (BRKFLG),A
1DA1: C36801   [30]             JP      INIT
                        
1DA4: ED45     [14]     ARETN:  RETN                    ; Return from NMI
                        
                        
1DA6: F5       [11]     TSTBIT: PUSH    AF              ; Save bit mask
1DA7: A0       [15]             AND     B               ; Get common bits
1DA8: C1       [25]             POP     BC              ; Restore bit mask
1DA9: B8       [29]             CP      B               ; Same bit set?
1DAA: 3E00     [36]             LD      A,0             ; Return 0 in A
1DAC: C9       [46]             RET
                        
1DAD: CDD607   [17]     OUTNCR: CALL    OUTC            ; Output character in A
1DB0: C3FD0B   [27]             JP      PRNTCRLF        ; Output CRLF
                        
                        .end
                        


; +++ segments +++

#CODE          = $0150 =   336,  size = $1C63 =  7267

; +++ global symbols +++

ABPASS   = $117D =  4477          basic.asm:2413
ABS      = $17C9 =  6089          basic.asm:3436
ACCSUM   = $09E6 =  2534          basic.asm:1315 (unused)
ACPASS   = $117C =  4476          basic.asm:2412
ADD30    = $1CDB =  7387          basic.asm:4184
ADD301   = $1CEB =  7403          basic.asm:4195
ADDEXP   = $1762 =  5986          basic.asm:3371
ADDIG    = $1908 =  6408          basic.asm:3659
ADDPHL   = $154F =  5455          basic.asm:3018
ALLFOL   = $144B =  5195          basic.asm:2860
ANTVLU   = $0CE6 =  3302          basic.asm:1722
ARET     = $1C59 =  7257          basic.asm:4099 (unused)
ARETN    = $1DA4 =  7588          basic.asm:4327 (unused)
ARLDSV   = $109D =  4253          basic.asm:2268
ARREND   = $211F =  8479          basic.asm:93
ARRLP    = $1316 =  4886          basic.asm:2651
ASC      = $141C =  5148          basic.asm:2830
ASCTFP   = $18AB =  6315          basic.asm:3605
ASPCS    = $0C48 =  3144          basic.asm:1645
ATN      = $1C0D =  7181          basic.asm:4070
ATN1     = $1C2A =  7210          basic.asm:4082
ATNTAB   = $1C34 =  7220          basic.asm:4087
ATOH     = $0A21 =  2593          basic.asm:1348
BADINP   = $0C6D =  3181          basic.asm:1657
BAKSTK   = $04A6 =  1190          basic.asm:523
BAKTMP   = $13FC =  5116          basic.asm:2808
BASTXT   = $20A3 =  8355          basic.asm:69
BCDEFP   = $17F0 =  6128          basic.asm:3463
BFREE    = $01FD =   509          basic.asm:222
BIN      = $1D2D =  7469          basic.asm:4244
BIN2     = $1D33 =  7475          basic.asm:4246 (unused)
BINERR   = $1D8A =  7562          basic.asm:4307
BINIT    = $1D69 =  7529          basic.asm:4282
BINTFP   = $1D5F =  7519          basic.asm:4278
BITOUT   = $1D47 =  7495          basic.asm:4258
BITOUT2  = $1D4B =  7499          basic.asm:4261
BKSP     = $0008 =     8          basic.asm:26
BN       = $0028 =    40          basic.asm:127
BNORM    = $15AF =  5551          basic.asm:3077
BNRMLP   = $15B2 =  5554          basic.asm:3080
BRK      = $0998 =  2456          basic.asm:1270
BRKFLG   = $2092 =  8338          basic.asm:62
BRKLIN   = $2113 =  8467          basic.asm:87
BRKMSG   = $04A0 =  1184          basic.asm:521
BRKRET   = $01F7 =   503          basic.asm:219
BS       = $0010 =    16          basic.asm:115
BSERR    = $10D0 =  4304          basic.asm:2299
BUFFER   = $20A6 =  8358          basic.asm:70
BYT2ASC  = $1CD2 =  7378          basic.asm:4179
BYTSFT   = $16E7 =  5863          basic.asm:3288
CFEVAL   = $1033 =  4147          basic.asm:2199
CHARTY   = $0FE1 =  4065          basic.asm:2155
CHEKFN   = $1214 =  4628          basic.asm:2504
CHKBIN   = $1D7C =  7548          basic.asm:4297
CHKLTR   = $09F3 =  2547          basic.asm:1324
CHKSTK   = $04DA =  1242          basic.asm:560
CHKSUM   = $208F =  8335          basic.asm:60
CHKSYN   = $07CB =  1995          basic.asm:994
CHKTYP   = $0DC7 =  3527          basic.asm:1837
CHR      = $142D =  5165          basic.asm:2842
CLEAR    = $0A46 =  2630          basic.asm:1372
CLOTST   = $0800 =  2048          basic.asm:1026
CLREG    = $062F =  1583          basic.asm:766
CLRPTR   = $060A =  1546          basic.asm:746
CLS      = $1C5C =  7260          basic.asm:4104
CMPFP    = $1839 =  6201          basic.asm:3521
CMPLG1   = $0F47 =  3911          basic.asm:2061
CMPLOG   = $0F45 =  3909          basic.asm:2060
CMPNUM   = $181F =  6175          basic.asm:3504
CMPRES   = $0F89 =  3977          basic.asm:2109
CMPSTR   = $0F71 =  3953          basic.asm:2089
CN       = $0020 =    32          basic.asm:123
CNVNUM   = $18B7 =  6327          basic.asm:3611
COLD     = $0150 =   336          basic.asm:131 (unused)
COMMAN   = $2088 =  8328          basic.asm:55
COMPL    = $160F =  5647          basic.asm:3151
CONCAT   = $1391 =  5009          basic.asm:2741
CONEXP   = $18E7 =  6375          basic.asm:3635
CONPOS   = $15AC =  5548          basic.asm:3075
CONT     = $09CB =  2507          basic.asm:1298
CONTAD   = $2119 =  8473          basic.asm:90
CONVAR   = $0EB2 =  3762          basic.asm:1961
COPY     = $0170 =   368          basic.asm:148
COS      = $1B91 =  7057          basic.asm:4018
COUNT    = $0870 =  2160          basic.asm:1092
CPDEHL   = $07C5 =  1989          basic.asm:987
CPYLIT   = $0701 =  1793          basic.asm:884
CR       = $000D =    13          basic.asm:29
CRARLP   = $10F0 =  4336          basic.asm:2319
CREARY   = $10D5 =  4309          basic.asm:2302
CRESTR   = $0B45 =  2885          basic.asm:1511
CRNCLP   = $0662 =  1634          basic.asm:792
CRTMST   = $124D =  4685          basic.asm:2537
CRTST    = $1259 =  4697          basic.asm:2548
CRTSTE   = $126F =  4719          basic.asm:2562
CRUNCH   = $0659 =  1625          basic.asm:788
CS       = $000C =    12          basic.asm:28
CSTART   = $0161 =   353          basic.asm:141
CTLOFG   = $208A =  8330          basic.asm:57
CTRLC    = $0003 =     3          basic.asm:24
CTRLG    = $0007 =     7          basic.asm:25
CTRLO    = $000F =    15          basic.asm:30
CTRLQ    = $0011 =    17          basic.asm:31
CTRLR    = $0012 =    18          basic.asm:32
CTRLS    = $0013 =    19          basic.asm:33
CTRLU    = $0015 =    21          basic.asm:34
CUROPR   = $210A =  8458          basic.asm:81
CURPOS   = $20F0 =  8432          basic.asm:72
DATA     = $0AEC =  2796          basic.asm:1463
DATFLG   = $20F3 =  8435          basic.asm:75
DATLIN   = $210E =  8462          basic.asm:83
DATSNR   = $04F7 =  1271          basic.asm:580
DCBCDE   = $1870 =  6256          basic.asm:3564
DD       = $0012 =    18          basic.asm:116
DDERR    = $0506 =  1286          basic.asm:588
DEEK     = $1C78 =  7288          basic.asm:4119
DEF      = $1191 =  4497          basic.asm:2425
DEFSIZ   = $10F8 =  4344          basic.asm:2323
DEINT    = $0A07 =  2567          basic.asm:1335
DEL      = $007F =   127          basic.asm:36
DELCHR   = $0731 =  1841          basic.asm:914
DEPINT   = $0A01 =  2561          basic.asm:1333
DETHL4   = $17FF =  6143          basic.asm:3475
DETHLB   = $1801 =  6145          basic.asm:3476
DIGTXT   = $19B1 =  6577          basic.asm:3757
DIM      = $0FB3 =  4019          basic.asm:2135
DIMRET   = $0FAA =  4010          basic.asm:2130
DINPOS   = $07FA =  2042          basic.asm:1021
DIV      = $16F8 =  5880          basic.asm:3299
DIV1     = $204F =  8271          basic.asm:45
DIV10    = $16EC =  5868          basic.asm:3294
DIV2     = $2053 =  8275          basic.asm:46
DIV3     = $2057 =  8279          basic.asm:47
DIV4     = $205A =  8282          basic.asm:48
DIVLP    = $171F =  5919          basic.asm:3323
DIVSUP   = $204E =  8270          basic.asm:44
DOAGN    = $0648 =  1608          basic.asm:779
DOCOM    = $0C19 =  3097          basic.asm:1621
DODEL    = $0711 =  1809          basic.asm:898
DOEBIT   = $19F1 =  6641          basic.asm:3800
DOFN     = $11BE =  4542          basic.asm:2453
DOKE     = $1C83 =  7299          basic.asm:4127
DONULL   = $0C07 =  3079          basic.asm:1610
DOSPC    = $0C43 =  3139          basic.asm:1642
DOTAB    = $0C30 =  3120          basic.asm:1632
DPOINT   = $18E3 =  6371          basic.asm:3633
DTSTR    = $125D =  4701          basic.asm:2551
DVBCDE   = $16FA =  5882          basic.asm:3301
DZ       = $0014 =    20          basic.asm:117
DZERR    = $0500 =  1280          basic.asm:584
ECHDEL   = $0725 =  1829          basic.asm:907
EDIGIT   = $192A =  6442          basic.asm:3682
ENDBUF   = $0708 =  1800          basic.asm:890
ENDCON   = $18F6 =  6390          basic.asm:3645
ENDDIM   = $1157 =  4439          basic.asm:2392
ENDINP   = $0BF8 =  3064          basic.asm:1604
ENDNAM   = $0FD5 =  4053          basic.asm:2151
ENDPRG   = $09A7 =  2471          basic.asm:1281
ENFMEM   = $04E3 =  1251          basic.asm:566
ERRIN    = $0531 =  1329          basic.asm:609
ERRLIN   = $2117 =  8471          basic.asm:89
ERRMSG   = $048E =  1166          basic.asm:517
ERROR    = $0511 =  1297          basic.asm:596
ERRORS   = $0404 =  1028          basic.asm:446
ESC      = $001B =    27          basic.asm:35
EVAL     = $0DD4 =  3540          basic.asm:1845
EVAL1    = $0DD7 =  3543          basic.asm:1847
EVAL2    = $0DE0 =  3552          basic.asm:1851
EVAL3    = $0DE3 =  3555          basic.asm:1852
EVLPAR   = $0E99 =  3737          basic.asm:1947
EVNOT    = $0F93 =  3987          basic.asm:2117
EXCUTE   = $0935 =  2357          basic.asm:1203
EXP      = $1A8B =  6795          basic.asm:3887
EXPLP    = $18D5 =  6357          basic.asm:3625
EXPTAB   = $1ACB =  6859          basic.asm:3915
EXPTEN   = $1A03 =  6659          basic.asm:3810
EXTIG    = $0D42 =  3394          basic.asm:1770
FANDT    = $0D6C =  3436          basic.asm:1788
FC       = $0008 =     8          basic.asm:111
FCERR    = $0A1C =  2588          basic.asm:1345
FDTLP    = $0D53 =  3411          basic.asm:1772
FINDEL   = $1133 =  4403          basic.asm:2364
FLGDIF   = $17AF =  6063          basic.asm:3419
FLGREL   = $17B6 =  6070          basic.asm:3425
FNARG    = $2125 =  8485          basic.asm:96
FNCTAB   = $024E =   590          basic.asm:232
FNDARY   = $10A3 =  4259          basic.asm:2272
FNDELP   = $1138 =  4408          basic.asm:2369
FNDEND   = $05DD =  1501          basic.asm:709
FNDNUM   = $1520 =  5408          basic.asm:2992
FNDTOK   = $084F =  2127          basic.asm:1072
FNDVAR   = $101A =  4122          basic.asm:2183
FNDWRD   = $068C =  1676          basic.asm:812
FNOFST   = $0EC3 =  3779          basic.asm:1971
FNRGNM   = $2123 =  8483          basic.asm:95
FNTHR    = $1028 =  4136          basic.asm:2191
FNVAL    = $0EEA =  3818          basic.asm:1993
FOPRND   = $0E0C =  3596          basic.asm:1873
FOR      = $089C =  2204          basic.asm:1114
FORFLG   = $2110 =  8464          basic.asm:84
FORFND   = $08CC =  2252          basic.asm:1142
FORSLP   = $08B0 =  2224          basic.asm:1123
FPADD    = $155E =  5470          basic.asm:3026
FPBCDE   = $17E5 =  6117          basic.asm:3455
FPEXP    = $212C =  8492          basic.asm:98
FPINT    = $184C =  6220          basic.asm:3541
FPMULT   = $1699 =  5785          basic.asm:3237
FPREG    = $2129 =  8489          basic.asm:97
FPROND   = $15F6 =  5622          basic.asm:3127
FPSINT   = $09FB =  2555          basic.asm:1331
FPTHL    = $17FC =  6140          basic.asm:3474
FRE      = $115B =  4443          basic.asm:2395
FRENUM   = $1177 =  4471          basic.asm:2407
FRMEVL   = $0EB5 =  3765          basic.asm:1962
GARBGE   = $12DE =  4830          basic.asm:2624
GARBLP   = $12E1 =  4833          basic.asm:2625
GETCHR   = $0955 =  2389          basic.asm:1223
GETCMD   = $0555 =  1365          basic.asm:626
GETHEX   = $1D08 =  7432          basic.asm:4217
GETINP   = $1C5A =  7258          basic.asm:4101
GETINT   = $1523 =  5411          basic.asm:2993
GETLEN   = $1411 =  5137          basic.asm:2822
GETLIN   = $0742 =  1858          basic.asm:922
GETLN    = $0A22 =  2594          basic.asm:1349
GETNUM   = $0DC2 =  3522          basic.asm:1834
GETNXT   = $06A7 =  1703          basic.asm:827
GETSTR   = $13DB =  5083          basic.asm:2788
GETVAR   = $0FB8 =  4024          basic.asm:2138
GNXARY   = $1315 =  4885          basic.asm:2650
GOFUNC   = $0EF2 =  3826          basic.asm:1997
GOSUB    = $0A98 =  2712          basic.asm:1414
GOTO     = $0AA9 =  2729          basic.asm:1426
GRBARY   = $1335 =  4917          basic.asm:2669
GRBDON   = $12B6 =  4790          basic.asm:2599
GRBLP    = $12EF =  4847          basic.asm:2631
GSTRCU   = $13DE =  5086          basic.asm:2789
GSTRDE   = $13E2 =  5090          basic.asm:2791
GSTRHL   = $13E1 =  5089          basic.asm:2790
GTFLNM   = $1420 =  5152          basic.asm:2832 (unused)
GTFNAM   = $0FBD =  4029          basic.asm:2141
GTLNLP   = $0A25 =  2597          basic.asm:1350
GTSIXD   = $197B =  6523          basic.asm:3726
GTVLUS   = $0CBE =  3262          basic.asm:1700
HALF     = $1A22 =  6690          basic.asm:3831
HALFPI   = $1BDB =  7131          basic.asm:4049
HEX      = $1C9A =  7322          basic.asm:4144
HEX1     = $1CB3 =  7347          basic.asm:4157
HEX2     = $1CB5 =  7349          basic.asm:4159
HEX3     = $1CC3 =  7363          basic.asm:4167
HEX4     = $1CC5 =  7365          basic.asm:4169
HEXIT    = $1D1F =  7455          basic.asm:4232
HEXLP    = $1CFB =  7419          basic.asm:4207
HEXLP1   = $1D00 =  7424          basic.asm:4209
HEXTFP   = $1CEF =  7407          basic.asm:4202
HX       = $0026 =    38          basic.asm:126
HXERR    = $1D28 =  7464          basic.asm:4240
ID       = $0016 =    22          basic.asm:118
IDTEST   = $1206 =  4614          basic.asm:2494
IF       = $0B7B =  2939          basic.asm:1544
IFGO     = $0B89 =  2953          basic.asm:1551
IFJMP    = $093C =  2364          basic.asm:1206
INCHL    = $17FA =  6138          basic.asm:3471
INCLEN   = $07F6 =  2038          basic.asm:1019
INDFND   = $04C0 =  1216          basic.asm:542
INEWLN   = $05A5 =  1445          basic.asm:669
INIT     = $0168 =   360          basic.asm:145
INITAB   = $042E =  1070          basic.asm:470
INITBE   = $048E =  1166          basic.asm:513
INITST   = $1D9C =  7580          basic.asm:4323
INMSG    = $0495 =  1173          basic.asm:518
INP      = $14E0 =  5344          basic.asm:2961
INPBIN   = $0D10 =  3344          basic.asm:1744
INPBRK   = $09A4 =  2468          basic.asm:1279
INPORT   = $2084 =  8324          basic.asm:52
INPSUB   = $2083 =  8323          basic.asm:51
INPUT    = $0C7E =  3198          basic.asm:1665
INRNG    = $1984 =  6532          basic.asm:3731
INT      = $1877 =  6263          basic.asm:3572
INTVAR   = $0619 =  1561          basic.asm:757
INVSGN   = $17CD =  6093          basic.asm:3438
ITMSEP   = $0D01 =  3329          basic.asm:1735
JJUMP1   = $1D8F =  7567          basic.asm:4311 (unused)
JSTZER   = $1A0D =  6669          basic.asm:3816
KILFOR   = $0DB2 =  3506          basic.asm:1825
KILIN    = $073C =  1852          basic.asm:919
LCRFLG   = $20F1 =  8433          basic.asm:73
LEFT     = $143D =  5181          basic.asm:2850
LEN      = $140D =  5133          basic.asm:2820
LET      = $0B03 =  2819          basic.asm:1479
LETNUM   = $0B56 =  2902          basic.asm:1521
LETSTR   = $0B1E =  2846          basic.asm:1492
LF       = $000A =    10          basic.asm:27
LFRGNM   = $14D6 =  5334          basic.asm:2952
LINEAT   = $20A1 =  8353          basic.asm:68
LINEIN   = $1936 =  6454          basic.asm:3692
LINES    = $1C69 =  7273          basic.asm:4113
LINESC   = $208B =  8331          basic.asm:58
LINESN   = $208D =  8333          basic.asm:59
LINFND   = $058E =  1422          basic.asm:655
LIST     = $0811 =  2065          basic.asm:1036
LISTLP   = $081D =  2077          basic.asm:1042
LOADFP   = $17F3 =  6131          basic.asm:3464
LOG      = $1658 =  5720          basic.asm:3205
LOGTAB   = $164B =  5707          basic.asm:3200
LOKFOR   = $04AA =  1194          basic.asm:525
LOOPST   = $210C =  8460          basic.asm:82
LS       = $001C =    28          basic.asm:121
LSTBIN   = $2111 =  8465          basic.asm:85
LSTLP2   = $083D =  2109          basic.asm:1063
LSTLP3   = $0840 =  2112          basic.asm:1064
LSTRAM   = $20F4 =  8436          basic.asm:76
LSTRND   = $207F =  8319          basic.asm:50
LTSTND   = $0D1B =  3355          basic.asm:1749
LWIDTH   = $2087 =  8327          basic.asm:54
MAKINT   = $1526 =  5414          basic.asm:2994
MAKNUM   = $19A0 =  6560          basic.asm:3746
MANLP    = $18BF =  6335          basic.asm:3617
MATCH    = $06D9 =  1753          basic.asm:859
MEMMSG   = $0243 =   579          basic.asm:228
MID      = $1477 =  5239          basic.asm:2890
MID1     = $1443 =  5187          basic.asm:2854
MIDNUM   = $14DB =  5339          basic.asm:2955
MINCDE   = $159E =  5534          basic.asm:3061
MINUS    = $0EA1 =  3745          basic.asm:1952
MKTMST   = $124A =  4682          basic.asm:2536
MLDBLP   = $1898 =  6296          basic.asm:3593
MLDEBC   = $1890 =  6288          basic.asm:3588
MLOOP    = $0198 =   408          basic.asm:166
MLSP10   = $178D =  6029          basic.asm:3399
MO       = $0024 =    36          basic.asm:125
MONITR   = $1D99 =  7577          basic.asm:4319
MONOUT   = $1D96 =  7574          basic.asm:4315
MORDT    = $0D27 =  3367          basic.asm:1754
MORINP   = $074B =  1867          basic.asm:927
MOVBUF   = $05C4 =  1476          basic.asm:690
MOVDIR   = $06E1 =  1761          basic.asm:867
MOVLP    = $04CF =  1231          basic.asm:552
MOVSTR   = $04CC =  1228          basic.asm:549
MOVUP    = $04C9 =  1225          basic.asm:548
MRPRNT   = $0B9B =  2971          basic.asm:1558
MSIZE    = $0185 =   389          basic.asm:159
MUL8LP   = $16C4 =  5828          basic.asm:3260
MULLN2   = $1690 =  5776          basic.asm:3231
MULT     = $1697 =  5783          basic.asm:3235
MULT8    = $16BB =  5819          basic.asm:3254
MULTEN   = $1901 =  6401          basic.asm:3653
MULVAL   = $213B =  8507          basic.asm:101
MVSTPT   = $0B4D =  2893          basic.asm:1515
NEDMOR   = $0CBA =  3258          basic.asm:1698
NEGAFT   = $1A38 =  6712          basic.asm:3840
NEW      = $0609 =  1545          basic.asm:745
NEXITM   = $0C53 =  3155          basic.asm:1651
NEXT     = $0D77 =  3447          basic.asm:1793
NEXT1    = $0D7A =  3450          basic.asm:1794
NF       = $0000 =     0          basic.asm:107
NFERR    = $0503 =  1283          basic.asm:586
NMIFLG   = $2091 =  8337          basic.asm:61 (unused)
NOCHNG   = $06D1 =  1745          basic.asm:854
NOENED   = $1A10 =  6672          basic.asm:3819
NOLIN    = $09BA =  2490          basic.asm:1290
NOMADD   = $16D5 =  5845          basic.asm:3271
NOMLAD   = $18A6 =  6310          basic.asm:3601
NOPMPT   = $0C98 =  3224          basic.asm:1677
NORMAL   = $15C9 =  5577          basic.asm:3096
NOSPC    = $06C8 =  1736          basic.asm:849
NOSUB7   = $1D1B =  7451          basic.asm:4228
NOSWAP   = $1578 =  5496          basic.asm:3042
NOTAMP   = $0E76 =  3702          basic.asm:1933
NOTSTR   = $0FF0 =  4080          basic.asm:2163
NOXOR    = $1506 =  5382          basic.asm:2978
NSCFOR   = $1000 =  4096          basic.asm:2171
NULFLG   = $2089 =  8329          basic.asm:56
NULL     = $09DE =  2526          basic.asm:1309
NULLP    = $0C0E =  3086          basic.asm:1613
NULLS    = $2086 =  8326          basic.asm:53
NUMASC   = $1949 =  6473          basic.asm:3702
NXTARY   = $10B7 =  4279          basic.asm:2284
NXTBYT   = $06B7 =  1719          basic.asm:839
NXTCHR   = $06F8 =  1784          basic.asm:879
NXTDAT   = $2121 =  8481          basic.asm:94
NXTDTA   = $0AEB =  2795          basic.asm:1461
NXTITM   = $0CB2 =  3250          basic.asm:1693
NXTOPR   = $2115 =  8469          basic.asm:88
NXTSTL   = $0AF2 =  2802          basic.asm:1466
NXTSTT   = $0AF5 =  2805          basic.asm:1469
OD       = $0006 =     6          basic.asm:110
OKMSG    = $049A =  1178          basic.asm:520
OM       = $000C =    12          basic.asm:113
OMERR    = $04F2 =  1266          basic.asm:577
ON       = $0B5D =  2909          basic.asm:1527
ONGO     = $0B6C =  2924          basic.asm:1535
ONGOLP   = $0B6D =  2925          basic.asm:1536
ONJMP    = $093D =  2365          basic.asm:1207
OPNPAR   = $0DD0 =  3536          basic.asm:1843
OPRND    = $0E4B =  3659          basic.asm:1916
OS       = $001A =    26          basic.asm:120
OTKLN    = $0739 =  1849          basic.asm:918
OTPORT   = $204C =  8268          basic.asm:43
OUTC     = $07D6 =  2006          basic.asm:1002
OUTEXP   = $1A01 =  6657          basic.asm:3809
OUTIT    = $07B7 =  1975          basic.asm:980
OUTNBS   = $07BD =  1981          basic.asm:983
OUTNCR   = $1DAD =  7597          basic.asm:4337
OUTSUB   = $204B =  8267          basic.asm:42
OUTWRD   = $0859 =  2137          basic.asm:1078
OV       = $000A =    10          basic.asm:112
OVERR    = $050C =  1292          basic.asm:592
OVTST1   = $1780 =  6016          basic.asm:3391
OVTST2   = $1785 =  6021          basic.asm:3394
OVTST3   = $1786 =  6022          basic.asm:3395
PADD     = $1925 =  6437          basic.asm:3678
PAND     = $0F0C =  3852          basic.asm:2019
PASSA    = $118C =  4492          basic.asm:2421
PBUFF    = $212E =  8494          basic.asm:100
PEEK     = $1534 =  5428          basic.asm:3003
PEND     = $099F =  2463          basic.asm:1276
PHLTFP   = $17E2 =  6114          basic.asm:3454
PLUCDE   = $1603 =  5635          basic.asm:3138
PNORM    = $15D1 =  5585          basic.asm:3104
POINT    = $2096 =  8342          basic.asm:64
POKE     = $153B =  5435          basic.asm:3007
POPAF    = $12D0 =  4816          basic.asm:2614
POPHL    = $13FA =  5114          basic.asm:2805
POPHRT   = $16E5 =  5861          basic.asm:3285
POPNOK   = $0547 =  1351          basic.asm:619
POR      = $0F0B =  3851          basic.asm:2018
POR1     = $0F2E =  3886          basic.asm:2042
POS      = $1189 =  4489          basic.asm:2420
POSINT   = $09FE =  2558          basic.asm:1332
POUT     = $14EC =  5356          basic.asm:2966
POWER    = $1A46 =  6726          basic.asm:3848
POWER1   = $1A56 =  6742          basic.asm:3856
POWER2   = $1A73 =  6771          basic.asm:3874
POWERS   = $1A26 =  6694          basic.asm:3833
PRINT    = $0B9F =  2975          basic.asm:1560
PRITAB   = $03EF =  1007          basic.asm:423
PRNTCRLF = $0BFD =  3069          basic.asm:1606
PRNTHL   = $193E =  6462          basic.asm:3696
PRNTLP   = $0BA2 =  2978          basic.asm:1561
PRNTNB   = $0BE5 =  3045          basic.asm:1593
PRNTOK   = $0548 =  1352          basic.asm:621
PRNTST   = $0BE9 =  3049          basic.asm:1595
PRNUMS   = $129A =  4762          basic.asm:2583
PROCES   = $0764 =  1892          basic.asm:938
PROGND   = $211B =  8475          basic.asm:91
PROGST   = $213E =  8510          basic.asm:102
PROMPT   = $064C =  1612          basic.asm:782
PRS      = $129B =  4763          basic.asm:2584
PRS1     = $129E =  4766          basic.asm:2585
PRSLP    = $12A5 =  4773          basic.asm:2588
PSET     = $2099 =  8345          basic.asm:65
PSUB     = $1559 =  5465          basic.asm:3023
PTRLP    = $05D1 =  1489          basic.asm:699
PUTBUF   = $07A3 =  1955          basic.asm:969
PUTCTL   = $07A8 =  1960          basic.asm:971
PUTFID   = $0911 =  2321          basic.asm:1180
QTSTLP   = $1260 =  4704          basic.asm:2553
QTSTR    = $125A =  4698          basic.asm:2549
QUARTR   = $1BDF =  7135          basic.asm:4051
READ     = $0CAD =  3245          basic.asm:1690
READFG   = $2112 =  8466          basic.asm:86
REDO     = $0C5A =  3162          basic.asm:1655
REM      = $0AEE =  2798          basic.asm:1464
RESDIV   = $1732 =  5938          basic.asm:3336
RESEED   = $1B7D =  7037          basic.asm:4007
RESET    = $209C =  8348          basic.asm:66
RESTNL   = $097A =  2426          basic.asm:1246
RESTOR   = $0965 =  2405          basic.asm:1235
RESZER   = $15C4 =  5572          basic.asm:3092
RETADR   = $1067 =  4199          basic.asm:2231
RETINT   = $17BB =  6075          basic.asm:3427
RETLIN   = $0AE6 =  2790          basic.asm:1458
RETNAD   = $06DD =  1757          basic.asm:863
RETNUL   = $106A =  4202          basic.asm:2235
RETNUM   = $0EAD =  3757          basic.asm:1957
RETREL   = $17AD =  6061          basic.asm:3417
RETURN   = $0AC7 =  2759          basic.asm:1442
RG       = $0004 =     4          basic.asm:109
RIGHT    = $146D =  5229          basic.asm:2883
RIGHT1   = $1441 =  5185          basic.asm:2852
RINPUT   = $2093 =  8339          basic.asm:63
RLTLP    = $0DF0 =  3568          basic.asm:1859
RND      = $1B1C =  6940          basic.asm:3954
RND1     = $1B58 =  7000          basic.asm:3985
RND2     = $1B74 =  7028          basic.asm:4003
RNDTAB   = $1B85 =  7045          basic.asm:4014
RNGTST   = $1A13 =  6675          basic.asm:3823
RONDB    = $15E5 =  5605          basic.asm:3116
RONDUP   = $15E4 =  5604          basic.asm:3115
ROUND    = $154C =  5452          basic.asm:3017
RSCALE   = $191F =  6431          basic.asm:3676
RSLNBK   = $0893 =  2195          basic.asm:1110
RSTSTR   = $1490 =  5264          basic.asm:2903
RUN      = $0A8C =  2700          basic.asm:1409
RUNCNT   = $0915 =  2325          basic.asm:1184
RUNFST   = $0615 =  1557          basic.asm:754
RUNLIN   = $0AA8 =  2728          basic.asm:1425
SAVEXP   = $15C5 =  5573          basic.asm:3093
SAVSTP   = $0908 =  2312          basic.asm:1173
SAVSTR   = $1235 =  4661          basic.asm:2520
SBSCPT   = $1075 =  4213          basic.asm:2241
SCALE    = $1623 =  5667          basic.asm:3170
SCALLP   = $1625 =  5669          basic.asm:3171
SCALMI   = $18EA =  6378          basic.asm:3638
SCALPL   = $1900 =  6400          basic.asm:3652
SCNEND   = $136C =  4972          basic.asm:2710
SCPTLP   = $107B =  4219          basic.asm:2245
SEARCH   = $06A5 =  1701          basic.asm:825
SEED     = $205C =  8284          basic.asm:49
SETIO    = $1510 =  5392          basic.asm:2985
SETLIN   = $0867 =  2151          basic.asm:1086
SETLIT   = $06EF =  1775          basic.asm:875
SETPTR   = $05CC =  1484          basic.asm:696
SETTOP   = $01BC =   444          basic.asm:191
SFTPRG   = $0596 =  1430          basic.asm:659
SGN      = $17B3 =  6067          basic.asm:3424
SGNEXP   = $0EFB =  3835          basic.asm:2005
SGNRES   = $212D =  8493          basic.asm:99
SHRITE   = $1632 =  5682          basic.asm:3179
SHRLP    = $1635 =  5685          basic.asm:3181
SHRT1    = $1639 =  5689          basic.asm:3185
SIGNON   = $020C =   524          basic.asm:224
SIGNS    = $180A =  6154          basic.asm:3484
SIN      = $1B97 =  7063          basic.asm:4020
SIN1     = $1BC7 =  7111          basic.asm:4040
SINTAB   = $1BE3 =  7139          basic.asm:4053
SIXDIG   = $1966 =  6502          basic.asm:3716
SMPVAR   = $1300 =  4864          basic.asm:2638
SMSER1   = $1AFB =  6907          basic.asm:3932
SN       = $0002 =     2          basic.asm:108
SNERR    = $04FD =  1277          basic.asm:582
SPCFST   = $1957 =  6487          basic.asm:3708
SPCLP    = $0C4C =  3148          basic.asm:1648
SQR      = $1A3D =  6717          basic.asm:3844
SRCHLN   = $05E9 =  1513          basic.asm:718
SRCHLP   = $05EC =  1516          basic.asm:719
SSTSA    = $13C8 =  5064          basic.asm:2770
ST       = $001E =    30          basic.asm:122
STACK    = $20AB =  8363          basic.asm:71
STAKFP   = $17D5 =  6101          basic.asm:3444
STALL    = $098E =  2446          basic.asm:1263
STARTB   = $0156 =   342          basic.asm:133
STKTHS   = $0E34 =  3636          basic.asm:1900
STLOOK   = $21A2 =  8610          basic.asm:103
STOP     = $099D =  2461          basic.asm:1274
STORED   = $0A69 =  2665          basic.asm:1389
STPOOL   = $1343 =  4931          basic.asm:2675
STR      = $1225 =  4645          basic.asm:2513
STR1     = $122B =  4651          basic.asm:2515
STRADD   = $1346 =  4934          basic.asm:2677
STRBOT   = $2108 =  8456          basic.asm:80
STRENT   = $0D04 =  3332          basic.asm:1737
STRSPC   = $209F =  8351          basic.asm:67
STTLIN   = $0BF0 =  3056          basic.asm:1599
SUBCDE   = $155B =  5467          basic.asm:3025
SUBPHL   = $1555 =  5461          basic.asm:3021
SUMLP    = $1B04 =  6916          basic.asm:3937
SUMSER   = $1AEC =  6892          basic.asm:3925
SUPTLZ   = $19E5 =  6629          basic.asm:3793
SVNAM2   = $0FD4 =  4052          basic.asm:2150
SVSTAD   = $1253 =  4691          basic.asm:2541
TAN      = $1BF8 =  7160          basic.asm:4060
TESTOS   = $12D2 =  4818          basic.asm:2617
TESTR    = $12B4 =  4788          basic.asm:2597
TM       = $0018 =    24          basic.asm:119
TMERR    = $050F =  1295          basic.asm:594
TMPSTR   = $2104 =  8452          basic.asm:79
TMSTPL   = $20F8 =  8440          basic.asm:78
TMSTPT   = $20F6 =  8438          basic.asm:77
TOPOOL   = $1439 =  5177          basic.asm:2847
TOSTRA   = $13D1 =  5073          basic.asm:2779
TRYAGN   = $19C0 =  6592          basic.asm:3766
TSALP    = $13D2 =  5074          basic.asm:2780
TSTBIT   = $1DA6 =  7590          basic.asm:4330 (unused)
TSTBRK   = $0980 =  2432          basic.asm:1252
TSTMEM   = $01AA =   426          basic.asm:179
TSTNUM   = $0DC5 =  3525          basic.asm:1835
TSTOPL   = $127B =  4731          basic.asm:2569
TSTRED   = $0F33 =  3891          basic.asm:2048
TSTREM   = $06F2 =  1778          basic.asm:876
TSTSGN   = $17A4 =  6052          basic.asm:3412
TSTSTR   = $0DC6 =  3526          basic.asm:1836
TTYLIN   = $0742 =  1858          basic.asm:923
TYPE     = $20F2 =  8434          basic.asm:74
UF       = $0022 =    34          basic.asm:124
UFERR    = $0509 =  1289          basic.asm:590
UL       = $000E =    14          basic.asm:114
ULERR    = $0AC2 =  2754          basic.asm:1439
UNITY    = $1647 =  5703          basic.asm:3198
UPDATA   = $097B =  2427          basic.asm:1247
USR      = $2048 =  8264          basic.asm:41
VAL      = $14A7 =  5287          basic.asm:2922
VAL1     = $14C5 =  5317          basic.asm:2942
VAL2     = $14CF =  5327          basic.asm:2946
VAL3     = $14D2 =  5330          basic.asm:2947
VAREND   = $211D =  8477          basic.asm:92
WAIT     = $14F2 =  5362          basic.asm:2969
WAITLP   = $1507 =  5383          basic.asm:2979
WARM     = $0153 =   339          basic.asm:132 (unused)
WARMST   = $01F4 =   500          basic.asm:218
WIDTH    = $1C61 =  7265          basic.asm:4108
WORDS    = $0286 =   646          basic.asm:263
WORDTB   = $03A5 =   933          basic.asm:352
WRKSPC   = $2045 =  8261          basic.asm:40
ZDATA    = $0083 =   131          basic.asm:394
ZDIV     = $00AF =   175          basic.asm:412 (unused)
ZEND     = $0080 =   128          basic.asm:392
ZEQUAL   = $00B4 =   180          basic.asm:415
ZERARY   = $1116 =  4374          basic.asm:2344
ZERBYT   = $0499 =  1177          basic.asm:519
ZEROLP   = $1059 =  4185          basic.asm:2222
ZEROSUP  = $1D39 =  7481          basic.asm:4249
ZFN      = $00A7 =   167          basic.asm:403
ZFOR     = $0081 =   129          basic.asm:393
ZGOSUB   = $008C =   140          basic.asm:396
ZGOTO    = $0088 =   136          basic.asm:395
ZGTR     = $00B3 =   179          basic.asm:414
ZLEFT    = $00CF =   207          basic.asm:419
ZLTH     = $00B5 =   181          basic.asm:416
ZMINUS   = $00AD =   173          basic.asm:410
ZNEW     = $00A4 =   164          basic.asm:399
ZNOT     = $00AA =   170          basic.asm:406
ZONELP   = $0C27 =  3111          basic.asm:1627
ZOR      = $00B2 =   178          basic.asm:413
ZPLUS    = $00AC =   172          basic.asm:409
ZPOINT   = $00C7 =   199          basic.asm:418 (unused)
ZPRINT   = $009E =   158          basic.asm:398
ZREM     = $008E =   142          basic.asm:397
ZSGN     = $00B6 =   182          basic.asm:417
ZSPC     = $00A8 =   168          basic.asm:404
ZSTEP    = $00AB =   171          basic.asm:407
ZTAB     = $00A5 =   165          basic.asm:401
ZTHEN    = $00A9 =   169          basic.asm:405
ZTIMES   = $00AE =   174          basic.asm:411 (unused)
ZTO      = $00A6 =   166          basic.asm:402
_end     = $1DB3 =  7603          basic.asm:128 (unused)
_size    = $1C63 =  7267          basic.asm:128 (unused)


total time: 0.0456 sec.
no errors
