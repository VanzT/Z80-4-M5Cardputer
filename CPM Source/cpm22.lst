                        ; --------------------------------------
                        ; zasm: assemble "cpm22.asm"
                        ; date: 2021-05-18 16:36:28
                        ; --------------------------------------


                        ;**************************************************************
                        ;*
                        ;*             C P / M   version   2 . 2
                        ;*
                        ;*   Reconstructed from memory image on February 27, 1981
                        ;*
                        ;*                by Clark A. Calkins
                        ;*
                        ;**************************************************************
                        ;
                        ;   Set memory limit here. This is the amount of contigeous
                        ; ram starting from 0000. CP/M will reside at the end of this space.
                        ;
                        
0003:                   IOBYTE	.EQU	3		;i/o definition byte.
0004:                   TDRIVE	.EQU	4		;current drive name and user number.
0005:                   ENTRY	.EQU	5		;entry point for the cp/m bdos.
005C:                   TFCB	.EQU	5CH		;default file control block.
0080:                   TBUFF	.EQU	80H		;i/o buffer and command line storage.
0100:                   TBASE	.EQU	100H		;transiant program storage area.
                        ;
                        ;   Set control character equates.
                        ;
0003:                   CNTRLC	.EQU	3		;control-c
0005:                   CNTRLE	.EQU	05H		;control-e
0008:                   BS	.EQU	08H		;backspace
0009:                   TAB	.EQU	09H		;tab
000A:                   LF	.EQU	0AH		;line feed
000C:                   FF	.EQU	0CH		;form feed
000D:                   CR	.EQU	0DH		;carriage return
0010:                   CNTRLP	.EQU	10H		;control-p
0012:                   CNTRLR	.EQU	12H		;control-r
0013:                   CNTRLS	.EQU	13H		;control-s
0015:                   CNTRLU	.EQU	15H		;control-u
0018:                   CNTRLX	.EQU	18H		;control-x
001A:                   CNTRLZ	.EQU	1AH		;control-z (end-of-file mark)
007F:                   DEL	.EQU	7FH		;rubout
                        ;
                        ;   Set origin for CP/M
                        ;
D000:                   	.ORG	0D000H
                        ;
D000: C35CD3   [10]     CBASE:	JP	COMMAND		;execute command processor (ccp).
D003: C358D3   [20]     	JP	CLEARBUF	;entry to empty input buffer before starting ccp.
                        
                        ;
                        ;   Standard cp/m ccp input buffer. Format is (max length),
                        ; (actual length), (char #1), (char #2), (char #3), etc.
                        ;
D006: 7F                INBUFF:	.DB	127		;length of input buffer.
D007: 00                	.DB	0		;current length of contents.
D008: 436F7079          	.TEXT	"Copyright"
D00C: 72696768          
D010: 74                
D011: 20313937          	.TEXT	" 1979 (c) by Digital Research      "
D015: 39202863          
D019: 29206279          
D01D: 20446967          
D021: 6974616C          
D025: 20526573          
D029: 65617263          
D02D: 68202020          
D031: 202020            
D034: 00000000          	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D038: 00...             
D04B: 00000000          	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D04F: 00...             
D062: 00000000          	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D066: 00...             
D079: 00000000          	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D07D: 00...             
D088: 08D0              INPOINT:.DW	INBUFF+2	;input line pointer
D08A: 0000              NAMEPNT:.DW	0		;input line pointer used for error message. Points to
                        ;			;start of name in error.
                        ;
                        ;   Routine to print (A) on the console. All registers used.
                        ;
D08C: 5F       [ 4]     PRINT:	LD	E,A		;setup bdos call.
D08D: 0E02     [11]     	LD	C,2
D08F: C30500   [21]     	JP	ENTRY
                        ;
                        ;   Routine to print (A) on the console and to save (BC).
                        ;
D092: C5       [11]     PRINTB:	PUSH	BC
D093: CD8CD0   [28]     	CALL	PRINT
D096: C1       [38]     	POP	BC
D097: C9       [48]     	RET	
                        ;
                        ;   Routine to send a carriage return, line feed combination
                        ; to the console.
                        ;
D098: 3E0D     [ 7]     CRLF:	LD	A,CR
D09A: CD92D0   [24]     	CALL	PRINTB
D09D: 3E0A     [31]     	LD	A,LF
D09F: C392D0   [41]     	JP	PRINTB
                        ;
                        ;   Routine to send one space to the console and save (BC).
                        ;
D0A2: 3E20     [ 7]     SPACE:	LD	A,' '
D0A4: C392D0   [17]     	JP	PRINTB
                        ;
                        ;   Routine to print character string pointed to be (BC) on the
                        ; console. It must terminate with a null byte.
                        ;
D0A7: C5       [11]     PLINE:	PUSH	BC
D0A8: CD98D0   [28]     	CALL	CRLF
D0AB: E1       [38]     	POP	HL
D0AC: 7E       [ 7]     PLINE2:	LD	A,(HL)
D0AD: B7       [11]     	OR	A
D0AE: C8       [16|22]  	RET	Z
D0AF: 23       [22]     	INC	HL
D0B0: E5       [33]     	PUSH	HL
D0B1: CD8CD0   [50]     	CALL	PRINT
D0B4: E1       [60]     	POP	HL
D0B5: C3ACD0   [70]     	JP	PLINE2
                        ;
                        ;   Routine to reset the disk system.
                        ;
D0B8: 0E0D     [ 7]     RESDSK:	LD	C,13
D0BA: C30500   [17]     	JP	ENTRY
                        ;
                        ;   Routine to select disk (A).
                        ;
D0BD: 5F       [ 4]     DSKSEL:	LD	E,A
D0BE: 0E0E     [11]     	LD	C,14
D0C0: C30500   [21]     	JP	ENTRY
                        ;
                        ;   Routine to call bdos and save the return code. The zero
                        ; flag is set on a return of 0ffh.
                        ;
D0C3: CD0500   [17]     ENTRY1:	CALL	ENTRY
D0C6: 32EED7   [30]     	LD	(RTNCODE),A	;save return code.
D0C9: 3C       [34]     	INC	A		;set zero if 0ffh returned.
D0CA: C9       [44]     	RET	
                        ;
                        ;   Routine to open a file. (DE) must point to the FCB.
                        ;
D0CB: 0E0F     [ 7]     OPEN:	LD	C,15
D0CD: C3C3D0   [17]     	JP	ENTRY1
                        ;
                        ;   Routine to open file at (FCB).
                        ;
D0D0: AF       [ 4]     OPENFCB:XOR	A		;clear the record number byte at fcb+32
D0D1: 32EDD7   [17]     	LD	(FCB+32),A
D0D4: 11CDD7   [27]     	LD	DE,FCB
D0D7: C3CBD0   [37]     	JP	OPEN
                        ;
                        ;   Routine to close a file. (DE) points to FCB.
                        ;
D0DA: 0E10     [ 7]     CLOSE:	LD	C,16
D0DC: C3C3D0   [17]     	JP	ENTRY1
                        ;
                        ;   Routine to search for the first file with ambigueous name
                        ; (DE).
                        ;
D0DF: 0E11     [ 7]     SRCHFST:LD	C,17
D0E1: C3C3D0   [17]     	JP	ENTRY1
                        ;
                        ;   Search for the next ambigeous file name.
                        ;
D0E4: 0E12     [ 7]     SRCHNXT:LD	C,18
D0E6: C3C3D0   [17]     	JP	ENTRY1
                        ;
                        ;   Search for file at (FCB).
                        ;
D0E9: 11CDD7   [10]     SRCHFCB:LD	DE,FCB
D0EC: C3DFD0   [20]     	JP	SRCHFST
                        ;
                        ;   Routine to delete a file pointed to by (DE).
                        ;
D0EF: 0E13     [ 7]     DELETE:	LD	C,19
D0F1: C30500   [17]     	JP	ENTRY
                        ;
                        ;   Routine to call the bdos and set the zero flag if a zero
                        ; status is returned.
                        ;
D0F4: CD0500   [17]     ENTRY2:	CALL	ENTRY
D0F7: B7       [21]     	OR	A		;set zero flag if appropriate.
D0F8: C9       [31]     	RET	
                        ;
                        ;   Routine to read the next record from a sequential file.
                        ; (DE) points to the FCB.
                        ;
D0F9: 0E14     [ 7]     RDREC:	LD	C,20
D0FB: C3F4D0   [17]     	JP	ENTRY2
                        ;
                        ;   Routine to read file at (FCB).
                        ;
D0FE: 11CDD7   [10]     READFCB:LD	DE,FCB
D101: C3F9D0   [20]     	JP	RDREC
                        ;
                        ;   Routine to write the next record of a sequential file.
                        ; (DE) points to the FCB.
                        ;
D104: 0E15     [ 7]     WRTREC:	LD	C,21
D106: C3F4D0   [17]     	JP	ENTRY2
                        ;
                        ;   Routine to create the file pointed to by (DE).
                        ;
D109: 0E16     [ 7]     CREATE:	LD	C,22
D10B: C3C3D0   [17]     	JP	ENTRY1
                        ;
                        ;   Routine to rename the file pointed to by (DE). Note that
                        ; the new name starts at (DE+16).
                        ;
D10E: 0E17     [ 7]     RENAM:	LD	C,23
D110: C30500   [17]     	JP	ENTRY
                        ;
                        ;   Get the current user code.
                        ;
D113: 1EFF     [ 7]     GETUSR:	LD	E,0FFH
                        ;
                        ;   Routne to get or set the current user code.
                        ; If (E) is FF then this is a GET, else it is a SET.
                        ;
D115: 0E20     [ 7]     GETSETUC: LD	C,32
D117: C30500   [17]     	JP	ENTRY
                        ;
                        ;   Routine to set the current drive byte at (TDRIVE).
                        ;
D11A: CD13D1   [17]     SETCDRV:CALL	GETUSR		;get user number
D11D: 87       [21]     	ADD	A,A		;and shift into the upper 4 bits.
D11E: 87       [25]     	ADD	A,A
D11F: 87       [29]     	ADD	A,A
D120: 87       [33]     	ADD	A,A
D121: 21EFD7   [43]     	LD	HL,CDRIVE	;now add in the current drive number.
D124: B6       [50]     	OR	(HL)
D125: 320400   [63]     	LD	(TDRIVE),A	;and save.
D128: C9       [73]     	RET	
                        ;
                        ;   Move currently active drive down to (TDRIVE).
                        ;
D129: 3AEFD7   [13]     MOVECD:	LD	A,(CDRIVE)
D12C: 320400   [26]     	LD	(TDRIVE),A
D12F: C9       [36]     	RET	
                        ;
                        ;   Routine to convert (A) into upper case ascii. Only letters
                        ; are affected.
                        ;
D130: FE61     [ 7]     UPPER:	CP	'a'		;check for letters in the range of 'a' to 'z'.
D132: D8       [12|18]  	RET	C
D133: FE7B     [19]     	CP	'{'
D135: D0       [24|30]  	RET	NC
D136: E65F     [31]     	AND	5FH		;convert it if found.
D138: C9       [41]     	RET	
                        ;
                        ;   Routine to get a line of input. We must check to see if the
                        ; user is in (BATCH) mode. If so, then read the input from file
                        ; ($$$.SUB). At the end, reset to console input.
                        ;
D139: 3AABD7   [13]     GETINP:	LD	A,(BATCH)	;if =0, then use console input.
D13C: B7       [17]     	OR	A
D13D: CA96D1   [27|27]  	JP	Z,GETINP1
                        ;
                        ;   Use the submit file ($$$.sub) which is prepared by a
                        ; SUBMIT run. It must be on drive (A) and it will be deleted
                        ; if and error occures (like eof).
                        ;
D140: 3AEFD7   [40]     	LD	A,(CDRIVE)	;select drive 0 if need be.
D143: B7       [44]     	OR	A
D144: 3E00     [51]     	LD	A,0		;always use drive A for submit.
D146: C4BDD0   [61|68]  	CALL	NZ,DSKSEL	;select it if required.
D149: 11ACD7   [71]     	LD	DE,BATCHFCB
D14C: CDCBD0   [88]     	CALL	OPEN		;look for it.
D14F: CA96D1   [98|98]  	JP	Z,GETINP1	;if not there, use normal input.
D152: 3ABBD7   [111]    	LD	A,(BATCHFCB+15)	;get last record number+1.
D155: 3D       [115]    	DEC	A
D156: 32CCD7   [128]    	LD	(BATCHFCB+32),A
D159: 11ACD7   [138]    	LD	DE,BATCHFCB
D15C: CDF9D0   [155]    	CALL	RDREC		;read last record.
D15F: C296D1   [165|165]	JP	NZ,GETINP1	;quit on end of file.
                        ;
                        ;   Move this record into input buffer.
                        ;
D162: 1107D0   [175]    	LD	DE,INBUFF+1
D165: 218000   [185]    	LD	HL,TBUFF	;data was read into buffer here.
D168: 0680     [192]    	LD	B,128		;all 128 characters may be used.
D16A: CD42D4   [209]    	CALL	HL2DE		;(HL) to (DE), (B) bytes.
D16D: 21BAD7   [219]    	LD	HL,BATCHFCB+14
D170: 3600     [229]    	LD	(HL),0		;zero out the 's2' byte.
D172: 23       [235]    	INC	HL		;and decrement the record count.
D173: 35       [246]    	DEC	(HL)
D174: 11ACD7   [256]    	LD	DE,BATCHFCB	;close the batch file now.
D177: CDDAD0   [273]    	CALL	CLOSE
D17A: CA96D1   [283|283]	JP	Z,GETINP1	;quit on an error.
D17D: 3AEFD7   [296]    	LD	A,(CDRIVE)	;re-select previous drive if need be.
D180: B7       [300]    	OR	A
D181: C4BDD0   [310|317]	CALL	NZ,DSKSEL	;don't do needless selects.
                        ;
                        ;   Print line just read on console.
                        ;
D184: 2108D0   [320]    	LD	HL,INBUFF+2
D187: CDACD0   [337]    	CALL	PLINE2
D18A: CDC2D1   [354]    	CALL	CHKCON		;check console, quit on a key.
D18D: CAA7D1   [364|364]	JP	Z,GETINP2	;jump if no key is pressed.
                        ;
                        ;   Terminate the submit job on any keyboard input. Delete this
                        ; file such that it is not re-started and jump to normal keyboard
                        ; input section.
                        ;
D190: CDDDD1   [381]    	CALL	DELBATCH	;delete the batch file.
D193: C382D3   [391]    	JP	CMMND1		;and restart command input.
                        ;
                        ;   Get here for normal keyboard input. Delete the submit file
                        ; incase there was one.
                        ;
D196: CDDDD1   [17]     GETINP1:CALL	DELBATCH	;delete file ($$$.sub).
D199: CD1AD1   [34]     	CALL	SETCDRV		;reset active disk.
D19C: 0E0A     [41]     	LD	C,10		;get line from console device.
D19E: 1106D0   [51]     	LD	DE,INBUFF
D1A1: CD0500   [68]     	CALL	ENTRY
D1A4: CD29D1   [85]     	CALL	MOVECD		;reset current drive (again).
                        ;
                        ;   Convert input line to upper case.
                        ;
D1A7: 2107D0   [10]     GETINP2:LD	HL,INBUFF+1
D1AA: 46       [17]     	LD	B,(HL)		;(B)=character counter.
D1AB: 23       [ 6]     GETINP3:INC	HL
D1AC: 78       [10]     	LD	A,B		;end of the line?
D1AD: B7       [14]     	OR	A
D1AE: CABAD1   [24|24]  	JP	Z,GETINP4
D1B1: 7E       [31]     	LD	A,(HL)		;convert to upper case.
D1B2: CD30D1   [48]     	CALL	UPPER
D1B5: 77       [55]     	LD	(HL),A
D1B6: 05       [59]     	DEC	B		;adjust character count.
D1B7: C3ABD1   [69]     	JP	GETINP3
D1BA: 77       [ 7]     GETINP4:LD	(HL),A		;add trailing null.
D1BB: 2108D0   [17]     	LD	HL,INBUFF+2
D1BE: 2288D0   [33]     	LD	(INPOINT),HL	;reset input line pointer.
D1C1: C9       [43]     	RET	
                        ;
                        ;   Routine to check the console for a key pressed. The zero
                        ; flag is set is none, else the character is returned in (A).
                        ;
D1C2: 0E0B     [ 7]     CHKCON:	LD	C,11		;check console.
D1C4: CD0500   [24]     	CALL	ENTRY
D1C7: B7       [28]     	OR	A
D1C8: C8       [33|39]  	RET	Z		;return if nothing.
D1C9: 0E01     [40]     	LD	C,1		;else get character.
D1CB: CD0500   [57]     	CALL	ENTRY
D1CE: B7       [61]     	OR	A		;clear zero flag and return.
D1CF: C9       [71]     	RET	
                        ;
                        ;   Routine to get the currently active drive number.
                        ;
D1D0: 0E19     [ 7]     GETDSK:	LD	C,25
D1D2: C30500   [17]     	JP	ENTRY
                        ;
                        ;   Set the stabdard dma address.
                        ;
D1D5: 118000   [10]     STDDMA:	LD	DE,TBUFF
                        ;
                        ;   Routine to set the dma address to (DE).
                        ;
D1D8: 0E1A     [ 7]     DMASET:	LD	C,26
D1DA: C30500   [17]     	JP	ENTRY
                        ;
                        ;  Delete the batch file created by SUBMIT.
                        ;
D1DD: 21ABD7   [10]     DELBATCH: LD	HL,BATCH	;is batch active?
D1E0: 7E       [17]     	LD	A,(HL)
D1E1: B7       [21]     	OR	A
D1E2: C8       [26|32]  	RET	Z
D1E3: 3600     [36]     	LD	(HL),0		;yes, de-activate it.
D1E5: AF       [40]     	XOR	A
D1E6: CDBDD0   [57]     	CALL	DSKSEL		;select drive 0 for sure.
D1E9: 11ACD7   [67]     	LD	DE,BATCHFCB	;and delete this file.
D1EC: CDEFD0   [84]     	CALL	DELETE
D1EF: 3AEFD7   [97]     	LD	A,(CDRIVE)	;reset current drive.
D1F2: C3BDD0   [107]    	JP	DSKSEL
                        ;
                        ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
                        ; the same or we halt....
                        ;
D1F5: 1128D3   [10]     VERIFY:	LD	DE,PATTRN1	;these are the serial number bytes.
D1F8: 2100D8   [20]     	LD	HL,PATTRN2	;ditto, but how could they be different?
D1FB: 0606     [27]     	LD	B,6		;6 bytes each.
D1FD: 1A       [ 7]     VERIFY1:LD	A,(DE)
D1FE: BE       [14]     	CP	(HL)
D1FF: C2CFD3   [24|24]  	JP	NZ,HALT		;jump to halt routine.
D202: 13       [30]     	INC	DE
D203: 23       [36]     	INC	HL
D204: 05       [40]     	DEC	B
D205: C2FDD1   [50|50]  	JP	NZ,VERIFY1
D208: C9       [60]     	RET	
                        ;
                        ;   Print back file name with a '?' to indicate a syntax error.
                        ;
D209: CD98D0   [17]     SYNERR:	CALL	CRLF		;end current line.
D20C: 2A8AD0   [33]     	LD	HL,(NAMEPNT)	;this points to name in error.
D20F: 7E       [ 7]     SYNERR1:LD	A,(HL)		;print it until a space or null is found.
D210: FE20     [14]     	CP	' '
D212: CA22D2   [24|24]  	JP	Z,SYNERR2
D215: B7       [28]     	OR	A
D216: CA22D2   [38|38]  	JP	Z,SYNERR2
D219: E5       [49]     	PUSH	HL
D21A: CD8CD0   [66]     	CALL	PRINT
D21D: E1       [76]     	POP	HL
D21E: 23       [82]     	INC	HL
D21F: C30FD2   [92]     	JP	SYNERR1
D222: 3E3F     [ 7]     SYNERR2:LD	A,'?'		;add trailing '?'.
D224: CD8CD0   [24]     	CALL	PRINT
D227: CD98D0   [41]     	CALL	CRLF
D22A: CDDDD1   [58]     	CALL	DELBATCH	;delete any batch file.
D22D: C382D3   [68]     	JP	CMMND1		;and restart from console input.
                        ;
                        ;   Check character at (DE) for legal command input. Note that the
                        ; zero flag is set if the character is a delimiter.
                        ;
D230: 1A       [ 7]     CHECK:	LD	A,(DE)
D231: B7       [11]     	OR	A
D232: C8       [16|22]  	RET	Z
D233: FE20     [23]     	CP	' '		;control characters are not legal here.
D235: DA09D2   [33|33]  	JP	C,SYNERR
D238: C8       [38|44]  	RET	Z		;check for valid delimiter.
D239: FE3D     [45]     	CP	'='
D23B: C8       [50|56]  	RET	Z
D23C: FE5F     [57]     	CP	'_'
D23E: C8       [62|68]  	RET	Z
D23F: FE2E     [69]     	CP	'.'
D241: C8       [74|80]  	RET	Z
D242: FE3A     [81]     	CP	':'
D244: C8       [86|92]  	RET	Z
D245: FE3B     [93]     	CP	03BH ; ';'
D247: C8       [98|104] 	RET	Z
D248: FE3C     [105]    	CP	'<'
D24A: C8       [110|116]	RET	Z
D24B: FE3E     [117]    	CP	'>'
D24D: C8       [122|128]	RET	Z
D24E: C9       [132]    	RET	
                        ;
                        ;   Get the next non-blank character from (DE).
                        ;
D24F: 1A       [ 7]     NONBLANK: LD	A,(DE)
D250: B7       [11]     	OR	A		;string ends with a null.
D251: C8       [16|22]  	RET	Z
D252: FE20     [23]     	CP	' '
D254: C0       [28|34]  	RET	NZ
D255: 13       [34]     	INC	DE
D256: C34FD2   [44]     	JP	NONBLANK
                        ;
                        ;   Add (HL)=(HL)+(A)
                        ;
D259: 85       [ 4]     ADDHL:	ADD	A,L
D25A: 6F       [ 8]     	LD	L,A
D25B: D0       [13|19]  	RET	NC		;take care of any carry.
D25C: 24       [17]     	INC	H
D25D: C9       [27]     	RET	
                        ;
                        ;   Convert the first name in (FCB).
                        ;
D25E: 3E00     [ 7]     CONVFST:LD	A,0
                        ;
                        ;   Format a file name (convert * to '?', etc.). On return,
                        ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
                        ; the position within the fcb for the name (either 0 or 16).
                        ;
D260: 21CDD7   [10]     CONVERT:LD	HL,FCB
D263: CD59D2   [27]     	CALL	ADDHL
D266: E5       [38]     	PUSH	HL
D267: E5       [49]     	PUSH	HL
D268: AF       [53]     	XOR	A
D269: 32F0D7   [66]     	LD	(CHGDRV),A	;initialize drive change flag.
D26C: 2A88D0   [82]     	LD	HL,(INPOINT)	;set (HL) as pointer into input line.
D26F: EB       [86]     	EX	DE,HL
D270: CD4FD2   [103]    	CALL	NONBLANK	;get next non-blank character.
D273: EB       [107]    	EX	DE,HL
D274: 228AD0   [123]    	LD	(NAMEPNT),HL	;save pointer here for any error message.
D277: EB       [127]    	EX	DE,HL
D278: E1       [137]    	POP	HL
D279: 1A       [144]    	LD	A,(DE)		;get first character.
D27A: B7       [148]    	OR	A
D27B: CA89D2   [158|158]	JP	Z,CONVRT1
D27E: DE40     [165]    	SBC	A,'A'-1		;might be a drive name, convert to binary.
D280: 47       [169]    	LD	B,A		;and save.
D281: 13       [175]    	INC	DE		;check next character for a ':'.
D282: 1A       [182]    	LD	A,(DE)
D283: FE3A     [189]    	CP	':'
D285: CA90D2   [199|199]	JP	Z,CONVRT2
D288: 1B       [205]    	DEC	DE		;nope, move pointer back to the start of the line.
D289: 3AEFD7   [13]     CONVRT1:LD	A,(CDRIVE)
D28C: 77       [20]     	LD	(HL),A
D28D: C396D2   [30]     	JP	CONVRT3
D290: 78       [ 4]     CONVRT2:LD	A,B
D291: 32F0D7   [17]     	LD	(CHGDRV),A	;set change in drives flag.
D294: 70       [24]     	LD	(HL),B
D295: 13       [30]     	INC	DE
                        ;
                        ;   Convert the basic file name.
                        ;
D296: 0608     [ 7]     CONVRT3:LD	B,08H
D298: CD30D2   [17]     CONVRT4:CALL	CHECK
D29B: CAB9D2   [27|27]  	JP	Z,CONVRT8
D29E: 23       [33]     	INC	HL
D29F: FE2A     [40]     	CP	'*'		;note that an '*' will fill the remaining
D2A1: C2A9D2   [50|50]  	JP	NZ,CONVRT5	;field with '?'.
D2A4: 363F     [60]     	LD	(HL),'?'
D2A6: C3ABD2   [70]     	JP	CONVRT6
D2A9: 77       [ 7]     CONVRT5:LD	(HL),A
D2AA: 13       [13]     	INC	DE
D2AB: 05       [ 4]     CONVRT6:DEC	B
D2AC: C298D2   [14|14]  	JP	NZ,CONVRT4
D2AF: CD30D2   [17]     CONVRT7:CALL	CHECK		;get next delimiter.
D2B2: CAC0D2   [27|27]  	JP	Z,GETEXT
D2B5: 13       [33]     	INC	DE
D2B6: C3AFD2   [43]     	JP	CONVRT7
D2B9: 23       [ 6]     CONVRT8:INC	HL		;blank fill the file name.
D2BA: 3620     [16]     	LD	(HL),' '
D2BC: 05       [20]     	DEC	B
D2BD: C2B9D2   [30|30]  	JP	NZ,CONVRT8
                        ;
                        ;   Get the extension and convert it.
                        ;
D2C0: 0603     [ 7]     GETEXT:	LD	B,03H
D2C2: FE2E     [14]     	CP	'.'
D2C4: C2E9D2   [24|24]  	JP	NZ,GETEXT5
D2C7: 13       [30]     	INC	DE
D2C8: CD30D2   [17]     GETEXT1:CALL	CHECK
D2CB: CAE9D2   [27|27]  	JP	Z,GETEXT5
D2CE: 23       [33]     	INC	HL
D2CF: FE2A     [40]     	CP	'*'
D2D1: C2D9D2   [50|50]  	JP	NZ,GETEXT2
D2D4: 363F     [60]     	LD	(HL),'?'
D2D6: C3DBD2   [70]     	JP	GETEXT3
D2D9: 77       [ 7]     GETEXT2:LD	(HL),A
D2DA: 13       [13]     	INC	DE
D2DB: 05       [ 4]     GETEXT3:DEC	B
D2DC: C2C8D2   [14|14]  	JP	NZ,GETEXT1
D2DF: CD30D2   [17]     GETEXT4:CALL	CHECK
D2E2: CAF0D2   [27|27]  	JP	Z,GETEXT6
D2E5: 13       [33]     	INC	DE
D2E6: C3DFD2   [43]     	JP	GETEXT4
D2E9: 23       [ 6]     GETEXT5:INC	HL
D2EA: 3620     [16]     	LD	(HL),' '
D2EC: 05       [20]     	DEC	B
D2ED: C2E9D2   [30|30]  	JP	NZ,GETEXT5
D2F0: 0603     [ 7]     GETEXT6:LD	B,3
D2F2: 23       [ 6]     GETEXT7:INC	HL
D2F3: 3600     [16]     	LD	(HL),0
D2F5: 05       [20]     	DEC	B
D2F6: C2F2D2   [30|30]  	JP	NZ,GETEXT7
D2F9: EB       [34]     	EX	DE,HL
D2FA: 2288D0   [50]     	LD	(INPOINT),HL	;save input line pointer.
D2FD: E1       [60]     	POP	HL
                        ;
                        ;   Check to see if this is an ambigeous file name specification.
                        ; Set the (A) register to non zero if it is.
                        ;
D2FE: 010B00   [70]     	LD	BC,11		;set name length.
D301: 23       [ 6]     GETEXT8:INC	HL
D302: 7E       [13]     	LD	A,(HL)
D303: FE3F     [20]     	CP	'?'		;any question marks?
D305: C209D3   [30|30]  	JP	NZ,GETEXT9
D308: 04       [34]     	INC	B		;count them.
D309: 0D       [ 4]     GETEXT9:DEC	C
D30A: C201D3   [14|14]  	JP	NZ,GETEXT8
D30D: 78       [18]     	LD	A,B
D30E: B7       [22]     	OR	A
D30F: C9       [32]     	RET	
                        ;
                        ;   CP/M command table. Note commands can be either 3 or 4 characters long.
                        ;
0006:                   NUMCMDS .EQU	6		;number of commands
D310: 44495220          CMDTBL:	.TEXT	"DIR "
D314: 45524120          	.TEXT	"ERA "
D318: 54595045          	.TEXT	"TYPE"
D31C: 53415645          	.TEXT	"SAVE"
D320: 52454E20          	.TEXT	"REN "
D324: 55534552          	.TEXT	"USER"
                        ;
                        ;   The following six bytes must agree with those at (PATTRN2)
                        ; or cp/m will HALT. Why?
                        ;
D328: 00160000          PATTRN1:.DB	0,22,0,0,0,0	;(* serial number bytes *).
D32C: 0000              
                        ;
                        ;   Search the command table for a match with what has just
                        ; been entered. If a match is found, then we jump to the
                        ; proper section. Else jump to (UNKNOWN).
                        ; On return, the (C) register is set to the command number
                        ; that matched (or NUMCMDS+1 if no match).
                        ;
D32E: 2110D3   [10]     SEARCH:	LD	HL,CMDTBL
D331: 0E00     [17]     	LD	C,0
D333: 79       [ 4]     SEARCH1:LD	A,C
D334: FE06     [11]     	CP	NUMCMDS		;this commands exists.
D336: D0       [16|22]  	RET	NC
D337: 11CED7   [26]     	LD	DE,FCB+1	;check this one.
D33A: 0604     [33]     	LD	B,4		;max command length.
D33C: 1A       [ 7]     SEARCH2:LD	A,(DE)
D33D: BE       [14]     	CP	(HL)
D33E: C24FD3   [24|24]  	JP	NZ,SEARCH3	;not a match.
D341: 13       [30]     	INC	DE
D342: 23       [36]     	INC	HL
D343: 05       [40]     	DEC	B
D344: C23CD3   [50|50]  	JP	NZ,SEARCH2
D347: 1A       [57]     	LD	A,(DE)		;allow a 3 character command to match.
D348: FE20     [64]     	CP	' '
D34A: C254D3   [74|74]  	JP	NZ,SEARCH4
D34D: 79       [78]     	LD	A,C		;set return register for this command.
D34E: C9       [88]     	RET	
D34F: 23       [ 6]     SEARCH3:INC	HL
D350: 05       [10]     	DEC	B
D351: C24FD3   [20|20]  	JP	NZ,SEARCH3
D354: 0C       [ 4]     SEARCH4:INC	C
D355: C333D3   [14]     	JP	SEARCH1
                        ;
                        ;   Set the input buffer to empty and then start the command
                        ; processor (ccp).
                        ;
D358: AF       [ 4]     CLEARBUF: XOR	A
D359: 3207D0   [17]     	LD	(INBUFF+1),A	;second byte is actual length.
                        ;
                        ;**************************************************************
                        ;*
                        ;*
                        ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
                        ;*
                        ;**************************************************************
                        ;*
D35C: 31ABD7   [10]     COMMAND:LD	SP,CCPSTACK	;setup stack area.
D35F: C5       [21]     	PUSH	BC		;note that (C) should be equal to:
D360: 79       [25]     	LD	A,C		;(uuuudddd) where 'uuuu' is the user number
D361: 1F       [29]     	RRA			;and 'dddd' is the drive number.
D362: 1F       [33]     	RRA	
D363: 1F       [37]     	RRA	
D364: 1F       [41]     	RRA	
D365: E60F     [48]     	AND	0FH		;isolate the user number.
D367: 5F       [52]     	LD	E,A
D368: CD15D1   [69]     	CALL	GETSETUC	;and set it.
D36B: CDB8D0   [86]     	CALL	RESDSK		;reset the disk system.
D36E: 32ABD7   [99]     	LD	(BATCH),A	;clear batch mode flag.
D371: C1       [109]    	POP	BC
D372: 79       [113]    	LD	A,C
D373: E60F     [120]    	AND	0FH		;isolate the drive number.
D375: 32EFD7   [133]    	LD	(CDRIVE),A	;and save.
D378: CDBDD0   [150]    	CALL	DSKSEL		;...and select.
D37B: 3A07D0   [163]    	LD	A,(INBUFF+1)
D37E: B7       [167]    	OR	A		;anything in input buffer already?
D37F: C298D3   [177|177]	JP	NZ,CMMND2	;yes, we just process it.
                        ;
                        ;   Entry point to get a command line from the console.
                        ;
D382: 31ABD7   [10]     CMMND1:	LD	SP,CCPSTACK	;set stack straight.
D385: CD98D0   [27]     	CALL	CRLF		;start a new line on the screen.
D388: CDD0D1   [44]     	CALL	GETDSK		;get current drive.
D38B: C641     [51]     	ADD	A,'A'
D38D: CD8CD0   [68]     	CALL	PRINT		;print current drive.
D390: 3E3E     [75]     	LD	A,'>'
D392: CD8CD0   [92]     	CALL	PRINT		;and add prompt.
D395: CD39D1   [109]    	CALL	GETINP		;get line from user.
                        ;
                        ;   Process command line here.
                        ;
D398: 118000   [10]     CMMND2:	LD	DE,TBUFF
D39B: CDD8D1   [27]     	CALL	DMASET		;set standard dma address.
D39E: CDD0D1   [44]     	CALL	GETDSK
D3A1: 32EFD7   [57]     	LD	(CDRIVE),A	;set current drive.
D3A4: CD5ED2   [74]     	CALL	CONVFST		;convert name typed in.
D3A7: C409D2   [84|91]  	CALL	NZ,SYNERR	;wild cards are not allowed.
D3AA: 3AF0D7   [97]     	LD	A,(CHGDRV)	;if a change in drives was indicated,
D3AD: B7       [101]    	OR	A		;then treat this as an unknown command
D3AE: C2A5D6   [111|111]	JP	NZ,UNKNOWN	;which gets executed.
D3B1: CD2ED3   [128]    	CALL	SEARCH		;else search command table for a match.
                        ;
                        ;   Note that an unknown command returns
                        ; with (A) pointing to the last address
                        ; in our table which is (UNKNOWN).
                        ;
D3B4: 21C1D3   [138]    	LD	HL,CMDADR	;now, look thru our address table for command (A).
D3B7: 5F       [142]    	LD	E,A		;set (DE) to command number.
D3B8: 1600     [149]    	LD	D,0
D3BA: 19       [160]    	ADD	HL,DE
D3BB: 19       [171]    	ADD	HL,DE		;(HL)=(CMDADR)+2*(command number).
D3BC: 7E       [178]    	LD	A,(HL)		;now pick out this address.
D3BD: 23       [184]    	INC	HL
D3BE: 66       [191]    	LD	H,(HL)
D3BF: 6F       [195]    	LD	L,A
D3C0: E9       [199]    	JP	(HL)		;now execute it.
                        ;
                        ;   CP/M command address table.
                        ;
D3C1: 77D41FD5          CMDADR:	.DW	DIRECT,ERASE,TYPE,SAVE
D3C5: 5DD5ADD5          
D3C9: 10D68ED6          	.DW	RENAME,USER,UNKNOWN
D3CD: A5D6              
                        ;
                        ;   Halt the system. Reason for this is unknown at present.
                        ;
D3CF: 21F376   [10]     HALT:	LD	HL,76F3H	;'DI HLT' instructions.
D3D2: 2200D0   [26]     	LD	(CBASE),HL
D3D5: 2100D0   [36]     	LD	HL,CBASE
D3D8: E9       [40]     	JP	(HL)
                        ;
                        ;   Read error while TYPEing a file.
                        ;
D3D9: 01DFD3   [10]     RDERROR:LD	BC,RDERR
D3DC: C3A7D0   [20]     	JP	PLINE
D3DF: 52656164          RDERR:	.TEXT	"Read error"
D3E3: 20657272          
D3E7: 6F72              
D3E9: 00                	.DB	0
                        ;
                        ;   Required file was not located.
                        ;
D3EA: 01F0D3   [10]     NONE:	LD	BC,NOFILE
D3ED: C3A7D0   [20]     	JP	PLINE
D3F0: 4E6F2066          NOFILE:	.TEXT	"No file"
D3F4: 696C65            
D3F7: 00                	.DB	0
                        ;
                        ;   Decode a command of the form 'A>filename number{ filename}.
                        ; Note that a drive specifier is not allowed on the first file
                        ; name. On return, the number is in register (A). Any error
                        ; causes 'filename?' to be printed and the command is aborted.
                        ;
D3F8: CD5ED2   [17]     DECODE:	CALL	CONVFST		;convert filename.
D3FB: 3AF0D7   [30]     	LD	A,(CHGDRV)	;do not allow a drive to be specified.
D3FE: B7       [34]     	OR	A
D3FF: C209D2   [44|44]  	JP	NZ,SYNERR
D402: 21CED7   [54]     	LD	HL,FCB+1	;convert number now.
D405: 010B00   [64]     	LD	BC,11		;(B)=sum register, (C)=max digit count.
D408: 7E       [ 7]     DECODE1:LD	A,(HL)
D409: FE20     [14]     	CP	' '		;a space terminates the numeral.
D40B: CA33D4   [24|24]  	JP	Z,DECODE3
D40E: 23       [30]     	INC	HL
D40F: D630     [37]     	SUB	'0'		;make binary from ascii.
D411: FE0A     [44]     	CP	10		;legal digit?
D413: D209D2   [54|54]  	JP	NC,SYNERR
D416: 57       [58]     	LD	D,A		;yes, save it in (D).
D417: 78       [62]     	LD	A,B		;compute (B)=(B)*10 and check for overflow.
D418: E6E0     [69]     	AND	0E0H
D41A: C209D2   [79|79]  	JP	NZ,SYNERR
D41D: 78       [83]     	LD	A,B
D41E: 07       [87]     	RLCA	
D41F: 07       [91]     	RLCA	
D420: 07       [95]     	RLCA			;(A)=(B)*8
D421: 80       [99]     	ADD	A,B		;.......*9
D422: DA09D2   [109|109]	JP	C,SYNERR
D425: 80       [113]    	ADD	A,B		;.......*10
D426: DA09D2   [123|123]	JP	C,SYNERR
D429: 82       [127]    	ADD	A,D		;add in new digit now.
D42A: DA09D2   [10|10]  DECODE2:JP	C,SYNERR
D42D: 47       [14]     	LD	B,A		;and save result.
D42E: 0D       [18]     	DEC	C		;only look at 11 digits.
D42F: C208D4   [28|28]  	JP	NZ,DECODE1
D432: C9       [38]     	RET	
D433: 7E       [ 7]     DECODE3:LD	A,(HL)		;spaces must follow (why?).
D434: FE20     [14]     	CP	' '
D436: C209D2   [24|24]  	JP	NZ,SYNERR
D439: 23       [30]     	INC	HL
D43A: 0D       [ 4]     DECODE4:DEC	C
D43B: C233D4   [14|14]  	JP	NZ,DECODE3
D43E: 78       [18]     	LD	A,B		;set (A)=the numeric value entered.
D43F: C9       [28]     	RET	
                        ;
                        ;   Move 3 bytes from (HL) to (DE). Note that there is only
                        ; one reference to this at (A2D5h).
                        ;
D440: 0603     [ 7]     MOVE3:	LD	B,3
                        ;
                        ;   Move (B) bytes from (HL) to (DE).
                        ;
D442: 7E       [ 7]     HL2DE:	LD	A,(HL)
D443: 12       [14]     	LD	(DE),A
D444: 23       [20]     	INC	HL
D445: 13       [26]     	INC	DE
D446: 05       [30]     	DEC	B
D447: C242D4   [40|40]  	JP	NZ,HL2DE
D44A: C9       [50]     	RET	
                        ;
                        ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
                        ;
D44B: 218000   [10]     EXTRACT:LD	HL,TBUFF
D44E: 81       [14]     	ADD	A,C
D44F: CD59D2   [31]     	CALL	ADDHL
D452: 7E       [38]     	LD	A,(HL)
D453: C9       [48]     	RET	
                        ;
                        ;  Check drive specified. If it means a change, then the new
                        ; drive will be selected. In any case, the drive byte of the
                        ; fcb will be set to null (means use current drive).
                        ;
D454: AF       [ 4]     DSELECT:XOR	A		;null out first byte of fcb.
D455: 32CDD7   [17]     	LD	(FCB),A
D458: 3AF0D7   [30]     	LD	A,(CHGDRV)	;a drive change indicated?
D45B: B7       [34]     	OR	A
D45C: C8       [39|45]  	RET	Z
D45D: 3D       [43]     	DEC	A		;yes, is it the same as the current drive?
D45E: 21EFD7   [53]     	LD	HL,CDRIVE
D461: BE       [60]     	CP	(HL)
D462: C8       [65|71]  	RET	Z
D463: C3BDD0   [75]     	JP	DSKSEL		;no. Select it then.
                        ;
                        ;   Check the drive selection and reset it to the previous
                        ; drive if it was changed for the preceeding command.
                        ;
D466: 3AF0D7   [13]     RESETDR:LD	A,(CHGDRV)	;drive change indicated?
D469: B7       [17]     	OR	A
D46A: C8       [22|28]  	RET	Z
D46B: 3D       [26]     	DEC	A		;yes, was it a different drive?
D46C: 21EFD7   [36]     	LD	HL,CDRIVE
D46F: BE       [43]     	CP	(HL)
D470: C8       [48|54]  	RET	Z
D471: 3AEFD7   [61]     	LD	A,(CDRIVE)	;yes, re-select our old drive.
D474: C3BDD0   [71]     	JP	DSKSEL
                        ;
                        ;**************************************************************
                        ;*
                        ;*           D I R E C T O R Y   C O M M A N D
                        ;*
                        ;**************************************************************
                        ;
D477: CD5ED2   [17]     DIRECT:	CALL	CONVFST		;convert file name.
D47A: CD54D4   [34]     	CALL	DSELECT		;select indicated drive.
D47D: 21CED7   [44]     	LD	HL,FCB+1	;was any file indicated?
D480: 7E       [51]     	LD	A,(HL)
D481: FE20     [58]     	CP	' '
D483: C28FD4   [68|68]  	JP	NZ,DIRECT2
D486: 060B     [75]     	LD	B,11		;no. Fill field with '?' - same as *.*.
D488: 363F     [10]     DIRECT1:LD	(HL),'?'
D48A: 23       [16]     	INC	HL
D48B: 05       [20]     	DEC	B
D48C: C288D4   [30|30]  	JP	NZ,DIRECT1
D48F: 1E00     [ 7]     DIRECT2:LD	E,0		;set initial cursor position.
D491: D5       [18]     	PUSH	DE
D492: CDE9D0   [35]     	CALL	SRCHFCB		;get first file name.
D495: CCEAD3   [45|52]  	CALL	Z,NONE		;none found at all?
D498: CA1BD5   [10|10]  DIRECT3:JP	Z,DIRECT9	;terminate if no more names.
D49B: 3AEED7   [23]     	LD	A,(RTNCODE)	;get file's position in segment (0-3).
D49E: 0F       [27]     	RRCA	
D49F: 0F       [31]     	RRCA	
D4A0: 0F       [35]     	RRCA	
D4A1: E660     [42]     	AND	60H		;(A)=position*32
D4A3: 4F       [46]     	LD	C,A
D4A4: 3E0A     [53]     	LD	A,10
D4A6: CD4BD4   [70]     	CALL	EXTRACT		;extract the tenth entry in fcb.
D4A9: 17       [74]     	RLA			;check system file status bit.
D4AA: DA0FD5   [84|84]  	JP	C,DIRECT8	;we don't list them.
D4AD: D1       [94]     	POP	DE
D4AE: 7B       [98]     	LD	A,E		;bump name count.
D4AF: 1C       [102]    	INC	E
D4B0: D5       [113]    	PUSH	DE
D4B1: E603     [120]    	AND	03H		;at end of line?
D4B3: F5       [131]    	PUSH	AF
D4B4: C2CCD4   [141|141]	JP	NZ,DIRECT4
D4B7: CD98D0   [158]    	CALL	CRLF		;yes, end this line and start another.
D4BA: C5       [169]    	PUSH	BC
D4BB: CDD0D1   [186]    	CALL	GETDSK		;start line with ('A:').
D4BE: C1       [196]    	POP	BC
D4BF: C641     [203]    	ADD	A,'A'
D4C1: CD92D0   [220]    	CALL	PRINTB
D4C4: 3E3A     [227]    	LD	A,':'
D4C6: CD92D0   [244]    	CALL	PRINTB
D4C9: C3D4D4   [254]    	JP	DIRECT5
D4CC: CDA2D0   [17]     DIRECT4:CALL	SPACE		;add seperator between file names.
D4CF: 3E3A     [24]     	LD	A,':'
D4D1: CD92D0   [41]     	CALL	PRINTB
D4D4: CDA2D0   [17]     DIRECT5:CALL	SPACE
D4D7: 0601     [24]     	LD	B,1		;'extract' each file name character at a time.
D4D9: 78       [ 4]     DIRECT6:LD	A,B
D4DA: CD4BD4   [21]     	CALL	EXTRACT
D4DD: E67F     [28]     	AND	7FH		;strip bit 7 (status bit).
D4DF: FE20     [35]     	CP	' '		;are we at the end of the name?
D4E1: C2F9D4   [45|45]  	JP	NZ,DRECT65
D4E4: F1       [55]     	POP	AF		;yes, don't print spaces at the end of a line.
D4E5: F5       [66]     	PUSH	AF
D4E6: FE03     [73]     	CP	3
D4E8: C2F7D4   [83|83]  	JP	NZ,DRECT63
D4EB: 3E09     [90]     	LD	A,9		;first check for no extension.
D4ED: CD4BD4   [107]    	CALL	EXTRACT
D4F0: E67F     [114]    	AND	7FH
D4F2: FE20     [121]    	CP	' '
D4F4: CA0ED5   [131|131]	JP	Z,DIRECT7	;don't print spaces.
D4F7: 3E20     [ 7]     DRECT63:LD	A,' '		;else print them.
D4F9: CD92D0   [17]     DRECT65:CALL	PRINTB
D4FC: 04       [21]     	INC	B		;bump to next character psoition.
D4FD: 78       [25]     	LD	A,B
D4FE: FE0C     [32]     	CP	12		;end of the name?
D500: D20ED5   [42|42]  	JP	NC,DIRECT7
D503: FE09     [49]     	CP	9		;nope, starting extension?
D505: C2D9D4   [59|59]  	JP	NZ,DIRECT6
D508: CDA2D0   [76]     	CALL	SPACE		;yes, add seperating space.
D50B: C3D9D4   [86]     	JP	DIRECT6
D50E: F1       [10]     DIRECT7:POP	AF		;get the next file name.
D50F: CDC2D1   [17]     DIRECT8:CALL	CHKCON		;first check console, quit on anything.
D512: C21BD5   [27|27]  	JP	NZ,DIRECT9
D515: CDE4D0   [44]     	CALL	SRCHNXT		;get next name.
D518: C398D4   [54]     	JP	DIRECT3		;and continue with our list.
D51B: D1       [10]     DIRECT9:POP	DE		;restore the stack and return to command level.
D51C: C386D7   [20]     	JP	GETBACK
                        ;
                        ;**************************************************************
                        ;*
                        ;*                E R A S E   C O M M A N D
                        ;*
                        ;**************************************************************
                        ;
D51F: CD5ED2   [17]     ERASE:	CALL	CONVFST		;convert file name.
D522: FE0B     [24]     	CP	11		;was '*.*' entered?
D524: C242D5   [34|34]  	JP	NZ,ERASE1
D527: 0152D5   [44]     	LD	BC,YESNO	;yes, ask for confirmation.
D52A: CDA7D0   [61]     	CALL	PLINE
D52D: CD39D1   [78]     	CALL	GETINP
D530: 2107D0   [88]     	LD	HL,INBUFF+1
D533: 35       [99]     	DEC	(HL)		;must be exactly 'y'.
D534: C282D3   [109|109]	JP	NZ,CMMND1
D537: 23       [115]    	INC	HL
D538: 7E       [122]    	LD	A,(HL)
D539: FE59     [129]    	CP	'Y'
D53B: C282D3   [139|139]	JP	NZ,CMMND1
D53E: 23       [145]    	INC	HL
D53F: 2288D0   [161]    	LD	(INPOINT),HL	;save input line pointer.
D542: CD54D4   [17]     ERASE1:	CALL	DSELECT		;select desired disk.
D545: 11CDD7   [27]     	LD	DE,FCB
D548: CDEFD0   [44]     	CALL	DELETE		;delete the file.
D54B: 3C       [48]     	INC	A
D54C: CCEAD3   [58|65]  	CALL	Z,NONE		;not there?
D54F: C386D7   [68]     	JP	GETBACK		;return to command level now.
D552: 416C6C20          YESNO:	.TEXT	"All (y/n)?"
D556: 28792F6E          
D55A: 293F              
D55C: 00                	.DB	0
                        ;
                        ;**************************************************************
                        ;*
                        ;*            T Y P E   C O M M A N D
                        ;*
                        ;**************************************************************
                        ;
D55D: CD5ED2   [17]     TYPE:	CALL	CONVFST		;convert file name.
D560: C209D2   [27|27]  	JP	NZ,SYNERR	;wild cards not allowed.
D563: CD54D4   [44]     	CALL	DSELECT		;select indicated drive.
D566: CDD0D0   [61]     	CALL	OPENFCB		;open the file.
D569: CAA7D5   [71|71]  	JP	Z,TYPE5		;not there?
D56C: CD98D0   [88]     	CALL	CRLF		;ok, start a new line on the screen.
D56F: 21F1D7   [98]     	LD	HL,NBYTES	;initialize byte counter.
D572: 36FF     [108]    	LD	(HL),0FFH	;set to read first sector.
D574: 21F1D7   [10]     TYPE1:	LD	HL,NBYTES
D577: 7E       [ 7]     TYPE2:	LD	A,(HL)		;have we written the entire sector?
D578: FE80     [14]     	CP	128
D57A: DA87D5   [24|24]  	JP	C,TYPE3
D57D: E5       [35]     	PUSH	HL		;yes, read in the next one.
D57E: CDFED0   [52]     	CALL	READFCB
D581: E1       [62]     	POP	HL
D582: C2A0D5   [72|72]  	JP	NZ,TYPE4	;end or error?
D585: AF       [76]     	XOR	A		;ok, clear byte counter.
D586: 77       [83]     	LD	(HL),A
D587: 34       [11]     TYPE3:	INC	(HL)		;count this byte.
D588: 218000   [21]     	LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF).
D58B: CD59D2   [38]     	CALL	ADDHL
D58E: 7E       [45]     	LD	A,(HL)
D58F: FE1A     [52]     	CP	CNTRLZ		;end of file mark?
D591: CA86D7   [62|62]  	JP	Z,GETBACK
D594: CD8CD0   [79]     	CALL	PRINT		;no, print it.
D597: CDC2D1   [96]     	CALL	CHKCON		;check console, quit if anything ready.
D59A: C286D7   [106|106]	JP	NZ,GETBACK
D59D: C374D5   [116]    	JP	TYPE1
                        ;
                        ;   Get here on an end of file or read error.
                        ;
D5A0: 3D       [ 4]     TYPE4:	DEC	A		;read error?
D5A1: CA86D7   [14|14]  	JP	Z,GETBACK
D5A4: CDD9D3   [31]     	CALL	RDERROR		;yes, print message.
D5A7: CD66D4   [17]     TYPE5:	CALL	RESETDR		;and reset proper drive
D5AA: C309D2   [27]     	JP	SYNERR		;now print file name with problem.
                        ;
                        ;**************************************************************
                        ;*
                        ;*            S A V E   C O M M A N D
                        ;*
                        ;**************************************************************
                        ;
D5AD: CDF8D3   [17]     SAVE:	CALL	DECODE		;get numeric number that follows SAVE.
D5B0: F5       [28]     	PUSH	AF		;save number of pages to write.
D5B1: CD5ED2   [45]     	CALL	CONVFST		;convert file name.
D5B4: C209D2   [55|55]  	JP	NZ,SYNERR	;wild cards not allowed.
D5B7: CD54D4   [72]     	CALL	DSELECT		;select specified drive.
D5BA: 11CDD7   [82]     	LD	DE,FCB		;now delete this file.
D5BD: D5       [93]     	PUSH	DE
D5BE: CDEFD0   [110]    	CALL	DELETE
D5C1: D1       [120]    	POP	DE
D5C2: CD09D1   [137]    	CALL	CREATE		;and create it again.
D5C5: CAFBD5   [147|147]	JP	Z,SAVE3		;can't create?
D5C8: AF       [151]    	XOR	A		;clear record number byte.
D5C9: 32EDD7   [164]    	LD	(FCB+32),A
D5CC: F1       [174]    	POP	AF		;convert pages to sectors.
D5CD: 6F       [178]    	LD	L,A
D5CE: 2600     [185]    	LD	H,0
D5D0: 29       [196]    	ADD	HL,HL		;(HL)=number of sectors to write.
D5D1: 110001   [206]    	LD	DE,TBASE	;and we start from here.
D5D4: 7C       [ 4]     SAVE1:	LD	A,H		;done yet?
D5D5: B5       [ 8]     	OR	L
D5D6: CAF1D5   [18|18]  	JP	Z,SAVE2
D5D9: 2B       [24]     	DEC	HL		;nope, count this and compute the start
D5DA: E5       [35]     	PUSH	HL		;of the next 128 byte sector.
D5DB: 218000   [45]     	LD	HL,128
D5DE: 19       [56]     	ADD	HL,DE
D5DF: E5       [67]     	PUSH	HL		;save it and set the transfer address.
D5E0: CDD8D1   [84]     	CALL	DMASET
D5E3: 11CDD7   [94]     	LD	DE,FCB		;write out this sector now.
D5E6: CD04D1   [111]    	CALL	WRTREC
D5E9: D1       [121]    	POP	DE		;reset (DE) to the start of the last sector.
D5EA: E1       [131]    	POP	HL		;restore sector count.
D5EB: C2FBD5   [141|141]	JP	NZ,SAVE3	;write error?
D5EE: C3D4D5   [151]    	JP	SAVE1
                        ;
                        ;   Get here after writing all of the file.
                        ;
D5F1: 11CDD7   [10]     SAVE2:	LD	DE,FCB		;now close the file.
D5F4: CDDAD0   [27]     	CALL	CLOSE
D5F7: 3C       [31]     	INC	A		;did it close ok?
D5F8: C201D6   [41|41]  	JP	NZ,SAVE4
                        ;
                        ;   Print out error message (no space).
                        ;
D5FB: 0107D6   [10]     SAVE3:	LD	BC,NOSPACE
D5FE: CDA7D0   [27]     	CALL	PLINE
D601: CDD5D1   [17]     SAVE4:	CALL	STDDMA		;reset the standard dma address.
D604: C386D7   [27]     	JP	GETBACK
D607: 4E6F2073          NOSPACE:.TEXT	"No space"
D60B: 70616365          
D60F: 00                	.DB	0
                        ;
                        ;**************************************************************
                        ;*
                        ;*           R E N A M E   C O M M A N D
                        ;*
                        ;**************************************************************
                        ;
D610: CD5ED2   [17]     RENAME:	CALL	CONVFST		;convert first file name.
D613: C209D2   [27|27]  	JP	NZ,SYNERR	;wild cards not allowed.
D616: 3AF0D7   [40]     	LD	A,(CHGDRV)	;remember any change in drives specified.
D619: F5       [51]     	PUSH	AF
D61A: CD54D4   [68]     	CALL	DSELECT		;and select this drive.
D61D: CDE9D0   [85]     	CALL	SRCHFCB		;is this file present?
D620: C279D6   [95|95]  	JP	NZ,RENAME6	;yes, print error message.
D623: 21CDD7   [105]    	LD	HL,FCB		;yes, move this name into second slot.
D626: 11DDD7   [115]    	LD	DE,FCB+16
D629: 0610     [122]    	LD	B,16
D62B: CD42D4   [139]    	CALL	HL2DE
D62E: 2A88D0   [155]    	LD	HL,(INPOINT)	;get input pointer.
D631: EB       [159]    	EX	DE,HL
D632: CD4FD2   [176]    	CALL	NONBLANK	;get next non blank character.
D635: FE3D     [183]    	CP	'='		;only allow an '=' or '_' seperator.
D637: CA3FD6   [193|193]	JP	Z,RENAME1
D63A: FE5F     [200]    	CP	'_'
D63C: C273D6   [210|210]	JP	NZ,RENAME5
D63F: EB       [ 4]     RENAME1:EX	DE,HL
D640: 23       [10]     	INC	HL		;ok, skip seperator.
D641: 2288D0   [26]     	LD	(INPOINT),HL	;save input line pointer.
D644: CD5ED2   [43]     	CALL	CONVFST		;convert this second file name now.
D647: C273D6   [53|53]  	JP	NZ,RENAME5	;again, no wild cards.
D64A: F1       [63]     	POP	AF		;if a drive was specified, then it
D64B: 47       [67]     	LD	B,A		;must be the same as before.
D64C: 21F0D7   [77]     	LD	HL,CHGDRV
D64F: 7E       [84]     	LD	A,(HL)
D650: B7       [88]     	OR	A
D651: CA59D6   [98|98]  	JP	Z,RENAME2
D654: B8       [102]    	CP	B
D655: 70       [109]    	LD	(HL),B
D656: C273D6   [119|119]	JP	NZ,RENAME5	;they were different, error.
D659: 70       [ 7]     RENAME2:LD	(HL),B		;	reset as per the first file specification.
D65A: AF       [11]     	XOR	A
D65B: 32CDD7   [24]     	LD	(FCB),A		;clear the drive byte of the fcb.
D65E: CDE9D0   [17]     RENAME3:CALL	SRCHFCB		;and go look for second file.
D661: CA6DD6   [27|27]  	JP	Z,RENAME4	;doesn't exist?
D664: 11CDD7   [37]     	LD	DE,FCB
D667: CD0ED1   [54]     	CALL	RENAM		;ok, rename the file.
D66A: C386D7   [64]     	JP	GETBACK
                        ;
                        ;   Process rename errors here.
                        ;
D66D: CDEAD3   [17]     RENAME4:CALL	NONE		;file not there.
D670: C386D7   [27]     	JP	GETBACK
D673: CD66D4   [17]     RENAME5:CALL	RESETDR		;bad command format.
D676: C309D2   [27]     	JP	SYNERR
D679: 0182D6   [10]     RENAME6:LD	BC,EXISTS	;destination file already exists.
D67C: CDA7D0   [27]     	CALL	PLINE
D67F: C386D7   [37]     	JP	GETBACK
D682: 46696C65          EXISTS:	.TEXT	"File exists"
D686: 20657869          
D68A: 737473            
D68D: 00                	.DB	0
                        ;
                        ;**************************************************************
                        ;*
                        ;*             U S E R   C O M M A N D
                        ;*
                        ;**************************************************************
                        ;
D68E: CDF8D3   [17]     USER:	CALL	DECODE		;get numeric value following command.
D691: FE10     [24]     	CP	16		;legal user number?
D693: D209D2   [34|34]  	JP	NC,SYNERR
D696: 5F       [38]     	LD	E,A		;yes but is there anything else?
D697: 3ACED7   [51]     	LD	A,(FCB+1)
D69A: FE20     [58]     	CP	' '
D69C: CA09D2   [68|68]  	JP	Z,SYNERR	;yes, that is not allowed.
D69F: CD15D1   [85]     	CALL	GETSETUC	;ok, set user code.
D6A2: C389D7   [95]     	JP	GETBACK1
                        ;
                        ;**************************************************************
                        ;*
                        ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
                        ;*
                        ;**************************************************************
                        ;
D6A5: CDF5D1   [17]     UNKNOWN:CALL	VERIFY		;check for valid system (why?).
D6A8: 3ACED7   [30]     	LD	A,(FCB+1)	;anything to execute?
D6AB: FE20     [37]     	CP	' '
D6AD: C2C4D6   [47|47]  	JP	NZ,UNKWN1
D6B0: 3AF0D7   [60]     	LD	A,(CHGDRV)	;nope, only a drive change?
D6B3: B7       [64]     	OR	A
D6B4: CA89D7   [74|74]  	JP	Z,GETBACK1	;neither???
D6B7: 3D       [78]     	DEC	A
D6B8: 32EFD7   [91]     	LD	(CDRIVE),A	;ok, store new drive.
D6BB: CD29D1   [108]    	CALL	MOVECD		;set (TDRIVE) also.
D6BE: CDBDD0   [125]    	CALL	DSKSEL		;and select this drive.
D6C1: C389D7   [135]    	JP	GETBACK1	;then return.
                        ;
                        ;   Here a file name was typed. Prepare to execute it.
                        ;
D6C4: 11D6D7   [10]     UNKWN1:	LD	DE,FCB+9	;an extension specified?
D6C7: 1A       [17]     	LD	A,(DE)
D6C8: FE20     [24]     	CP	' '
D6CA: C209D2   [34|34]  	JP	NZ,SYNERR	;yes, not allowed.
D6CD: D5       [11]     UNKWN2:	PUSH	DE
D6CE: CD54D4   [28]     	CALL	DSELECT		;select specified drive.
D6D1: D1       [38]     	POP	DE
D6D2: 2183D7   [48]     	LD	HL,COMFILE	;set the extension to 'COM'.
D6D5: CD40D4   [65]     	CALL	MOVE3
D6D8: CDD0D0   [82]     	CALL	OPENFCB		;and open this file.
D6DB: CA6BD7   [92|92]  	JP	Z,UNKWN9	;not present?
                        ;
                        ;   Load in the program.
                        ;
D6DE: 210001   [102]    	LD	HL,TBASE	;store the program starting here.
D6E1: E5       [11]     UNKWN3:	PUSH	HL
D6E2: EB       [15]     	EX	DE,HL
D6E3: CDD8D1   [32]     	CALL	DMASET		;set transfer address.
D6E6: 11CDD7   [42]     	LD	DE,FCB		;and read the next record.
D6E9: CDF9D0   [59]     	CALL	RDREC
D6EC: C201D7   [69|69]  	JP	NZ,UNKWN4	;end of file or read error?
D6EF: E1       [79]     	POP	HL		;nope, bump pointer for next sector.
D6F0: 118000   [89]     	LD	DE,128
D6F3: 19       [100]    	ADD	HL,DE
D6F4: 1100D0   [110]    	LD	DE,CBASE	;enough room for the whole file?
D6F7: 7D       [114]    	LD	A,L
D6F8: 93       [118]    	SUB	E
D6F9: 7C       [122]    	LD	A,H
D6FA: 9A       [126]    	SBC	A,D
D6FB: D271D7   [136|136]	JP	NC,UNKWN0	;no, it can't fit.
D6FE: C3E1D6   [146]    	JP	UNKWN3
                        ;
                        ;   Get here after finished reading.
                        ;
D701: E1       [10]     UNKWN4:	POP	HL
D702: 3D       [14]     	DEC	A		;normal end of file?
D703: C271D7   [24|24]  	JP	NZ,UNKWN0
D706: CD66D4   [41]     	CALL	RESETDR		;yes, reset previous drive.
D709: CD5ED2   [58]     	CALL	CONVFST		;convert the first file name that follows
D70C: 21F0D7   [68]     	LD	HL,CHGDRV	;command name.
D70F: E5       [79]     	PUSH	HL
D710: 7E       [86]     	LD	A,(HL)		;set drive code in default fcb.
D711: 32CDD7   [99]     	LD	(FCB),A
D714: 3E10     [106]    	LD	A,16		;put second name 16 bytes later.
D716: CD60D2   [123]    	CALL	CONVERT		;convert second file name.
D719: E1       [133]    	POP	HL
D71A: 7E       [140]    	LD	A,(HL)		;and set the drive for this second file.
D71B: 32DDD7   [153]    	LD	(FCB+16),A
D71E: AF       [157]    	XOR	A		;clear record byte in fcb.
D71F: 32EDD7   [170]    	LD	(FCB+32),A
D722: 115C00   [180]    	LD	DE,TFCB		;move it into place at(005Ch).
D725: 21CDD7   [190]    	LD	HL,FCB
D728: 0621     [197]    	LD	B,33
D72A: CD42D4   [214]    	CALL	HL2DE
D72D: 2108D0   [224]    	LD	HL,INBUFF+2	;now move the remainder of the input
D730: 7E       [ 7]     UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank.
D731: B7       [11]     	OR	A		;or a null.
D732: CA3ED7   [21|21]  	JP	Z,UNKWN6
D735: FE20     [28]     	CP	' '
D737: CA3ED7   [38|38]  	JP	Z,UNKWN6
D73A: 23       [44]     	INC	HL
D73B: C330D7   [54]     	JP	UNKWN5
                        ;
                        ;   Do the line move now. It ends in a null byte.
                        ;
D73E: 0600     [ 7]     UNKWN6:	LD	B,0		;keep a character count.
D740: 118100   [17]     	LD	DE,TBUFF+1	;data gets put here.
D743: 7E       [ 7]     UNKWN7:	LD	A,(HL)		;move it now.
D744: 12       [14]     	LD	(DE),A
D745: B7       [18]     	OR	A
D746: CA4FD7   [28|28]  	JP	Z,UNKWN8
D749: 04       [32]     	INC	B
D74A: 23       [38]     	INC	HL
D74B: 13       [44]     	INC	DE
D74C: C343D7   [54]     	JP	UNKWN7
D74F: 78       [ 4]     UNKWN8:	LD	A,B		;now store the character count.
D750: 328000   [17]     	LD	(TBUFF),A
D753: CD98D0   [34]     	CALL	CRLF		;clean up the screen.
D756: CDD5D1   [51]     	CALL	STDDMA		;set standard transfer address.
D759: CD1AD1   [68]     	CALL	SETCDRV		;reset current drive.
D75C: CD0001   [85]     	CALL	TBASE		;and execute the program.
                        ;
                        ;   Transiant programs return here (or reboot).
                        ;
D75F: 31ABD7   [95]     	LD	SP,BATCH	;set stack first off.
D762: CD29D1   [112]    	CALL	MOVECD		;move current drive into place (TDRIVE).
D765: CDBDD0   [129]    	CALL	DSKSEL		;and reselect it.
D768: C382D3   [139]    	JP	CMMND1		;back to comand mode.
                        ;
                        ;   Get here if some error occured.
                        ;
D76B: CD66D4   [17]     UNKWN9:	CALL	RESETDR		;inproper format.
D76E: C309D2   [27]     	JP	SYNERR
D771: 017AD7   [10]     UNKWN0:	LD	BC,BADLOAD	;read error or won't fit.
D774: CDA7D0   [27]     	CALL	PLINE
D777: C386D7   [37]     	JP	GETBACK
D77A: 42616420          BADLOAD:.TEXT	"Bad load"
D77E: 6C6F6164          
D782: 00                	.DB	0
D783: 434F4D            COMFILE:.TEXT	"COM"		;command file extension.
                        ;
                        ;   Get here to return to command level. We will reset the
                        ; previous active drive and then either return to command
                        ; level directly or print error message and then return.
                        ;
D786: CD66D4   [17]     GETBACK:CALL	RESETDR		;reset previous drive.
D789: CD5ED2   [17]     GETBACK1: CALL	CONVFST		;convert first name in (FCB).
D78C: 3ACED7   [30]     	LD	A,(FCB+1)	;if this was just a drive change request,
D78F: D620     [37]     	SUB	' '		;make sure it was valid.
D791: 21F0D7   [47]     	LD	HL,CHGDRV
D794: B6       [54]     	OR	(HL)
D795: C209D2   [64|64]  	JP	NZ,SYNERR
D798: C382D3   [74]     	JP	CMMND1		;ok, return to command level.
                        ;
                        ;   ccp stack area.
                        ;
D79B: 00000000          	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D79F: 00...             
D7AB:                   CCPSTACK .EQU	$	;end of ccp stack area.
                        ;
                        ;   Batch (or SUBMIT) processing information storage.
                        ;
D7AB: 00                BATCH:	.DB	0		;batch mode flag (0=not active).
D7AC: 00                BATCHFCB: .DB	0
D7AD: 24242420          	.TEXT "$$$     SUB"
D7B1: 20202020          
D7B5: 535542            
D7B8: 00000000          	.DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
D7BC: 00...             
                        ;
                        ;   File control block setup by the CCP.
                        ;
D7CD: 00                FCB:	.DB	0
D7CE: 20202020          	.TEXT	"           "
D7D2: 20...             
D7D9: 00000000          	.DB	0,0,0,0,0
D7DD: 00                
D7DE: 20202020          	.TEXT	"           "
D7E2: 20...             
D7E9: 00000000          	.DB	0,0,0,0,0
D7ED: 00                
D7EE: 00                RTNCODE:.DB	0		;status returned from bdos call.
D7EF: 00                CDRIVE:	.DB	0		;currently active drive.
D7F0: 00                CHGDRV:	.DB	0		;change in drives flag (0=no change).
D7F1: 0000              NBYTES:	.DW	0		;byte counter used by TYPE.
                        ;
                        ;   Room for expansion?
                        ;
D7F3: 00000000          	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0
D7F7: 00...             
                        ;
                        ;   Note that the following six bytes must match those at
                        ; (PATTRN1) or cp/m will HALT. Why?
                        ;
D800: 00160000          PATTRN2:.DB	0,22,0,0,0,0	;(* serial number bytes *).
D804: 0000              
                        ;
                        ;**************************************************************
                        ;*
                        ;*                    B D O S   E N T R Y
                        ;*
                        ;**************************************************************
                        ;
D806: C311D8   [10]     FBASE:	JP	FBASE1
                        ;
                        ;   Bdos error table.
                        ;
D809: 99D8              BADSCTR:.DW	ERROR1		;bad sector on read or write.
D80B: A5D8              BADSLCT:.DW	ERROR2		;bad disk select.
D80D: ABD8              RODISK:	.DW	ERROR3		;disk is read only.
D80F: B1D8              ROFILE:	.DW	ERROR4		;file is read only.
                        ;
                        ;   Entry into bdos. (DE) or (E) are the parameters passed. The
                        ; function number desired is in register (C).
                        ;
D811: EB       [ 4]     FBASE1:	EX	DE,HL		;save the (DE) parameters.
D812: 2243DB   [20]     	LD	(PARAMS),HL
D815: EB       [24]     	EX	DE,HL
D816: 7B       [28]     	LD	A,E		;and save register (E) in particular.
D817: 32D6E5   [41]     	LD	(EPARAM),A
D81A: 210000   [51]     	LD	HL,0
D81D: 2245DB   [67]     	LD	(STATUS),HL	;clear return status.
D820: 39       [78]     	ADD	HL,SP
D821: 220FDB   [94]     	LD	(USRSTACK),HL	;save users stack pointer.
D824: 3141DB   [104]    	LD	SP,STKAREA	;and set our own.
D827: AF       [108]    	XOR	A		;clear auto select storage space.
D828: 32E0E5   [121]    	LD	(AUTOFLAG),A
D82B: 32DEE5   [134]    	LD	(AUTO),A
D82E: 2174E5   [144]    	LD	HL,GOBACK	;set return address.
D831: E5       [155]    	PUSH	HL
D832: 79       [159]    	LD	A,C		;get function number.
D833: FE29     [166]    	CP	NFUNCTS		;valid function number?
D835: D0       [171|177]	RET	NC
D836: 4B       [175]    	LD	C,E		;keep single register function here.
D837: 2147D8   [185]    	LD	HL,FUNCTNS	;now look thru the function table.
D83A: 5F       [189]    	LD	E,A
D83B: 1600     [196]    	LD	D,0		;(DE)=function number.
D83D: 19       [207]    	ADD	HL,DE
D83E: 19       [218]    	ADD	HL,DE		;(HL)=(start of table)+2*(function number).
D83F: 5E       [225]    	LD	E,(HL)
D840: 23       [231]    	INC	HL
D841: 56       [238]    	LD	D,(HL)		;now (DE)=address for this function.
D842: 2A43DB   [254]    	LD	HL,(PARAMS)	;retrieve parameters.
D845: EB       [258]    	EX	DE,HL		;now (DE) has the original parameters.
D846: E9       [262]    	JP	(HL)		;execute desired function.
                        ;
                        ;   BDOS function jump table.
                        ;
0029:                   NFUNCTS .EQU	41		;number of functions in followin table.
                        ;
D847: 03E6C8DA          FUNCTNS:.DW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
D84B: 90D9CEDA          
D84F: 12E60FE6          
D853: D4DAEDDA          
D857: F3DAF8DA          	.DW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
D85B: E1D9FEDA          
D85F: 7EE483E4          
D863: 45E49CE4          
D867: A5E4ABE4          	.DW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
D86B: C8E4D7E4          
D86F: E0E4E6E4          
D873: ECE4              
D875: F5E4FEE4          	.DW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
D879: 04E50AE5          
D87D: 11E52CDD          
D881: 17E51DE5          
D885: 26E52DE5          	.DW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
D889: 41E547E5          
D88D: 4DE50EE4          
D891: 53E504DB          
D895: 04DB9BE5          	.DW	RTN,WTSPECL
                        ;
                        ;   Bdos error message section.
                        ;
D899: 21CAD8   [10]     ERROR1:	LD	HL,BADSEC	;bad sector message.
D89C: CDE5D8   [27]     	CALL	PRTERR		;print it and get a 1 char responce.
D89F: FE03     [34]     	CP	CNTRLC		;re-boot request (control-c)?
D8A1: CA0000   [44|44]  	JP	Z,0		;yes.
D8A4: C9       [54]     	RET			;no, return to retry i/o function.
                        ;
D8A5: 21D5D8   [10]     ERROR2:	LD	HL,BADSEL	;bad drive selected.
D8A8: C3B4D8   [20]     	JP	ERROR5
                        ;
D8AB: 21E1D8   [10]     ERROR3:	LD	HL,DISKRO	;disk is read only.
D8AE: C3B4D8   [20]     	JP	ERROR5
                        ;
D8B1: 21DCD8   [10]     ERROR4:	LD	HL,FILERO	;file is read only.
                        ;
D8B4: CDE5D8   [17]     ERROR5:	CALL	PRTERR
D8B7: C30000   [27]     	JP	0		;always reboot on these errors.
                        ;
D8BA: 42646F73          BDOSERR:.TEXT	"Bdos Err On "
D8BE: 20457272          
D8C2: 204F6E20          
D8C6: 203A2024          BDOSDRV:.TEXT	" : $"
D8CA: 42616420          BADSEC:	.TEXT	"Bad Sector$"
D8CE: 53656374          
D8D2: 6F7224            
D8D5: 53656C65          BADSEL:	.TEXT	"Select$"
D8D9: 637424            
D8DC: 46696C65          FILERO:	.TEXT	"File "
D8E0: 20                
D8E1: 522F4F24          DISKRO:	.TEXT	"R/O$"
                        ;
                        ;   Print bdos error message.
                        ;
D8E5: E5       [11]     PRTERR:	PUSH	HL		;save second message pointer.
D8E6: CDC9D9   [28]     	CALL	OUTCRLF		;send (cr)(lf).
D8E9: 3A42DB   [41]     	LD	A,(ACTIVE)	;get active drive.
D8EC: C641     [48]     	ADD	A,'A'		;make ascii.
D8EE: 32C6D8   [61]     	LD	(BDOSDRV),A	;and put in message.
D8F1: 01BAD8   [71]     	LD	BC,BDOSERR	;and print it.
D8F4: CDD3D9   [88]     	CALL	PRTMESG
D8F7: C1       [98]     	POP	BC		;print second message line now.
D8F8: CDD3D9   [115]    	CALL	PRTMESG
                        ;
                        ;   Get an input character. We will check our 1 character
                        ; buffer first. This may be set by the console status routine.
                        ;
D8FB: 210EDB   [10]     GETCHAR:LD	HL,CHARBUF	;check character buffer.
D8FE: 7E       [17]     	LD	A,(HL)		;anything present already?
D8FF: 3600     [27]     	LD	(HL),0		;...either case clear it.
D901: B7       [31]     	OR	A
D902: C0       [36|42]  	RET	NZ		;yes, use it.
D903: C309E6   [46]     	JP	CONIN		;nope, go get a character responce.
                        ;
                        ;   Input and echo a character.
                        ;
D906: CDFBD8   [17]     GETECHO:CALL	GETCHAR		;input a character.
D909: CD14D9   [34]     	CALL	CHKCHAR		;carriage control?
D90C: D8       [39|45]  	RET	C		;no, a regular control char so don't echo.
D90D: F5       [50]     	PUSH	AF		;ok, save character now.
D90E: 4F       [54]     	LD	C,A
D90F: CD90D9   [71]     	CALL	OUTCON		;and echo it.
D912: F1       [81]     	POP	AF		;get character and return.
D913: C9       [91]     	RET	
                        ;
                        ;   Check character in (A). Set the zero flag on a carriage
                        ; control character and the carry flag on any other control
                        ; character.
                        ;
D914: FE0D     [ 7]     CHKCHAR:CP	CR		;check for carriage return, line feed, backspace,
D916: C8       [12|18]  	RET	Z		;or a tab.
D917: FE0A     [19]     	CP	LF
D919: C8       [24|30]  	RET	Z
D91A: FE09     [31]     	CP	TAB
D91C: C8       [36|42]  	RET	Z
D91D: FE08     [43]     	CP	BS
D91F: C8       [48|54]  	RET	Z
D920: FE20     [55]     	CP	' '		;other control char? Set carry flag.
D922: C9       [65]     	RET	
                        ;
                        ;   Check the console during output. Halt on a control-s, then
                        ; reboot on a control-c. If anything else is ready, clear the
                        ; zero flag and return (the calling routine may want to do
                        ; something).
                        ;
D923: 3A0EDB   [13]     CKCONSOL: LD	A,(CHARBUF)	;check buffer.
D926: B7       [17]     	OR	A		;if anything, just return without checking.
D927: C245D9   [27|27]  	JP	NZ,CKCON2
D92A: CD06E6   [44]     	CALL	CONST		;nothing in buffer. Check console.
D92D: E601     [51]     	AND	01H		;look at bit 0.
D92F: C8       [56|62]  	RET	Z		;return if nothing.
D930: CD09E6   [73]     	CALL	CONIN		;ok, get it.
D933: FE13     [80]     	CP	CNTRLS		;if not control-s, return with zero cleared.
D935: C242D9   [90|90]  	JP	NZ,CKCON1
D938: CD09E6   [107]    	CALL	CONIN		;halt processing until another char
D93B: FE03     [114]    	CP	CNTRLC		;is typed. Control-c?
D93D: CA0000   [124|124]	JP	Z,0		;yes, reboot now.
D940: AF       [128]    	XOR	A		;no, just pretend nothing was ever ready.
D941: C9       [138]    	RET	
D942: 320EDB   [13]     CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing.
D945: 3E01     [ 7]     CKCON2:	LD	A,1		;set (A) to non zero to mean something is ready.
D947: C9       [17]     	RET	
                        ;
                        ;   Output (C) to the screen. If the printer flip-flop flag
                        ; is set, we will send character to printer also. The console
                        ; will be checked in the process.
                        ;
D948: 3A0ADB   [13]     OUTCHAR:LD	A,(OUTFLAG)	;check output flag.
D94B: B7       [17]     	OR	A		;anything and we won't generate output.
D94C: C262D9   [27|27]  	JP	NZ,OUTCHR1
D94F: C5       [38]     	PUSH	BC
D950: CD23D9   [55]     	CALL	CKCONSOL	;check console (we don't care whats there).
D953: C1       [65]     	POP	BC
D954: C5       [76]     	PUSH	BC
D955: CD0CE6   [93]     	CALL	CONOUT		;output (C) to the screen.
D958: C1       [103]    	POP	BC
D959: C5       [114]    	PUSH	BC
D95A: 3A0DDB   [127]    	LD	A,(PRTFLAG)	;check printer flip-flop flag.
D95D: B7       [131]    	OR	A
D95E: C40FE6   [141|148]	CALL	NZ,LIST		;print it also if non-zero.
D961: C1       [151]    	POP	BC
D962: 79       [ 4]     OUTCHR1:LD	A,C		;update cursors position.
D963: 210CDB   [14]     	LD	HL,CURPOS
D966: FE7F     [21]     	CP	DEL		;rubouts don't do anything here.
D968: C8       [26|32]  	RET	Z
D969: 34       [37]     	INC	(HL)		;bump line pointer.
D96A: FE20     [44]     	CP	' '		;and return if a normal character.
D96C: D0       [49|55]  	RET	NC
D96D: 35       [60]     	DEC	(HL)		;restore and check for the start of the line.
D96E: 7E       [67]     	LD	A,(HL)
D96F: B7       [71]     	OR	A
D970: C8       [76|82]  	RET	Z		;ingnore control characters at the start of the line.
D971: 79       [80]     	LD	A,C
D972: FE08     [87]     	CP	BS		;is it a backspace?
D974: C279D9   [97|97]  	JP	NZ,OUTCHR2
D977: 35       [108]    	DEC	(HL)		;yes, backup pointer.
D978: C9       [118]    	RET	
D979: FE0A     [ 7]     OUTCHR2:CP	LF		;is it a line feed?
D97B: C0       [12|18]  	RET	NZ		;ignore anything else.
D97C: 3600     [22]     	LD	(HL),0		;reset pointer to start of line.
D97E: C9       [32]     	RET	
                        ;
                        ;   Output (A) to the screen. If it is a control character
                        ; (other than carriage control), use ^x format.
                        ;
D97F: 79       [ 4]     SHOWIT:	LD	A,C
D980: CD14D9   [21]     	CALL	CHKCHAR		;check character.
D983: D290D9   [31|31]  	JP	NC,OUTCON	;not a control, use normal output.
D986: F5       [42]     	PUSH	AF
D987: 0E5E     [49]     	LD	C,'^'		;for a control character, preceed it with '^'.
D989: CD48D9   [66]     	CALL	OUTCHAR
D98C: F1       [76]     	POP	AF
D98D: F640     [83]     	OR	'@'		;and then use the letter equivelant.
D98F: 4F       [87]     	LD	C,A
                        ;
                        ;   Function to output (C) to the console device and expand tabs
                        ; if necessary.
                        ;
D990: 79       [ 4]     OUTCON:	LD	A,C
D991: FE09     [11]     	CP	TAB		;is it a tab?
D993: C248D9   [21|21]  	JP	NZ,OUTCHAR	;use regular output.
D996: 0E20     [ 7]     OUTCON1:LD	C,' '		;yes it is, use spaces instead.
D998: CD48D9   [24]     	CALL	OUTCHAR
D99B: 3A0CDB   [37]     	LD	A,(CURPOS)	;go until the cursor is at a multiple of 8
                        
D99E: E607     [44]     	AND	07H		;position.
D9A0: C296D9   [54|54]  	JP	NZ,OUTCON1
D9A3: C9       [64]     	RET	
                        ;
                        ;   Echo a backspace character. Erase the prevoius character
                        ; on the screen.
                        ;
D9A4: CDACD9   [17]     BACKUP:	CALL	BACKUP1		;backup the screen 1 place.
D9A7: 0E20     [24]     	LD	C,' '		;then blank that character.
D9A9: CD0CE6   [41]     	CALL	CONOUT
D9AC: 0E08     [ 7]     BACKUP1:LD	C,BS		;then back space once more.
D9AE: C30CE6   [17]     	JP	CONOUT
                        ;
                        ;   Signal a deleted line. Print a '#' at the end and start
                        ; over.
                        ;
D9B1: 0E23     [ 7]     NEWLINE:LD	C,'#'
D9B3: CD48D9   [24]     	CALL	OUTCHAR		;print this.
D9B6: CDC9D9   [41]     	CALL	OUTCRLF		;start new line.
D9B9: 3A0CDB   [13]     NEWLN1:	LD	A,(CURPOS)	;move the cursor to the starting position.
D9BC: 210BDB   [23]     	LD	HL,STARTING
D9BF: BE       [30]     	CP	(HL)
D9C0: D0       [35|41]  	RET	NC		;there yet?
D9C1: 0E20     [42]     	LD	C,' '
D9C3: CD48D9   [59]     	CALL	OUTCHAR		;nope, keep going.
D9C6: C3B9D9   [69]     	JP	NEWLN1
                        ;
                        ;   Output a (cr) (lf) to the console device (screen).
                        ;
D9C9: 0E0D     [ 7]     OUTCRLF:LD	C,CR
D9CB: CD48D9   [24]     	CALL	OUTCHAR
D9CE: 0E0A     [31]     	LD	C,LF
D9D0: C348D9   [41]     	JP	OUTCHAR
                        ;
                        ;   Print message pointed to by (BC). It will end with a '$'.
                        ;
D9D3: 0A       [ 7]     PRTMESG:LD	A,(BC)		;check for terminating character.
D9D4: FE24     [14]     	CP	'$'
D9D6: C8       [19|25]  	RET	Z
D9D7: 03       [25]     	INC	BC
D9D8: C5       [36]     	PUSH	BC		;otherwise, bump pointer and print it.
D9D9: 4F       [40]     	LD	C,A
D9DA: CD90D9   [57]     	CALL	OUTCON
D9DD: C1       [67]     	POP	BC
D9DE: C3D3D9   [77]     	JP	PRTMESG
                        ;
                        ;   Function to execute a buffered read.
                        ;
D9E1: 3A0CDB   [13]     RDBUFF:	LD	A,(CURPOS)	;use present location as starting one.
D9E4: 320BDB   [26]     	LD	(STARTING),A
D9E7: 2A43DB   [42]     	LD	HL,(PARAMS)	;get the maximum buffer space.
D9EA: 4E       [49]     	LD	C,(HL)
D9EB: 23       [55]     	INC	HL		;point to first available space.
D9EC: E5       [66]     	PUSH	HL		;and save.
D9ED: 0600     [73]     	LD	B,0		;keep a character count.
D9EF: C5       [11]     RDBUF1:	PUSH	BC
D9F0: E5       [22]     	PUSH	HL
D9F1: CDFBD8   [17]     RDBUF2:	CALL	GETCHAR		;get the next input character.
D9F4: E67F     [24]     	AND	7FH		;strip bit 7.
D9F6: E1       [34]     	POP	HL		;reset registers.
D9F7: C1       [44]     	POP	BC
D9F8: FE0D     [51]     	CP	CR		;en of the line?
D9FA: CAC1DA   [61|61]  	JP	Z,RDBUF17
D9FD: FE0A     [68]     	CP	LF
D9FF: CAC1DA   [78|78]  	JP	Z,RDBUF17
DA02: FE08     [85]     	CP	BS		;how about a backspace?
DA04: C216DA   [95|95]  	JP	NZ,RDBUF3
DA07: 78       [99]     	LD	A,B		;yes, but ignore at the beginning of the line.
DA08: B7       [103]    	OR	A
DA09: CAEFD9   [113|113]	JP	Z,RDBUF1
DA0C: 05       [117]    	DEC	B		;ok, update counter.
DA0D: 3A0CDB   [130]    	LD	A,(CURPOS)	;if we backspace to the start of the line,
DA10: 320ADB   [143]    	LD	(OUTFLAG),A	;treat as a cancel (control-x).
DA13: C370DA   [153]    	JP	RDBUF10
DA16: FE7F     [ 7]     RDBUF3:	CP	DEL		;user typed a rubout?
DA18: C226DA   [17|17]  	JP	NZ,RDBUF4
DA1B: 78       [21]     	LD	A,B		;ignore at the start of the line.
DA1C: B7       [25]     	OR	A
DA1D: CAEFD9   [35|35]  	JP	Z,RDBUF1
DA20: 7E       [42]     	LD	A,(HL)		;ok, echo the prevoius character.
DA21: 05       [46]     	DEC	B		;and reset pointers (counters).
DA22: 2B       [52]     	DEC	HL
DA23: C3A9DA   [62]     	JP	RDBUF15
DA26: FE05     [ 7]     RDBUF4:	CP	CNTRLE		;physical end of line?
DA28: C237DA   [17|17]  	JP	NZ,RDBUF5
DA2B: C5       [28]     	PUSH	BC		;yes, do it.
DA2C: E5       [39]     	PUSH	HL
DA2D: CDC9D9   [56]     	CALL	OUTCRLF
DA30: AF       [60]     	XOR	A		;and update starting position.
DA31: 320BDB   [73]     	LD	(STARTING),A
DA34: C3F1D9   [83]     	JP	RDBUF2
DA37: FE10     [ 7]     RDBUF5:	CP	CNTRLP		;control-p?
DA39: C248DA   [17|17]  	JP	NZ,RDBUF6
DA3C: E5       [28]     	PUSH	HL		;yes, flip the print flag filp-flop byte.
DA3D: 210DDB   [38]     	LD	HL,PRTFLAG
DA40: 3E01     [45]     	LD	A,1		;PRTFLAG=1-PRTFLAG
DA42: 96       [52]     	SUB	(HL)
DA43: 77       [59]     	LD	(HL),A
DA44: E1       [69]     	POP	HL
DA45: C3EFD9   [79]     	JP	RDBUF1
DA48: FE18     [ 7]     RDBUF6:	CP	CNTRLX		;control-x (cancel)?
DA4A: C25FDA   [17|17]  	JP	NZ,RDBUF8
DA4D: E1       [27]     	POP	HL
DA4E: 3A0BDB   [13]     RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here.
DA51: 210CDB   [23]     	LD	HL,CURPOS
DA54: BE       [30]     	CP	(HL)
DA55: D2E1D9   [40|40]  	JP	NC,RDBUFF	;done yet?
DA58: 35       [51]     	DEC	(HL)		;no, decrement pointer and output back up one space.
DA59: CDA4D9   [68]     	CALL	BACKUP
DA5C: C34EDA   [78]     	JP	RDBUF7
DA5F: FE15     [ 7]     RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)?
DA61: C26BDA   [17|17]  	JP	NZ,RDBUF9
DA64: CDB1D9   [34]     	CALL	NEWLINE		;start a new line.
DA67: E1       [44]     	POP	HL
DA68: C3E1D9   [54]     	JP	RDBUFF
DA6B: FE12     [ 7]     RDBUF9:	CP	CNTRLR		;control-r?
DA6D: C2A6DA   [17|17]  	JP	NZ,RDBUF14
DA70: C5       [11]     RDBUF10:PUSH	BC		;yes, start a new line and retype the old one.
DA71: CDB1D9   [28]     	CALL	NEWLINE
DA74: C1       [38]     	POP	BC
DA75: E1       [48]     	POP	HL
DA76: E5       [59]     	PUSH	HL
DA77: C5       [70]     	PUSH	BC
DA78: 78       [ 4]     RDBUF11:LD	A,B		;done whole line yet?
DA79: B7       [ 8]     	OR	A
DA7A: CA8ADA   [18|18]  	JP	Z,RDBUF12
DA7D: 23       [24]     	INC	HL		;nope, get next character.
DA7E: 4E       [31]     	LD	C,(HL)
DA7F: 05       [35]     	DEC	B		;count it.
DA80: C5       [46]     	PUSH	BC
DA81: E5       [57]     	PUSH	HL
DA82: CD7FD9   [74]     	CALL	SHOWIT		;and display it.
DA85: E1       [84]     	POP	HL
DA86: C1       [94]     	POP	BC
DA87: C378DA   [104]    	JP	RDBUF11
DA8A: E5       [11]     RDBUF12:PUSH	HL		;done with line. If we were displaying
DA8B: 3A0ADB   [24]     	LD	A,(OUTFLAG)	;then update cursor position.
DA8E: B7       [28]     	OR	A
DA8F: CAF1D9   [38|38]  	JP	Z,RDBUF2
DA92: 210CDB   [48]     	LD	HL,CURPOS	;because this line is shorter, we must
DA95: 96       [55]     	SUB	(HL)		;back up the cursor (not the screen however)
DA96: 320ADB   [68]     	LD	(OUTFLAG),A	;some number of positions.
DA99: CDA4D9   [17]     RDBUF13:CALL	BACKUP		;note that as long as (OUTFLAG) is non
DA9C: 210ADB   [27]     	LD	HL,OUTFLAG	;zero, the screen will not be changed.
DA9F: 35       [38]     	DEC	(HL)
DAA0: C299DA   [48|48]  	JP	NZ,RDBUF13
DAA3: C3F1D9   [58]     	JP	RDBUF2		;now just get the next character.
                        ;
                        ;   Just a normal character, put this in our buffer and echo.
                        ;
DAA6: 23       [ 6]     RDBUF14:INC	HL
DAA7: 77       [13]     	LD	(HL),A		;store character.
DAA8: 04       [17]     	INC	B		;and count it.
DAA9: C5       [11]     RDBUF15:PUSH	BC
DAAA: E5       [22]     	PUSH	HL
DAAB: 4F       [26]     	LD	C,A		;echo it now.
DAAC: CD7FD9   [43]     	CALL	SHOWIT
DAAF: E1       [53]     	POP	HL
DAB0: C1       [63]     	POP	BC
DAB1: 7E       [70]     	LD	A,(HL)		;was it an abort request?
DAB2: FE03     [77]     	CP	CNTRLC		;control-c abort?
DAB4: 78       [81]     	LD	A,B
DAB5: C2BDDA   [91|91]  	JP	NZ,RDBUF16
DAB8: FE01     [98]     	CP	1		;only if at start of line.
DABA: CA0000   [108|108]	JP	Z,0
DABD: B9       [ 4]     RDBUF16:CP	C		;nope, have we filled the buffer?
DABE: DAEFD9   [14|14]  	JP	C,RDBUF1
DAC1: E1       [10]     RDBUF17:POP	HL		;yes end the line and return.
DAC2: 70       [17]     	LD	(HL),B
DAC3: 0E0D     [24]     	LD	C,CR
DAC5: C348D9   [34]     	JP	OUTCHAR		;output (cr) and return.
                        ;
                        ;   Function to get a character from the console device.
                        ;
DAC8: CD06D9   [17]     GETCON:	CALL	GETECHO		;get and echo.
DACB: C301DB   [27]     	JP	SETSTAT		;save status and return.
                        ;
                        ;   Function to get a character from the tape reader device.
                        ;
DACE: CD15E6   [17]     GETRDR:	CALL	READER		;get a character from reader, set status and return.
DAD1: C301DB   [27]     	JP	SETSTAT
                        ;
                        ;  Function to perform direct console i/o. If (C) contains (FF)
                        ; then this is an input request. If (C) contains (FE) then
                        ; this is a status request. Otherwise we are to output (C).
                        ;
DAD4: 79       [ 4]     DIRCIO:	LD	A,C		;test for (FF).
DAD5: 3C       [ 8]     	INC	A
DAD6: CAE0DA   [18|18]  	JP	Z,DIRC1
DAD9: 3C       [22]     	INC	A		;test for (FE).
DADA: CA06E6   [32|32]  	JP	Z,CONST
DADD: C30CE6   [42]     	JP	CONOUT		;just output (C).
DAE0: CD06E6   [17]     DIRC1:	CALL	CONST		;this is an input request.
DAE3: B7       [21]     	OR	A
DAE4: CA91E5   [31|31]  	JP	Z,GOBACK1	;not ready? Just return (directly).
DAE7: CD09E6   [48]     	CALL	CONIN		;yes, get character.
DAEA: C301DB   [58]     	JP	SETSTAT		;set status and return.
                        ;
                        ;   Function to return the i/o byte.
                        ;
DAED: 3A0300   [13]     GETIOB:	LD	A,(IOBYTE)
DAF0: C301DB   [23]     	JP	SETSTAT
                        ;
                        ;   Function to set the i/o byte.
                        ;
DAF3: 210300   [10]     SETIOB:	LD	HL,IOBYTE
DAF6: 71       [17]     	LD	(HL),C
DAF7: C9       [27]     	RET	
                        ;
                        ;   Function to print the character string pointed to by (DE)
                        ; on the console device. The string ends with a '$'.
                        ;
DAF8: EB       [ 4]     PRTSTR:	EX	DE,HL
DAF9: 4D       [ 8]     	LD	C,L
DAFA: 44       [12]     	LD	B,H		;now (BC) points to it.
DAFB: C3D3D9   [22]     	JP	PRTMESG
                        ;
                        ;   Function to interigate the console device.
                        ;
DAFE: CD23D9   [17]     GETCSTS:CALL	CKCONSOL
                        ;
                        ;   Get here to set the status and return to the cleanup
                        ; section. Then back to the user.
                        ;
DB01: 3245DB   [13]     SETSTAT:LD	(STATUS),A
DB04: C9       [10]     RTN:	RET	
                        ;
                        ;   Set the status to 1 (read or write error code).
                        ;
DB05: 3E01     [ 7]     IOERR1:	LD	A,1
DB07: C301DB   [17]     	JP	SETSTAT
                        ;
DB0A: 00                OUTFLAG:.DB	0		;output flag (non zero means no output).
DB0B: 02                STARTING: .DB	2		;starting position for cursor.
DB0C: 00                CURPOS:	.DB	0		;cursor position (0=start of line).
DB0D: 00                PRTFLAG:.DB	0		;printer flag (control-p toggle). List if non zero.
DB0E: 00                CHARBUF:.DB	0		;single input character buffer.
                        ;
                        ;   Stack area for BDOS calls.
                        ;
DB0F: 0000              USRSTACK: .DW	0		;save users stack pointer here.
                        ;
DB11: 00000000          	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DB15: 00...             
DB29: 00000000          	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DB2D: 00...             
DB41:                   STKAREA .EQU	$		;end of stack area.
                        ;
DB41: 00                USERNO:	.DB	0		;current user number.
DB42: 00                ACTIVE:	.DB	0		;currently active drive.
DB43: 0000              PARAMS:	.DW	0		;save (DE) parameters here on entry.
DB45: 0000              STATUS:	.DW	0		;status returned from bdos function.
                        ;
                        ;   Select error occured, jump to error routine.
                        ;
DB47: 210BD8   [10]     SLCTERR:LD	HL,BADSLCT
                        ;
                        ;   Jump to (HL) indirectly.
                        ;
DB4A: 5E       [ 7]     JUMPHL:	LD	E,(HL)
DB4B: 23       [13]     	INC	HL
DB4C: 56       [20]     	LD	D,(HL)		;now (DE) contain the desired address.
DB4D: EB       [24]     	EX	DE,HL
DB4E: E9       [28]     	JP	(HL)
                        ;
                        ;   Block move. (DE) to (HL), (C) bytes total.
                        ;
DB4F: 0C       [ 4]     DE2HL:	INC	C		;is count down to zero?
DB50: 0D       [ 4]     DE2HL1:	DEC	C
DB51: C8       [ 9|15]  	RET	Z		;yes, we are done.
DB52: 1A       [16]     	LD	A,(DE)		;no, move one more byte.
DB53: 77       [23]     	LD	(HL),A
DB54: 13       [29]     	INC	DE
DB55: 23       [35]     	INC	HL
DB56: C350DB   [45]     	JP	DE2HL1		;and repeat.
                        ;
                        ;   Select the desired drive.
                        ;
DB59: 3A42DB   [13]     SELECT:	LD	A,(ACTIVE)	;get active disk.
DB5C: 4F       [17]     	LD	C,A
DB5D: CD1BE6   [34]     	CALL	SELDSK		;select it.
DB60: 7C       [38]     	LD	A,H		;valid drive?
DB61: B5       [42]     	OR	L		;valid drive?
DB62: C8       [47|53]  	RET	Z		;return if not.
                        ;
                        ;   Here, the BIOS returned the address of the parameter block
                        ; in (HL). We will extract the necessary pointers and save them.
                        ;
DB63: 5E       [54]     	LD	E,(HL)		;yes, get address of translation table into (DE).
DB64: 23       [60]     	INC	HL
DB65: 56       [67]     	LD	D,(HL)
DB66: 23       [73]     	INC	HL
DB67: 22B3E5   [89]     	LD	(SCRATCH1),HL	;save pointers to scratch areas.
DB6A: 23       [95]     	INC	HL
DB6B: 23       [101]    	INC	HL
DB6C: 22B5E5   [117]    	LD	(SCRATCH2),HL	;ditto.
DB6F: 23       [123]    	INC	HL
DB70: 23       [129]    	INC	HL
DB71: 22B7E5   [145]    	LD	(SCRATCH3),HL	;ditto.
DB74: 23       [151]    	INC	HL
DB75: 23       [157]    	INC	HL
DB76: EB       [161]    	EX	DE,HL		;now save the translation table address.
DB77: 22D0E5   [177]    	LD	(XLATE),HL
DB7A: 21B9E5   [187]    	LD	HL,DIRBUF	;put the next 8 bytes here.
DB7D: 0E08     [194]    	LD	C,8		;they consist of the directory buffer
DB7F: CD4FDB   [211]    	CALL	DE2HL		;pointer, parameter block pointer,
DB82: 2ABBE5   [227]    	LD	HL,(DISKPB)	;check and allocation vectors.
DB85: EB       [231]    	EX	DE,HL
DB86: 21C1E5   [241]    	LD	HL,SECTORS	;move parameter block into our ram.
DB89: 0E0F     [248]    	LD	C,15		;it is 15 bytes long.
DB8B: CD4FDB   [265]    	CALL	DE2HL
DB8E: 2AC6E5   [281]    	LD	HL,(DSKSIZE)	;check disk size.
DB91: 7C       [285]    	LD	A,H		;more than 256 blocks on this?
DB92: 21DDE5   [295]    	LD	HL,BIGDISK
DB95: 36FF     [305]    	LD	(HL),0FFH	;set to samll.
DB97: B7       [309]    	OR	A
DB98: CA9DDB   [319|319]	JP	Z,SELECT1
DB9B: 3600     [329]    	LD	(HL),0		;wrong, set to large.
DB9D: 3EFF     [ 7]     SELECT1:LD	A,0FFH		;clear the zero flag.
DB9F: B7       [11]     	OR	A
DBA0: C9       [21]     	RET	
                        ;
                        ;   Routine to home the disk track head and clear pointers.
                        ;
DBA1: CD18E6   [17]     HOMEDRV:CALL	HOME		;home the head.
DBA4: AF       [21]     	XOR	A
DBA5: 2AB5E5   [37]     	LD	HL,(SCRATCH2)	;set our track pointer also.
DBA8: 77       [44]     	LD	(HL),A
DBA9: 23       [50]     	INC	HL
DBAA: 77       [57]     	LD	(HL),A
DBAB: 2AB7E5   [73]     	LD	HL,(SCRATCH3)	;and our sector pointer.
DBAE: 77       [80]     	LD	(HL),A
DBAF: 23       [86]     	INC	HL
DBB0: 77       [93]     	LD	(HL),A
DBB1: C9       [103]    	RET	
                        ;
                        ;   Do the actual disk read and check the error return status.
                        ;
DBB2: CD27E6   [17]     DOREAD:	CALL	READ
DBB5: C3BBDB   [27]     	JP	IORET
                        ;
                        ;   Do the actual disk write and handle any bios error.
                        ;
DBB8: CD2AE6   [17]     DOWRITE:CALL	WRITE
DBBB: B7       [ 4]     IORET:	OR	A
DBBC: C8       [ 9|15]  	RET	Z		;return unless an error occured.
DBBD: 2109D8   [19]     	LD	HL,BADSCTR	;bad read/write on this sector.
DBC0: C34ADB   [29]     	JP	JUMPHL
                        ;
                        ;   Routine to select the track and sector that the desired
                        ; block number falls in.
                        ;
DBC3: 2AEAE5   [16]     TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file
DBC6: 0E02     [23]     	LD	C,2		;in directory and compute sector #.
DBC8: CDEADC   [40]     	CALL	SHIFTR		;sector #=file-position/4.
DBCB: 22E5E5   [56]     	LD	(BLKNMBR),HL	;save this as the block number of interest.
DBCE: 22ECE5   [72]     	LD	(CKSUMTBL),HL	;what's it doing here too?
                        ;
                        ;   if the sector number has already been set (BLKNMBR), enter
                        ; at this point.
                        ;
DBD1: 21E5E5   [10]     TRKSEC1:LD	HL,BLKNMBR
DBD4: 4E       [17]     	LD	C,(HL)		;move sector number into (BC).
DBD5: 23       [23]     	INC	HL
DBD6: 46       [30]     	LD	B,(HL)
DBD7: 2AB7E5   [46]     	LD	HL,(SCRATCH3)	;get current sector number and
DBDA: 5E       [53]     	LD	E,(HL)		;move this into (DE).
DBDB: 23       [59]     	INC	HL
DBDC: 56       [66]     	LD	D,(HL)
DBDD: 2AB5E5   [82]     	LD	HL,(SCRATCH2)	;get current track number.
DBE0: 7E       [89]     	LD	A,(HL)		;and this into (HL).
DBE1: 23       [95]     	INC	HL
DBE2: 66       [102]    	LD	H,(HL)
DBE3: 6F       [106]    	LD	L,A
DBE4: 79       [ 4]     TRKSEC2:LD	A,C		;is desired sector before current one?
DBE5: 93       [ 8]     	SUB	E
DBE6: 78       [12]     	LD	A,B
DBE7: 9A       [16]     	SBC	A,D
DBE8: D2FADB   [26|26]  	JP	NC,TRKSEC3
DBEB: E5       [37]     	PUSH	HL		;yes, decrement sectors by one track.
DBEC: 2AC1E5   [53]     	LD	HL,(SECTORS)	;get sectors per track.
DBEF: 7B       [57]     	LD	A,E
DBF0: 95       [61]     	SUB	L
DBF1: 5F       [65]     	LD	E,A
DBF2: 7A       [69]     	LD	A,D
DBF3: 9C       [73]     	SBC	A,H
DBF4: 57       [77]     	LD	D,A		;now we have backed up one full track.
DBF5: E1       [87]     	POP	HL
DBF6: 2B       [93]     	DEC	HL		;adjust track counter.
DBF7: C3E4DB   [103]    	JP	TRKSEC2
DBFA: E5       [11]     TRKSEC3:PUSH	HL		;desired sector is after current one.
DBFB: 2AC1E5   [27]     	LD	HL,(SECTORS)	;get sectors per track.
DBFE: 19       [38]     	ADD	HL,DE		;bump sector pointer to next track.
DBFF: DA0FDC   [48|48]  	JP	C,TRKSEC4
DC02: 79       [52]     	LD	A,C		;is desired sector now before current one?
DC03: 95       [56]     	SUB	L
DC04: 78       [60]     	LD	A,B
DC05: 9C       [64]     	SBC	A,H
DC06: DA0FDC   [74|74]  	JP	C,TRKSEC4
DC09: EB       [78]     	EX	DE,HL		;not yes, increment track counter
DC0A: E1       [88]     	POP	HL		;and continue until it is.
DC0B: 23       [94]     	INC	HL
DC0C: C3FADB   [104]    	JP	TRKSEC3
                        ;
                        ;   here we have determined the track number that contains the
                        ; desired sector.
                        ;
DC0F: E1       [10]     TRKSEC4:POP	HL		;get track number (HL).
DC10: C5       [21]     	PUSH	BC
DC11: D5       [32]     	PUSH	DE
DC12: E5       [43]     	PUSH	HL
DC13: EB       [47]     	EX	DE,HL
DC14: 2ACEE5   [63]     	LD	HL,(OFFSET)	;adjust for first track offset.
DC17: 19       [74]     	ADD	HL,DE
DC18: 44       [78]     	LD	B,H
DC19: 4D       [82]     	LD	C,L
DC1A: CD1EE6   [99]     	CALL	SETTRK		;select this track.
DC1D: D1       [109]    	POP	DE		;reset current track pointer.
DC1E: 2AB5E5   [125]    	LD	HL,(SCRATCH2)
DC21: 73       [132]    	LD	(HL),E
DC22: 23       [138]    	INC	HL
DC23: 72       [145]    	LD	(HL),D
DC24: D1       [155]    	POP	DE
DC25: 2AB7E5   [171]    	LD	HL,(SCRATCH3)	;reset the first sector on this track.
DC28: 73       [178]    	LD	(HL),E
DC29: 23       [184]    	INC	HL
DC2A: 72       [191]    	LD	(HL),D
DC2B: C1       [201]    	POP	BC
DC2C: 79       [205]    	LD	A,C		;now subtract the desired one.
DC2D: 93       [209]    	SUB	E		;to make it relative (1-# sectors/track).
DC2E: 4F       [213]    	LD	C,A
DC2F: 78       [217]    	LD	A,B
DC30: 9A       [221]    	SBC	A,D
DC31: 47       [225]    	LD	B,A
DC32: 2AD0E5   [241]    	LD	HL,(XLATE)	;translate this sector according to this table.
DC35: EB       [245]    	EX	DE,HL
DC36: CD30E6   [262]    	CALL	SECTRN		;let the bios translate it.
DC39: 4D       [266]    	LD	C,L
DC3A: 44       [270]    	LD	B,H
DC3B: C321E6   [280]    	JP	SETSEC		;and select it.
                        ;
                        ;   Compute block number from record number (SAVNREC) and
                        ; extent number (SAVEXT).
                        ;
DC3E: 21C3E5   [10]     GETBLOCK: LD	HL,BLKSHFT	;get logical to physical conversion.
DC41: 4E       [17]     	LD	C,(HL)		;note that this is base 2 log of ratio.
DC42: 3AE3E5   [30]     	LD	A,(SAVNREC)	;get record number.
DC45: B7       [ 4]     GETBLK1:OR	A		;compute (A)=(A)/2^BLKSHFT.
DC46: 1F       [ 8]     	RRA	
DC47: 0D       [12]     	DEC	C
DC48: C245DC   [22|22]  	JP	NZ,GETBLK1
DC4B: 47       [26]     	LD	B,A		;save result in (B).
DC4C: 3E08     [33]     	LD	A,8
DC4E: 96       [40]     	SUB	(HL)
DC4F: 4F       [44]     	LD	C,A		;compute (C)=8-BLKSHFT.
DC50: 3AE2E5   [57]     	LD	A,(SAVEXT)
DC53: 0D       [ 4]     GETBLK2:DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT).
DC54: CA5CDC   [14|14]  	JP	Z,GETBLK3
DC57: B7       [18]     	OR	A
DC58: 17       [22]     	RLA	
DC59: C353DC   [32]     	JP	GETBLK2
DC5C: 80       [ 4]     GETBLK3:ADD	A,B
DC5D: C9       [14]     	RET	
                        ;
                        ;   Routine to extract the (BC) block byte from the fcb pointed
                        ; to by (PARAMS). If this is a big-disk, then these are 16 bit
                        ; block numbers, else they are 8 bit numbers.
                        ; Number is returned in (HL).
                        ;
DC5E: 2A43DB   [16]     EXTBLK:	LD	HL,(PARAMS)	;get fcb address.
DC61: 111000   [26]     	LD	DE,16		;block numbers start 16 bytes into fcb.
DC64: 19       [37]     	ADD	HL,DE
DC65: 09       [48]     	ADD	HL,BC
DC66: 3ADDE5   [61]     	LD	A,(BIGDISK)	;are we using a big-disk?
DC69: B7       [65]     	OR	A
DC6A: CA71DC   [75|75]  	JP	Z,EXTBLK1
DC6D: 6E       [82]     	LD	L,(HL)		;no, extract an 8 bit number from the fcb.
DC6E: 2600     [89]     	LD	H,0
DC70: C9       [99]     	RET	
DC71: 09       [11]     EXTBLK1:ADD	HL,BC		;yes, extract a 16 bit number.
DC72: 5E       [18]     	LD	E,(HL)
DC73: 23       [24]     	INC	HL
DC74: 56       [31]     	LD	D,(HL)
DC75: EB       [35]     	EX	DE,HL		;return in (HL).
DC76: C9       [45]     	RET	
                        ;
                        ;   Compute block number.
                        ;
DC77: CD3EDC   [17]     COMBLK:	CALL	GETBLOCK
DC7A: 4F       [21]     	LD	C,A
DC7B: 0600     [28]     	LD	B,0
DC7D: CD5EDC   [45]     	CALL	EXTBLK
DC80: 22E5E5   [61]     	LD	(BLKNMBR),HL
DC83: C9       [71]     	RET	
                        ;
                        ;   Check for a zero block number (unused).
                        ;
DC84: 2AE5E5   [16]     CHKBLK:	LD	HL,(BLKNMBR)
DC87: 7D       [20]     	LD	A,L		;is it zero?
DC88: B4       [24]     	OR	H
DC89: C9       [34]     	RET	
                        ;
                        ;   Adjust physical block (BLKNMBR) and convert to logical
                        ; sector (LOGSECT). This is the starting sector of this block.
                        ; The actual sector of interest is then added to this and the
                        ; resulting sector number is stored back in (BLKNMBR). This
                        ; will still have to be adjusted for the track number.
                        ;
DC8A: 3AC3E5   [13]     LOGICAL:LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
DC8D: 2AE5E5   [29]     	LD	HL,(BLKNMBR)	;get physical sector desired.
DC90: 29       [11]     LOGICL1:ADD	HL,HL		;compute logical sector number.
DC91: 3D       [15]     	DEC	A		;note logical sectors are 128 bytes long.
DC92: C290DC   [25|25]  	JP	NZ,LOGICL1
DC95: 22E7E5   [41]     	LD	(LOGSECT),HL	;save logical sector.
DC98: 3AC4E5   [54]     	LD	A,(BLKMASK)	;get block mask.
DC9B: 4F       [58]     	LD	C,A
DC9C: 3AE3E5   [71]     	LD	A,(SAVNREC)	;get next sector to access.
DC9F: A1       [75]     	AND	C		;extract the relative position within physical block.
DCA0: B5       [79]     	OR	L		;and add it too logical sector.
DCA1: 6F       [83]     	LD	L,A
DCA2: 22E5E5   [99]     	LD	(BLKNMBR),HL	;and store.
DCA5: C9       [109]    	RET	
                        ;
                        ;   Set (HL) to point to extent byte in fcb.
                        ;
DCA6: 2A43DB   [16]     SETEXT:	LD	HL,(PARAMS)
DCA9: 110C00   [26]     	LD	DE,12		;it is the twelth byte.
DCAC: 19       [37]     	ADD	HL,DE
DCAD: C9       [47]     	RET	
                        ;
                        ;   Set (HL) to point to record count byte in fcb and (DE) to
                        ; next record number byte.
                        ;
DCAE: 2A43DB   [16]     SETHLDE:LD	HL,(PARAMS)
DCB1: 110F00   [26]     	LD	DE,15		;record count byte (#15).
DCB4: 19       [37]     	ADD	HL,DE
DCB5: EB       [41]     	EX	DE,HL
DCB6: 211100   [51]     	LD	HL,17		;next record number (#32).
DCB9: 19       [62]     	ADD	HL,DE
DCBA: C9       [72]     	RET	
                        ;
                        ;   Save current file data from fcb.
                        ;
DCBB: CDAEDC   [17]     STRDATA:CALL	SETHLDE
DCBE: 7E       [24]     	LD	A,(HL)		;get and store record count byte.
DCBF: 32E3E5   [37]     	LD	(SAVNREC),A
DCC2: EB       [41]     	EX	DE,HL
DCC3: 7E       [48]     	LD	A,(HL)		;get and store next record number byte.
DCC4: 32E1E5   [61]     	LD	(SAVNXT),A
DCC7: CDA6DC   [78]     	CALL	SETEXT		;point to extent byte.
DCCA: 3AC5E5   [91]     	LD	A,(EXTMASK)	;get extent mask.
DCCD: A6       [98]     	AND	(HL)
DCCE: 32E2E5   [111]    	LD	(SAVEXT),A	;and save extent here.
DCD1: C9       [121]    	RET	
                        ;
                        ;   Set the next record to access. If (MODE) is set to 2, then
                        ; the last record byte (SAVNREC) has the correct number to access.
                        ; For sequential access, (MODE) will be equal to 1.
                        ;
DCD2: CDAEDC   [17]     SETNREC:CALL	SETHLDE
DCD5: 3AD5E5   [30]     	LD	A,(MODE)	;get sequential flag (=1).
DCD8: FE02     [37]     	CP	2		;a 2 indicates that no adder is needed.
DCDA: C2DEDC   [47|47]  	JP	NZ,STNREC1
DCDD: AF       [51]     	XOR	A		;clear adder (random access?).
DCDE: 4F       [ 4]     STNREC1:LD	C,A
DCDF: 3AE3E5   [17]     	LD	A,(SAVNREC)	;get last record number.
DCE2: 81       [21]     	ADD	A,C		;increment record count.
DCE3: 77       [28]     	LD	(HL),A		;and set fcb's next record byte.
DCE4: EB       [32]     	EX	DE,HL
DCE5: 3AE1E5   [45]     	LD	A,(SAVNXT)	;get next record byte from storage.
DCE8: 77       [52]     	LD	(HL),A		;and put this into fcb as number of records used.
DCE9: C9       [62]     	RET	
                        ;
                        ;   Shift (HL) right (C) bits.
                        ;
DCEA: 0C       [ 4]     SHIFTR:	INC	C
DCEB: 0D       [ 4]     SHIFTR1:DEC	C
DCEC: C8       [ 9|15]  	RET	Z
DCED: 7C       [13]     	LD	A,H
DCEE: B7       [17]     	OR	A
DCEF: 1F       [21]     	RRA	
DCF0: 67       [25]     	LD	H,A
DCF1: 7D       [29]     	LD	A,L
DCF2: 1F       [33]     	RRA	
DCF3: 6F       [37]     	LD	L,A
DCF4: C3EBDC   [47]     	JP	SHIFTR1
                        ;
                        ;   Compute the check-sum for the directory buffer. Return
                        ; integer sum in (A).
                        ;
DCF7: 0E80     [ 7]     CHECKSUM: LD	C,128		;length of buffer.
DCF9: 2AB9E5   [23]     	LD	HL,(DIRBUF)	;get its location.
DCFC: AF       [27]     	XOR	A		;clear summation byte.
DCFD: 86       [ 7]     CHKSUM1:ADD	A,(HL)		;and compute sum ignoring carries.
DCFE: 23       [13]     	INC	HL
DCFF: 0D       [17]     	DEC	C
DD00: C2FDDC   [27|27]  	JP	NZ,CHKSUM1
DD03: C9       [37]     	RET	
                        ;
                        ;   Shift (HL) left (C) bits.
                        ;
DD04: 0C       [ 4]     SHIFTL:	INC	C
DD05: 0D       [ 4]     SHIFTL1:DEC	C
DD06: C8       [ 9|15]  	RET	Z
DD07: 29       [20]     	ADD	HL,HL		;shift left 1 bit.
DD08: C305DD   [30]     	JP	SHIFTL1
                        ;
                        ;   Routine to set a bit in a 16 bit value contained in (BC).
                        ; The bit set depends on the current drive selection.
                        ;
DD0B: C5       [11]     SETBIT:	PUSH	BC		;save 16 bit word.
DD0C: 3A42DB   [24]     	LD	A,(ACTIVE)	;get active drive.
DD0F: 4F       [28]     	LD	C,A
DD10: 210100   [38]     	LD	HL,1
DD13: CD04DD   [55]     	CALL	SHIFTL		;shift bit 0 into place.
DD16: C1       [65]     	POP	BC		;now 'or' this with the original word.
DD17: 79       [69]     	LD	A,C
DD18: B5       [73]     	OR	L
DD19: 6F       [77]     	LD	L,A		;low byte done, do high byte.
DD1A: 78       [81]     	LD	A,B
DD1B: B4       [85]     	OR	H
DD1C: 67       [89]     	LD	H,A
DD1D: C9       [99]     	RET	
                        ;
                        ;   Extract the write protect status bit for the current drive.
                        ; The result is returned in (A), bit 0.
                        ;
DD1E: 2AADE5   [16]     GETWPRT:LD	HL,(WRTPRT)	;get status bytes.
DD21: 3A42DB   [29]     	LD	A,(ACTIVE)	;which drive is current?
DD24: 4F       [33]     	LD	C,A
DD25: CDEADC   [50]     	CALL	SHIFTR		;shift status such that bit 0 is the
DD28: 7D       [54]     	LD	A,L		;one of interest for this drive.
DD29: E601     [61]     	AND	01H		;and isolate it.
DD2B: C9       [71]     	RET	
                        ;
                        ;   Function to write protect the current disk.
                        ;
DD2C: 21ADE5   [10]     WRTPRTD:LD	HL,WRTPRT	;point to status word.
DD2F: 4E       [17]     	LD	C,(HL)		;set (BC) equal to the status.
DD30: 23       [23]     	INC	HL
DD31: 46       [30]     	LD	B,(HL)
DD32: CD0BDD   [47]     	CALL	SETBIT		;and set this bit according to current drive.
DD35: 22ADE5   [63]     	LD	(WRTPRT),HL	;then save.
DD38: 2AC8E5   [79]     	LD	HL,(DIRSIZE)	;now save directory size limit.
DD3B: 23       [85]     	INC	HL		;remember the last one.
DD3C: EB       [89]     	EX	DE,HL
DD3D: 2AB3E5   [105]    	LD	HL,(SCRATCH1)	;and store it here.
DD40: 73       [112]    	LD	(HL),E		;put low byte.
DD41: 23       [118]    	INC	HL
DD42: 72       [125]    	LD	(HL),D		;then high byte.
DD43: C9       [135]    	RET	
                        ;
                        ;   Check for a read only file.
                        ;
DD44: CD5EDD   [17]     CHKROFL:CALL	FCB2HL		;set (HL) to file entry in directory buffer.
DD47: 110900   [10]     CKROF1:	LD	DE,9		;look at bit 7 of the ninth byte.
DD4A: 19       [21]     	ADD	HL,DE
DD4B: 7E       [28]     	LD	A,(HL)
DD4C: 17       [32]     	RLA	
DD4D: D0       [37|43]  	RET	NC		;return if ok.
DD4E: 210FD8   [47]     	LD	HL,ROFILE	;else, print error message and terminate.
DD51: C34ADB   [57]     	JP	JUMPHL
                        ;
                        ;   Check the write protect status of the active disk.
                        ;
DD54: CD1EDD   [17]     CHKWPRT:CALL	GETWPRT
DD57: C8       [22|28]  	RET	Z		;return if ok.
DD58: 210DD8   [32]     	LD	HL,RODISK	;else print message and terminate.
DD5B: C34ADB   [42]     	JP	JUMPHL
                        ;
                        ;   Routine to set (HL) pointing to the proper entry in the
                        ; directory buffer.
                        ;
DD5E: 2AB9E5   [16]     FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer.
DD61: 3AE9E5   [29]     	LD	A,(FCBPOS)	;relative position of file.
                        ;
                        ;   Routine to add (A) to (HL).
                        ;
DD64: 85       [ 4]     ADDA2HL:ADD	A,L
DD65: 6F       [ 8]     	LD	L,A
DD66: D0       [13|19]  	RET	NC
DD67: 24       [17]     	INC	H		;take care of any carry.
DD68: C9       [27]     	RET	
                        ;
                        ;   Routine to get the 's2' byte from the fcb supplied in
                        ; the initial parameter specification.
                        ;
DD69: 2A43DB   [16]     GETS2:	LD	HL,(PARAMS)	;get address of fcb.
DD6C: 110E00   [26]     	LD	DE,14		;relative position of 's2'.
DD6F: 19       [37]     	ADD	HL,DE
DD70: 7E       [44]     	LD	A,(HL)		;extract this byte.
DD71: C9       [54]     	RET	
                        ;
                        ;   Clear the 's2' byte in the fcb.
                        ;
DD72: CD69DD   [17]     CLEARS2:CALL	GETS2		;this sets (HL) pointing to it.
DD75: 3600     [27]     	LD	(HL),0		;now clear it.
DD77: C9       [37]     	RET	
                        ;
                        ;   Set bit 7 in the 's2' byte of the fcb.
                        ;
DD78: CD69DD   [17]     SETS2B7:CALL	GETS2		;get the byte.
DD7B: F680     [24]     	OR	80H		;and set bit 7.
DD7D: 77       [31]     	LD	(HL),A		;then store.
DD7E: C9       [41]     	RET	
                        ;
                        ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
                        ; the difference. This checks to see if there are more file
                        ; names in the directory. We are at (FILEPOS) and there are
                        ; (SCRATCH1) of them to check.
                        ;
DD7F: 2AEAE5   [16]     MOREFLS:LD	HL,(FILEPOS)	;we are here.
DD82: EB       [20]     	EX	DE,HL
DD83: 2AB3E5   [36]     	LD	HL,(SCRATCH1)	;and don't go past here.
DD86: 7B       [40]     	LD	A,E		;compute difference but don't keep.
DD87: 96       [47]     	SUB	(HL)
DD88: 23       [53]     	INC	HL
DD89: 7A       [57]     	LD	A,D
DD8A: 9E       [64]     	SBC	A,(HL)		;set carry if no more names.
DD8B: C9       [74]     	RET	
                        ;
                        ;   Call this routine to prevent (SCRATCH1) from being greater
                        ; than (FILEPOS).
                        ;
DD8C: CD7FDD   [17]     CHKNMBR:CALL	MOREFLS		;SCRATCH1 too big?
DD8F: D8       [22|28]  	RET	C
DD90: 13       [28]     	INC	DE		;yes, reset it to (FILEPOS).
DD91: 72       [35]     	LD	(HL),D
DD92: 2B       [41]     	DEC	HL
DD93: 73       [48]     	LD	(HL),E
DD94: C9       [58]     	RET	
                        ;
                        ;   Compute (HL)=(DE)-(HL)
                        ;
DD95: 7B       [ 4]     SUBHL:	LD	A,E		;compute difference.
DD96: 95       [ 8]     	SUB	L
DD97: 6F       [12]     	LD	L,A		;store low byte.
DD98: 7A       [16]     	LD	A,D
DD99: 9C       [20]     	SBC	A,H
DD9A: 67       [24]     	LD	H,A		;and then high byte.
DD9B: C9       [34]     	RET	
                        ;
                        ;   Set the directory checksum byte.
                        ;
DD9C: 0EFF     [ 7]     SETDIR:	LD	C,0FFH
                        ;
                        ;   Routine to set or compare the directory checksum byte. If
                        ; (C)=0ffh, then this will set the checksum byte. Else the byte
                        ; will be checked. If the check fails (the disk has been changed),
                        ; then this disk will be write protected.
                        ;
DD9E: 2AECE5   [16]     CHECKDIR: LD	HL,(CKSUMTBL)
DDA1: EB       [20]     	EX	DE,HL
DDA2: 2ACCE5   [36]     	LD	HL,(ALLOC1)
DDA5: CD95DD   [53]     	CALL	SUBHL
DDA8: D0       [58|64]  	RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return.
DDA9: C5       [69]     	PUSH	BC
DDAA: CDF7DC   [86]     	CALL	CHECKSUM	;else compute checksum.
DDAD: 2ABDE5   [102]    	LD	HL,(CHKVECT)	;get address of checksum table.
DDB0: EB       [106]    	EX	DE,HL
DDB1: 2AECE5   [122]    	LD	HL,(CKSUMTBL)
DDB4: 19       [133]    	ADD	HL,DE		;set (HL) to point to byte for this drive.
DDB5: C1       [143]    	POP	BC
DDB6: 0C       [147]    	INC	C		;set or check ?
DDB7: CAC4DD   [157|157]	JP	Z,CHKDIR1
DDBA: BE       [164]    	CP	(HL)		;check them.
DDBB: C8       [169|175]	RET	Z		;return if they are the same.
DDBC: CD7FDD   [186]    	CALL	MOREFLS		;not the same, do we care?
DDBF: D0       [191|197]	RET	NC
DDC0: CD2CDD   [208]    	CALL	WRTPRTD		;yes, mark this as write protected.
DDC3: C9       [218]    	RET	
DDC4: 77       [ 7]     CHKDIR1:LD	(HL),A		;just set the byte.
DDC5: C9       [17]     	RET	
                        ;
                        ;   Do a write to the directory of the current disk.
                        ;
DDC6: CD9CDD   [17]     DIRWRITE: CALL	SETDIR		;set checksum byte.
DDC9: CDE0DD   [34]     	CALL	DIRDMA		;set directory dma address.
DDCC: 0E01     [41]     	LD	C,1		;tell the bios to actually write.
DDCE: CDB8DB   [58]     	CALL	DOWRITE		;then do the write.
DDD1: C3DADD   [68]     	JP	DEFDMA
                        ;
                        ;   Read from the directory.
                        ;
DDD4: CDE0DD   [17]     DIRREAD:CALL	DIRDMA		;set the directory dma address.
DDD7: CDB2DB   [34]     	CALL	DOREAD		;and read it.
                        ;
                        ;   Routine to set the dma address to the users choice.
                        ;
DDDA: 21B1E5   [10]     DEFDMA:	LD	HL,USERDMA	;reset the default dma address and return.
DDDD: C3E3DD   [20]     	JP	DIRDMA1
                        ;
                        ;   Routine to set the dma address for directory work.
                        ;
DDE0: 21B9E5   [10]     DIRDMA:	LD	HL,DIRBUF
                        ;
                        ;   Set the dma address. On entry, (HL) points to
                        ; word containing the desired dma address.
                        ;
DDE3: 4E       [ 7]     DIRDMA1:LD	C,(HL)
DDE4: 23       [13]     	INC	HL
DDE5: 46       [20]     	LD	B,(HL)		;setup (BC) and go to the bios to set it.
DDE6: C324E6   [30]     	JP	SETDMA
                        ;
                        ;   Move the directory buffer into user's dma space.
                        ;
DDE9: 2AB9E5   [16]     MOVEDIR:LD	HL,(DIRBUF)	;buffer is located here, and
DDEC: EB       [20]     	EX	DE,HL
DDED: 2AB1E5   [36]     	LD	HL,(USERDMA)	; put it here.
DDF0: 0E80     [43]     	LD	C,128		;this is its length.
DDF2: C34FDB   [53]     	JP	DE2HL		;move it now and return.
                        ;
                        ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
                        ;
DDF5: 21EAE5   [10]     CKFILPOS: LD	HL,FILEPOS
DDF8: 7E       [17]     	LD	A,(HL)
DDF9: 23       [23]     	INC	HL
DDFA: BE       [30]     	CP	(HL)		;are both bytes the same?
DDFB: C0       [35|41]  	RET	NZ
DDFC: 3C       [39]     	INC	A		;yes, but are they each 0ffh?
DDFD: C9       [49]     	RET	
                        ;
                        ;   Set location (FILEPOS) to 0ffffh.
                        ;
DDFE: 21FFFF   [10]     STFILPOS: LD	HL,0FFFFH
DE01: 22EAE5   [26]     	LD	(FILEPOS),HL
DE04: C9       [36]     	RET	
                        ;
                        ;   Move on to the next file position within the current
                        ; directory buffer. If no more exist, set pointer to 0ffffh
                        ; and the calling routine will check for this. Enter with (C)
                        ; equal to 0ffh to cause the checksum byte to be set, else we
                        ; will check this disk and set write protect if checksums are
                        ; not the same (applies only if another directory sector must
                        ; be read).
                        ;
DE05: 2AC8E5   [16]     NXENTRY:LD	HL,(DIRSIZE)	;get directory entry size limit.
DE08: EB       [20]     	EX	DE,HL
DE09: 2AEAE5   [36]     	LD	HL,(FILEPOS)	;get current count.
DE0C: 23       [42]     	INC	HL		;go on to the next one.
DE0D: 22EAE5   [58]     	LD	(FILEPOS),HL
DE10: CD95DD   [75]     	CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
DE13: D219DE   [85|85]  	JP	NC,NXENT1	;is there more room left?
DE16: C3FEDD   [95]     	JP	STFILPOS	;no. Set this flag and return.
DE19: 3AEAE5   [13]     NXENT1:	LD	A,(FILEPOS)	;get file position within directory.
DE1C: E603     [20]     	AND	03H		;only look within this sector (only 4 entries fit).
DE1E: 0605     [27]     	LD	B,5		;convert to relative position (32 bytes each).
DE20: 87       [ 4]     NXENT2:	ADD	A,A		;note that this is not efficient code.
DE21: 05       [ 8]     	DEC	B		;5 'ADD A's would be better.
DE22: C220DE   [18|18]  	JP	NZ,NXENT2
DE25: 32E9E5   [31]     	LD	(FCBPOS),A	;save it as position of fcb.
DE28: B7       [35]     	OR	A
DE29: C0       [40|46]  	RET	NZ		;return if we are within buffer.
DE2A: C5       [51]     	PUSH	BC
DE2B: CDC3DB   [68]     	CALL	TRKSEC		;we need the next directory sector.
DE2E: CDD4DD   [85]     	CALL	DIRREAD
DE31: C1       [95]     	POP	BC
DE32: C39EDD   [105]    	JP	CHECKDIR
                        ;
                        ;   Routine to to get a bit from the disk space allocation
                        ; map. It is returned in (A), bit position 0. On entry to here,
                        ; set (BC) to the block number on the disk to check.
                        ; On return, (D) will contain the original bit position for
                        ; this block number and (HL) will point to the address for it.
                        ;
DE35: 79       [ 4]     CKBITMAP: LD	A,C		;determine bit number of interest.
DE36: E607     [11]     	AND	07H		;compute (D)=(E)=(C and 7)+1.
DE38: 3C       [15]     	INC	A
DE39: 5F       [19]     	LD	E,A		;save particular bit number.
DE3A: 57       [23]     	LD	D,A
                        ;
                        ;   compute (BC)=(BC)/8.
                        ;
DE3B: 79       [27]     	LD	A,C
DE3C: 0F       [31]     	RRCA			;now shift right 3 bits.
DE3D: 0F       [35]     	RRCA	
DE3E: 0F       [39]     	RRCA	
DE3F: E61F     [46]     	AND	1FH		;and clear bits 7,6,5.
DE41: 4F       [50]     	LD	C,A
DE42: 78       [54]     	LD	A,B
DE43: 87       [58]     	ADD	A,A		;now shift (B) into bits 7,6,5.
DE44: 87       [62]     	ADD	A,A
DE45: 87       [66]     	ADD	A,A
DE46: 87       [70]     	ADD	A,A
DE47: 87       [74]     	ADD	A,A
DE48: B1       [78]     	OR	C		;and add in (C).
DE49: 4F       [82]     	LD	C,A		;ok, (C) ha been completed.
DE4A: 78       [86]     	LD	A,B		;is there a better way of doing this?
DE4B: 0F       [90]     	RRCA	
DE4C: 0F       [94]     	RRCA	
DE4D: 0F       [98]     	RRCA	
DE4E: E61F     [105]    	AND	1FH
DE50: 47       [109]    	LD	B,A		;and now (B) is completed.
                        ;
                        ;   use this as an offset into the disk space allocation
                        ; table.
                        ;
DE51: 2ABFE5   [125]    	LD	HL,(ALOCVECT)
DE54: 09       [136]    	ADD	HL,BC
DE55: 7E       [143]    	LD	A,(HL)		;now get correct byte.
DE56: 07       [ 4]     CKBMAP1:RLCA			;get correct bit into position 0.
DE57: 1D       [ 8]     	DEC	E
DE58: C256DE   [18|18]  	JP	NZ,CKBMAP1
DE5B: C9       [28]     	RET	
                        ;
                        ;   Set or clear the bit map such that block number (BC) will be marked
                        ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
                        ; 1 then it will be set (don't use anyother values).
                        ;
DE5C: D5       [11]     STBITMAP: PUSH	DE
DE5D: CD35DE   [28]     	CALL	CKBITMAP	;get the byte of interest.
DE60: E6FE     [35]     	AND	0FEH		;clear the affected bit.
DE62: C1       [45]     	POP	BC
DE63: B1       [49]     	OR	C		;and now set it acording to (C).
                        ;
                        ;  entry to restore the original bit position and then store
                        ; in table. (A) contains the value, (D) contains the bit
                        ; position (1-8), and (HL) points to the address within the
                        ; space allocation table for this byte.
                        ;
DE64: 0F       [ 4]     STBMAP1:RRCA			;restore original bit position.
DE65: 15       [ 8]     	DEC	D
DE66: C264DE   [18|18]  	JP	NZ,STBMAP1
DE69: 77       [25]     	LD	(HL),A		;and stor byte in table.
DE6A: C9       [35]     	RET	
                        ;
                        ;   Set/clear space used bits in allocation map for this file.
                        ; On entry, (C)=1 to set the map and (C)=0 to clear it.
                        ;
DE6B: CD5EDD   [17]     SETFILE:CALL	FCB2HL		;get address of fcb
DE6E: 111000   [27]     	LD	DE,16
DE71: 19       [38]     	ADD	HL,DE		;get to block number bytes.
DE72: C5       [49]     	PUSH	BC
DE73: 0E11     [56]     	LD	C,17		;check all 17 bytes (max) of table.
DE75: D1       [10]     SETFL1:	POP	DE
DE76: 0D       [14]     	DEC	C		;done all bytes yet?
DE77: C8       [19|25]  	RET	Z
DE78: D5       [30]     	PUSH	DE
DE79: 3ADDE5   [43]     	LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
DE7C: B7       [47]     	OR	A
DE7D: CA88DE   [57|57]  	JP	Z,SETFL2
DE80: C5       [68]     	PUSH	BC		;only 8 bit numbers. set (BC) to this one.
DE81: E5       [79]     	PUSH	HL
DE82: 4E       [86]     	LD	C,(HL)		;get low byte from table, always
DE83: 0600     [93]     	LD	B,0		;set high byte to zero.
DE85: C38EDE   [103]    	JP	SETFL3
DE88: 0D       [ 4]     SETFL2:	DEC	C		;for 16 bit block numbers, adjust counter.
DE89: C5       [15]     	PUSH	BC
DE8A: 4E       [22]     	LD	C,(HL)		;now get both the low and high bytes.
DE8B: 23       [28]     	INC	HL
DE8C: 46       [35]     	LD	B,(HL)
DE8D: E5       [46]     	PUSH	HL
DE8E: 79       [ 4]     SETFL3:	LD	A,C		;block used?
DE8F: B0       [ 8]     	OR	B
DE90: CA9DDE   [18|18]  	JP	Z,SETFL4
DE93: 2AC6E5   [34]     	LD	HL,(DSKSIZE)	;is this block number within the
DE96: 7D       [38]     	LD	A,L		;space on the disk?
DE97: 91       [42]     	SUB	C
DE98: 7C       [46]     	LD	A,H
DE99: 98       [50]     	SBC	A,B
DE9A: D45CDE   [60|67]  	CALL	NC,STBITMAP	;yes, set the proper bit.
DE9D: E1       [10]     SETFL4:	POP	HL		;point to next block number in fcb.
DE9E: 23       [16]     	INC	HL
DE9F: C1       [26]     	POP	BC
DEA0: C375DE   [36]     	JP	SETFL1
                        ;
                        ;   Construct the space used allocation bit map for the active
                        ; drive. If a file name starts with '$' and it is under the
                        ; current user number, then (STATUS) is set to minus 1. Otherwise
                        ; it is not set at all.
                        ;
DEA3: 2AC6E5   [16]     BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table.
DEA6: 0E03     [23]     	LD	C,3
DEA8: CDEADC   [40]     	CALL	SHIFTR		;(HL)=(HL)/8.
DEAB: 23       [46]     	INC	HL		;at lease 1 byte.
DEAC: 44       [50]     	LD	B,H
DEAD: 4D       [54]     	LD	C,L		;set (BC) to the allocation table length.
                        ;
                        ;   Initialize the bitmap for this drive. Right now, the first
                        ; two bytes are specified by the disk parameter block. However
                        ; a patch could be entered here if it were necessary to setup
                        ; this table in a special mannor. For example, the bios could
                        ; determine locations of 'bad blocks' and set them as already
                        ; 'used' in the map.
                        ;
DEAE: 2ABFE5   [70]     	LD	HL,(ALOCVECT)	;now zero out the table now.
DEB1: 3600     [10]     BITMAP1:LD	(HL),0
DEB3: 23       [16]     	INC	HL
DEB4: 0B       [22]     	DEC	BC
DEB5: 78       [26]     	LD	A,B
DEB6: B1       [30]     	OR	C
DEB7: C2B1DE   [40|40]  	JP	NZ,BITMAP1
DEBA: 2ACAE5   [56]     	LD	HL,(ALLOC0)	;get initial space used by directory.
DEBD: EB       [60]     	EX	DE,HL
DEBE: 2ABFE5   [76]     	LD	HL,(ALOCVECT)	;and put this into map.
DEC1: 73       [83]     	LD	(HL),E
DEC2: 23       [89]     	INC	HL
DEC3: 72       [96]     	LD	(HL),D
                        ;
                        ;   End of initialization portion.
                        ;
DEC4: CDA1DB   [113]    	CALL	HOMEDRV		;now home the drive.
DEC7: 2AB3E5   [129]    	LD	HL,(SCRATCH1)
DECA: 3603     [139]    	LD	(HL),3		;force next directory request to read
DECC: 23       [145]    	INC	HL		;in a sector.
DECD: 3600     [155]    	LD	(HL),0
DECF: CDFEDD   [172]    	CALL	STFILPOS	;clear initial file position also.
DED2: 0EFF     [ 7]     BITMAP2:LD	C,0FFH		;read next file name in directory
DED4: CD05DE   [24]     	CALL	NXENTRY		;and set checksum byte.
DED7: CDF5DD   [41]     	CALL	CKFILPOS	;is there another file?
DEDA: C8       [46|52]  	RET	Z
DEDB: CD5EDD   [63]     	CALL	FCB2HL		;yes, get its address.
DEDE: 3EE5     [70]     	LD	A,0E5H
DEE0: BE       [77]     	CP	(HL)		;empty file entry?
DEE1: CAD2DE   [87|87]  	JP	Z,BITMAP2
DEE4: 3A41DB   [100]    	LD	A,(USERNO)	;no, correct user number?
DEE7: BE       [107]    	CP	(HL)
DEE8: C2F6DE   [117|117]	JP	NZ,BITMAP3
DEEB: 23       [123]    	INC	HL
DEEC: 7E       [130]    	LD	A,(HL)		;yes, does name start with a '$'?
DEED: D624     [137]    	SUB	'$'
DEEF: C2F6DE   [147|147]	JP	NZ,BITMAP3
DEF2: 3D       [151]    	DEC	A		;yes, set atatus to minus one.
DEF3: 3245DB   [164]    	LD	(STATUS),A
DEF6: 0E01     [ 7]     BITMAP3:LD	C,1		;now set this file's space as used in bit map.
DEF8: CD6BDE   [24]     	CALL	SETFILE
DEFB: CD8CDD   [41]     	CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
DEFE: C3D2DE   [51]     	JP	BITMAP2
                        ;
                        ;   Set the status (STATUS) and return.
                        ;
DF01: 3AD4E5   [13]     STSTATUS: LD	A,(FNDSTAT)
DF04: C301DB   [23]     	JP	SETSTAT
                        ;
                        ;   Check extents in (A) and (C). Set the zero flag if they
                        ; are the same. The number of 16k chunks of disk space that
                        ; the directory extent covers is expressad is (EXTMASK+1).
                        ; No registers are modified.
                        ;
DF07: C5       [11]     SAMEXT:	PUSH	BC
DF08: F5       [22]     	PUSH	AF
DF09: 3AC5E5   [35]     	LD	A,(EXTMASK)	;get extent mask and use it to
DF0C: 2F       [39]     	CPL			;to compare both extent numbers.
DF0D: 47       [43]     	LD	B,A		;save resulting mask here.
DF0E: 79       [47]     	LD	A,C		;mask first extent and save in (C).
DF0F: A0       [51]     	AND	B
DF10: 4F       [55]     	LD	C,A
DF11: F1       [65]     	POP	AF		;now mask second extent and compare
DF12: A0       [69]     	AND	B		;with the first one.
DF13: 91       [73]     	SUB	C
DF14: E61F     [80]     	AND	1FH		;(* only check buts 0-4 *)
DF16: C1       [90]     	POP	BC		;the zero flag is set if they are the same.
DF17: C9       [100]    	RET			;restore (BC) and return.
                        ;
                        ;   Search for the first occurence of a file name. On entry,
                        ; register (C) should contain the number of bytes of the fcb
                        ; that must match.
                        ;
DF18: 3EFF     [ 7]     FINDFST:LD	A,0FFH
DF1A: 32D4E5   [20]     	LD	(FNDSTAT),A
DF1D: 21D8E5   [30]     	LD	HL,COUNTER	;save character count.
DF20: 71       [37]     	LD	(HL),C
DF21: 2A43DB   [53]     	LD	HL,(PARAMS)	;get filename to match.
DF24: 22D9E5   [69]     	LD	(SAVEFCB),HL	;and save.
DF27: CDFEDD   [86]     	CALL	STFILPOS	;clear initial file position (set to 0ffffh).
DF2A: CDA1DB   [103]    	CALL	HOMEDRV		;home the drive.
                        ;
                        ;   Entry to locate the next occurence of a filename within the
                        ; directory. The disk is not expected to have been changed. If
                        ; it was, then it will be write protected.
                        ;
DF2D: 0E00     [ 7]     FINDNXT:LD	C,0		;write protect the disk if changed.
DF2F: CD05DE   [24]     	CALL	NXENTRY		;get next filename entry in directory.
DF32: CDF5DD   [41]     	CALL	CKFILPOS	;is file position = 0ffffh?
DF35: CA94DF   [51|51]  	JP	Z,FNDNXT6	;yes, exit now then.
DF38: 2AD9E5   [67]     	LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
DF3B: EB       [71]     	EX	DE,HL
DF3C: 1A       [78]     	LD	A,(DE)
DF3D: FEE5     [85]     	CP	0E5H		;empty directory entry?
DF3F: CA4ADF   [95|95]  	JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *)
DF42: D5       [106]    	PUSH	DE
DF43: CD7FDD   [123]    	CALL	MOREFLS		;more files in directory?
DF46: D1       [133]    	POP	DE
DF47: D294DF   [143|143]	JP	NC,FNDNXT6	;no more. Exit now.
DF4A: CD5EDD   [17]     FNDNXT1:CALL	FCB2HL		;get address of this fcb in directory.
DF4D: 3AD8E5   [30]     	LD	A,(COUNTER)	;get number of bytes (characters) to check.
DF50: 4F       [34]     	LD	C,A
DF51: 0600     [41]     	LD	B,0		;initialize byte position counter.
DF53: 79       [ 4]     FNDNXT2:LD	A,C		;are we done with the compare?
DF54: B7       [ 8]     	OR	A
DF55: CA83DF   [18|18]  	JP	Z,FNDNXT5
DF58: 1A       [25]     	LD	A,(DE)		;no, check next byte.
DF59: FE3F     [32]     	CP	'?'		;don't care about this character?
DF5B: CA7CDF   [42|42]  	JP	Z,FNDNXT4
DF5E: 78       [46]     	LD	A,B		;get bytes position in fcb.
DF5F: FE0D     [53]     	CP	13		;don't care about the thirteenth byte either.
DF61: CA7CDF   [63|63]  	JP	Z,FNDNXT4
DF64: FE0C     [70]     	CP	12		;extent byte?
DF66: 1A       [77]     	LD	A,(DE)
DF67: CA73DF   [87|87]  	JP	Z,FNDNXT3
DF6A: 96       [94]     	SUB	(HL)		;otherwise compare characters.
DF6B: E67F     [101]    	AND	7FH
DF6D: C22DDF   [111|111]	JP	NZ,FINDNXT	;not the same, check next entry.
DF70: C37CDF   [121]    	JP	FNDNXT4		;so far so good, keep checking.
DF73: C5       [11]     FNDNXT3:PUSH	BC		;check the extent byte here.
DF74: 4E       [18]     	LD	C,(HL)
DF75: CD07DF   [35]     	CALL	SAMEXT
DF78: C1       [45]     	POP	BC
DF79: C22DDF   [55|55]  	JP	NZ,FINDNXT	;not the same, look some more.
                        ;
                        ;   So far the names compare. Bump pointers to the next byte
                        ; and continue until all (C) characters have been checked.
                        ;
DF7C: 13       [ 6]     FNDNXT4:INC	DE		;bump pointers.
DF7D: 23       [12]     	INC	HL
DF7E: 04       [16]     	INC	B
DF7F: 0D       [20]     	DEC	C		;adjust character counter.
DF80: C353DF   [30]     	JP	FNDNXT2
DF83: 3AEAE5   [13]     FNDNXT5:LD	A,(FILEPOS)	;return the position of this entry.
DF86: E603     [20]     	AND	03H
DF88: 3245DB   [33]     	LD	(STATUS),A
DF8B: 21D4E5   [43]     	LD	HL,FNDSTAT
DF8E: 7E       [50]     	LD	A,(HL)
DF8F: 17       [54]     	RLA	
DF90: D0       [59|65]  	RET	NC
DF91: AF       [63]     	XOR	A
DF92: 77       [70]     	LD	(HL),A
DF93: C9       [80]     	RET	
                        ;
                        ;   Filename was not found. Set appropriate status.
                        ;
DF94: CDFEDD   [17]     FNDNXT6:CALL	STFILPOS	;set (FILEPOS) to 0ffffh.
DF97: 3EFF     [24]     	LD	A,0FFH		;say not located.
DF99: C301DB   [34]     	JP	SETSTAT
                        ;
                        ;   Erase files from the directory. Only the first byte of the
                        ; fcb will be affected. It is set to (E5).
                        ;
DF9C: CD54DD   [17]     ERAFILE:CALL	CHKWPRT		;is disk write protected?
DF9F: 0E0C     [24]     	LD	C,12		;only compare file names.
DFA1: CD18DF   [41]     	CALL	FINDFST		;get first file name.
DFA4: CDF5DD   [17]     ERAFIL1:CALL	CKFILPOS	;any found?
DFA7: C8       [22|28]  	RET	Z		;nope, we must be done.
DFA8: CD44DD   [39]     	CALL	CHKROFL		;is file read only?
DFAB: CD5EDD   [56]     	CALL	FCB2HL		;nope, get address of fcb and
DFAE: 36E5     [66]     	LD	(HL),0E5H	;set first byte to 'empty'.
DFB0: 0E00     [73]     	LD	C,0		;clear the space from the bit map.
DFB2: CD6BDE   [90]     	CALL	SETFILE
DFB5: CDC6DD   [107]    	CALL	DIRWRITE	;now write the directory sector back out.
DFB8: CD2DDF   [124]    	CALL	FINDNXT		;find the next file name.
DFBB: C3A4DF   [134]    	JP	ERAFIL1		;and repeat process.
                        ;
                        ;   Look through the space allocation map (bit map) for the
                        ; next available block. Start searching at block number (BC-1).
                        ; The search procedure is to look for an empty block that is
                        ; before the starting block. If not empty, look at a later
                        ; block number. In this way, we return the closest empty block
                        ; on either side of the 'target' block number. This will speed
                        ; access on random devices. For serial devices, this should be
                        ; changed to look in the forward direction first and then start
                        ; at the front and search some more.
                        ;
                        ;   On return, (DE)= block number that is empty and (HL) =0
                        ; if no empry block was found.
                        ;
DFBE: 50       [ 4]     FNDSPACE: LD	D,B		;set (DE) as the block that is checked.
DFBF: 59       [ 8]     	LD	E,C
                        ;
                        ;   Look before target block. Registers (BC) are used as the lower
                        ; pointer and (DE) as the upper pointer.
                        ;
DFC0: 79       [ 4]     FNDSPA1:LD	A,C		;is block 0 specified?
DFC1: B0       [ 8]     	OR	B
DFC2: CAD1DF   [18|18]  	JP	Z,FNDSPA2
DFC5: 0B       [24]     	DEC	BC		;nope, check previous block.
DFC6: D5       [35]     	PUSH	DE
DFC7: C5       [46]     	PUSH	BC
DFC8: CD35DE   [63]     	CALL	CKBITMAP
DFCB: 1F       [67]     	RRA			;is this block empty?
DFCC: D2ECDF   [77|77]  	JP	NC,FNDSPA3	;yes. use this.
                        ;
                        ;   Note that the above logic gets the first block that it finds
                        ; that is empty. Thus a file could be written 'backward' making
                        ; it very slow to access. This could be changed to look for the
                        ; first empty block and then continue until the start of this
                        ; empty space is located and then used that starting block.
                        ; This should help speed up access to some files especially on
                        ; a well used disk with lots of fairly small 'holes'.
                        ;
DFCF: C1       [87]     	POP	BC		;nope, check some more.
DFD0: D1       [97]     	POP	DE
                        ;
                        ;   Now look after target block.
                        ;
DFD1: 2AC6E5   [16]     FNDSPA2:LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
DFD4: 7B       [20]     	LD	A,E
DFD5: 95       [24]     	SUB	L
DFD6: 7A       [28]     	LD	A,D
DFD7: 9C       [32]     	SBC	A,H
DFD8: D2F4DF   [42|42]  	JP	NC,FNDSPA4
DFDB: 13       [48]     	INC	DE		;yes, move on to next one.
DFDC: C5       [59]     	PUSH	BC
DFDD: D5       [70]     	PUSH	DE
DFDE: 42       [74]     	LD	B,D
DFDF: 4B       [78]     	LD	C,E
DFE0: CD35DE   [95]     	CALL	CKBITMAP	;check it.
DFE3: 1F       [99]     	RRA			;empty?
DFE4: D2ECDF   [109|109]	JP	NC,FNDSPA3
DFE7: D1       [119]    	POP	DE		;nope, continue searching.
DFE8: C1       [129]    	POP	BC
DFE9: C3C0DF   [139]    	JP	FNDSPA1
                        ;
                        ;   Empty block found. Set it as used and return with (HL)
                        ; pointing to it (true?).
                        ;
DFEC: 17       [ 4]     FNDSPA3:RLA			;reset byte.
DFED: 3C       [ 8]     	INC	A		;and set bit 0.
DFEE: CD64DE   [25]     	CALL	STBMAP1		;update bit map.
DFF1: E1       [35]     	POP	HL		;set return registers.
DFF2: D1       [45]     	POP	DE
DFF3: C9       [55]     	RET	
                        ;
                        ;   Free block was not found. If (BC) is not zero, then we have
                        ; not checked all of the disk space.
                        ;
DFF4: 79       [ 4]     FNDSPA4:LD	A,C
DFF5: B0       [ 8]     	OR	B
DFF6: C2C0DF   [18|18]  	JP	NZ,FNDSPA1
DFF9: 210000   [28]     	LD	HL,0		;set 'not found' status.
DFFC: C9       [38]     	RET	
                        ;
                        ;   Move a complete fcb entry into the directory and write it.
                        ;
DFFD: 0E00     [ 7]     FCBSET:	LD	C,0
DFFF: 1E20     [14]     	LD	E,32		;length of each entry.
                        ;
                        ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
                        ; fcb in directory starting at relative byte (C). This updated
                        ; directory buffer is then written to the disk.
                        ;
E001: D5       [11]     UPDATE:	PUSH	DE
E002: 0600     [18]     	LD	B,0		;set (BC) to relative byte position.
E004: 2A43DB   [34]     	LD	HL,(PARAMS)	;get address of fcb.
E007: 09       [45]     	ADD	HL,BC		;compute starting byte.
E008: EB       [49]     	EX	DE,HL
E009: CD5EDD   [66]     	CALL	FCB2HL		;get address of fcb to update in directory.
E00C: C1       [76]     	POP	BC		;set (C) to number of bytes to change.
E00D: CD4FDB   [93]     	CALL	DE2HL
E010: CDC3DB   [17]     UPDATE1:CALL	TRKSEC		;determine the track and sector affected.
E013: C3C6DD   [27]     	JP	DIRWRITE	;then write this sector out.
                        ;
                        ;   Routine to change the name of all files on the disk with a
                        ; specified name. The fcb contains the current name as the
                        ; first 12 characters and the new name 16 bytes into the fcb.
                        ;
E016: CD54DD   [17]     CHGNAMES: CALL	CHKWPRT		;check for a write protected disk.
E019: 0E0C     [24]     	LD	C,12		;match first 12 bytes of fcb only.
E01B: CD18DF   [41]     	CALL	FINDFST		;get first name.
E01E: 2A43DB   [57]     	LD	HL,(PARAMS)	;get address of fcb.
E021: 7E       [64]     	LD	A,(HL)		;get user number.
E022: 111000   [74]     	LD	DE,16		;move over to desired name.
E025: 19       [85]     	ADD	HL,DE
E026: 77       [92]     	LD	(HL),A		;keep same user number.
E027: CDF5DD   [17]     CHGNAM1:CALL	CKFILPOS	;any matching file found?
E02A: C8       [22|28]  	RET	Z		;no, we must be done.
E02B: CD44DD   [39]     	CALL	CHKROFL		;check for read only file.
E02E: 0E10     [46]     	LD	C,16		;start 16 bytes into fcb.
E030: 1E0C     [53]     	LD	E,12		;and update the first 12 bytes of directory.
E032: CD01E0   [70]     	CALL	UPDATE
E035: CD2DDF   [87]     	CALL	FINDNXT		;get te next file name.
E038: C327E0   [97]     	JP	CHGNAM1		;and continue.
                        ;
                        ;   Update a files attributes. The procedure is to search for
                        ; every file with the same name as shown in fcb (ignoring bit 7)
                        ; and then to update it (which includes bit 7). No other changes
                        ; are made.
                        ;
E03B: 0E0C     [ 7]     SAVEATTR: LD	C,12		;match first 12 bytes.
E03D: CD18DF   [24]     	CALL	FINDFST		;look for first filename.
E040: CDF5DD   [17]     SAVATR1:CALL	CKFILPOS	;was one found?
E043: C8       [22|28]  	RET	Z		;nope, we must be done.
E044: 0E00     [29]     	LD	C,0		;yes, update the first 12 bytes now.
E046: 1E0C     [36]     	LD	E,12
E048: CD01E0   [53]     	CALL	UPDATE		;update filename and write directory.
E04B: CD2DDF   [70]     	CALL	FINDNXT		;and get the next file.
E04E: C340E0   [80]     	JP	SAVATR1		;then continue until done.
                        ;
                        ;  Open a file (name specified in fcb).
                        ;
E051: 0E0F     [ 7]     OPENIT:	LD	C,15		;compare the first 15 bytes.
E053: CD18DF   [24]     	CALL	FINDFST		;get the first one in directory.
E056: CDF5DD   [41]     	CALL	CKFILPOS	;any at all?
E059: C8       [46|52]  	RET	Z
E05A: CDA6DC   [17]     OPENIT1:CALL	SETEXT		;point to extent byte within users fcb.
E05D: 7E       [24]     	LD	A,(HL)		;and get it.
E05E: F5       [35]     	PUSH	AF		;save it and address.
E05F: E5       [46]     	PUSH	HL
E060: CD5EDD   [63]     	CALL	FCB2HL		;point to fcb in directory.
E063: EB       [67]     	EX	DE,HL
E064: 2A43DB   [83]     	LD	HL,(PARAMS)	;this is the users copy.
E067: 0E20     [90]     	LD	C,32		;move it into users space.
E069: D5       [101]    	PUSH	DE
E06A: CD4FDB   [118]    	CALL	DE2HL
E06D: CD78DD   [135]    	CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
E070: D1       [145]    	POP	DE		;now get the extent byte from this fcb.
E071: 210C00   [155]    	LD	HL,12
E074: 19       [166]    	ADD	HL,DE
E075: 4E       [173]    	LD	C,(HL)		;into (C).
E076: 210F00   [183]    	LD	HL,15		;now get the record count byte into (B).
E079: 19       [194]    	ADD	HL,DE
E07A: 46       [201]    	LD	B,(HL)
E07B: E1       [211]    	POP	HL		;keep the same extent as the user had originally.
E07C: F1       [221]    	POP	AF
E07D: 77       [228]    	LD	(HL),A
E07E: 79       [232]    	LD	A,C		;is it the same as in the directory fcb?
E07F: BE       [239]    	CP	(HL)
E080: 78       [243]    	LD	A,B		;if yes, then use the same record count.
E081: CA8BE0   [253|253]	JP	Z,OPENIT2
E084: 3E00     [260]    	LD	A,0		;if the user specified an extent greater than
E086: DA8BE0   [270|270]	JP	C,OPENIT2	;the one in the directory, then set record count to 0.
E089: 3E80     [277]    	LD	A,128		;otherwise set to maximum.
E08B: 2A43DB   [16]     OPENIT2:LD	HL,(PARAMS)	;set record count in users fcb to (A).
E08E: 110F00   [26]     	LD	DE,15
E091: 19       [37]     	ADD	HL,DE		;compute relative position.
E092: 77       [44]     	LD	(HL),A		;and set the record count.
E093: C9       [54]     	RET	
                        ;
                        ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
                        ; point to a zero value (16 bit).
                        ;   Return with zero flag set it (DE) was moved. Registers (DE)
                        ; and (HL) are not changed. However (A) is.
                        ;
E094: 7E       [ 7]     MOVEWORD: LD	A,(HL)		;check for a zero word.
E095: 23       [13]     	INC	HL
E096: B6       [20]     	OR	(HL)		;both bytes zero?
E097: 2B       [26]     	DEC	HL
E098: C0       [31|37]  	RET	NZ		;nope, just return.
E099: 1A       [38]     	LD	A,(DE)		;yes, move two bytes from (DE) into
E09A: 77       [45]     	LD	(HL),A		;this zero space.
E09B: 13       [51]     	INC	DE
E09C: 23       [57]     	INC	HL
E09D: 1A       [64]     	LD	A,(DE)
E09E: 77       [71]     	LD	(HL),A
E09F: 1B       [77]     	DEC	DE		;don't disturb these registers.
E0A0: 2B       [83]     	DEC	HL
E0A1: C9       [93]     	RET	
                        ;
                        ;   Get here to close a file specified by (fcb).
                        ;
E0A2: AF       [ 4]     CLOSEIT:XOR	A		;clear status and file position bytes.
E0A3: 3245DB   [17]     	LD	(STATUS),A
E0A6: 32EAE5   [30]     	LD	(FILEPOS),A
E0A9: 32EBE5   [43]     	LD	(FILEPOS+1),A
E0AC: CD1EDD   [60]     	CALL	GETWPRT		;get write protect bit for this drive.
E0AF: C0       [65|71]  	RET	NZ		;just return if it is set.
E0B0: CD69DD   [82]     	CALL	GETS2		;else get the 's2' byte.
E0B3: E680     [89]     	AND	80H		;and look at bit 7 (file unmodified?).
E0B5: C0       [94|100] 	RET	NZ		;just return if set.
E0B6: 0E0F     [101]    	LD	C,15		;else look up this file in directory.
E0B8: CD18DF   [118]    	CALL	FINDFST
E0BB: CDF5DD   [135]    	CALL	CKFILPOS	;was it found?
E0BE: C8       [140|146]	RET	Z		;just return if not.
E0BF: 011000   [150]    	LD	BC,16		;set (HL) pointing to records used section.
E0C2: CD5EDD   [167]    	CALL	FCB2HL
E0C5: 09       [178]    	ADD	HL,BC
E0C6: EB       [182]    	EX	DE,HL
E0C7: 2A43DB   [198]    	LD	HL,(PARAMS)	;do the same for users specified fcb.
E0CA: 09       [209]    	ADD	HL,BC
E0CB: 0E10     [216]    	LD	C,16		;this many bytes are present in this extent.
E0CD: 3ADDE5   [13]     CLOSEIT1: LD	A,(BIGDISK)	;8 or 16 bit record numbers?
E0D0: B7       [17]     	OR	A
E0D1: CAE8E0   [27|27]  	JP	Z,CLOSEIT4
E0D4: 7E       [34]     	LD	A,(HL)		;just 8 bit. Get one from users fcb.
E0D5: B7       [38]     	OR	A
E0D6: 1A       [45]     	LD	A,(DE)		;now get one from directory fcb.
E0D7: C2DBE0   [55|55]  	JP	NZ,CLOSEIT2
E0DA: 77       [62]     	LD	(HL),A		;users byte was zero. Update from directory.
E0DB: B7       [ 4]     CLOSEIT2: OR	A
E0DC: C2E1E0   [14|14]  	JP	NZ,CLOSEIT3
E0DF: 7E       [21]     	LD	A,(HL)		;directories byte was zero, update from users fcb.
E0E0: 12       [28]     	LD	(DE),A
E0E1: BE       [ 7]     CLOSEIT3: CP	(HL)		;if neither one of these bytes were zero,
E0E2: C21FE1   [17|17]  	JP	NZ,CLOSEIT7	;then close error if they are not the same.
E0E5: C3FDE0   [27]     	JP	CLOSEIT5	;ok so far, get to next byte in fcbs.
E0E8: CD94E0   [17]     CLOSEIT4: CALL	MOVEWORD	;update users fcb if it is zero.
E0EB: EB       [21]     	EX	DE,HL
E0EC: CD94E0   [38]     	CALL	MOVEWORD	;update directories fcb if it is zero.
E0EF: EB       [42]     	EX	DE,HL
E0F0: 1A       [49]     	LD	A,(DE)		;if these two values are no different,
E0F1: BE       [56]     	CP	(HL)		;then a close error occured.
E0F2: C21FE1   [66|66]  	JP	NZ,CLOSEIT7
E0F5: 13       [72]     	INC	DE		;check second byte.
E0F6: 23       [78]     	INC	HL
E0F7: 1A       [85]     	LD	A,(DE)
E0F8: BE       [92]     	CP	(HL)
E0F9: C21FE1   [102|102]	JP	NZ,CLOSEIT7
E0FC: 0D       [106]    	DEC	C		;remember 16 bit values.
E0FD: 13       [ 6]     CLOSEIT5: INC	DE		;bump to next item in table.
E0FE: 23       [12]     	INC	HL
E0FF: 0D       [16]     	DEC	C		;there are 16 entries only.
E100: C2CDE0   [26|26]  	JP	NZ,CLOSEIT1	;continue if more to do.
E103: 01ECFF   [36]     	LD	BC,0FFECH	;backup 20 places (extent byte).
E106: 09       [47]     	ADD	HL,BC
E107: EB       [51]     	EX	DE,HL
E108: 09       [62]     	ADD	HL,BC
E109: 1A       [69]     	LD	A,(DE)
E10A: BE       [76]     	CP	(HL)		;directory's extent already greater than the
E10B: DA17E1   [86|86]  	JP	C,CLOSEIT6	;users extent?
E10E: 77       [93]     	LD	(HL),A		;no, update directory extent.
E10F: 010300   [103]    	LD	BC,3		;and update the record count byte in
E112: 09       [114]    	ADD	HL,BC		;directories fcb.
E113: EB       [118]    	EX	DE,HL
E114: 09       [129]    	ADD	HL,BC
E115: 7E       [136]    	LD	A,(HL)		;get from user.
E116: 12       [143]    	LD	(DE),A		;and put in directory.
E117: 3EFF     [ 7]     CLOSEIT6: LD	A,0FFH		;set 'was open and is now closed' byte.
E119: 32D2E5   [20]     	LD	(CLOSEFLG),A
E11C: C310E0   [30]     	JP	UPDATE1		;update the directory now.
E11F: 2145DB   [10]     CLOSEIT7: LD	HL,STATUS	;set return status and then return.
E122: 35       [21]     	DEC	(HL)
E123: C9       [31]     	RET	
                        ;
                        ;   Routine to get the next empty space in the directory. It
                        ; will then be cleared for use.
                        ;
E124: CD54DD   [17]     GETEMPTY: CALL	CHKWPRT		;make sure disk is not write protected.
E127: 2A43DB   [33]     	LD	HL,(PARAMS)	;save current parameters (fcb).
E12A: E5       [44]     	PUSH	HL
E12B: 21ACE5   [54]     	LD	HL,EMPTYFCB	;use special one for empty space.
E12E: 2243DB   [70]     	LD	(PARAMS),HL
E131: 0E01     [77]     	LD	C,1		;search for first empty spot in directory.
E133: CD18DF   [94]     	CALL	FINDFST		;(* only check first byte *)
E136: CDF5DD   [111]    	CALL	CKFILPOS	;none?
E139: E1       [121]    	POP	HL
E13A: 2243DB   [137]    	LD	(PARAMS),HL	;restore original fcb address.
E13D: C8       [142|148]	RET	Z		;return if no more space.
E13E: EB       [146]    	EX	DE,HL
E13F: 210F00   [156]    	LD	HL,15		;point to number of records for this file.
E142: 19       [167]    	ADD	HL,DE
E143: 0E11     [174]    	LD	C,17		;and clear all of this space.
E145: AF       [178]    	XOR	A
E146: 77       [ 7]     GETMT1:	LD	(HL),A
E147: 23       [13]     	INC	HL
E148: 0D       [17]     	DEC	C
E149: C246E1   [27|27]  	JP	NZ,GETMT1
E14C: 210D00   [37]     	LD	HL,13		;clear the 's1' byte also.
E14F: 19       [48]     	ADD	HL,DE
E150: 77       [55]     	LD	(HL),A
E151: CD8CDD   [72]     	CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
E154: CDFDDF   [89]     	CALL	FCBSET		;write out this fcb entry to directory.
E157: C378DD   [99]     	JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
                        ;
                        ;   Routine to close the current extent and open the next one
                        ; for reading.
                        ;
E15A: AF       [ 4]     GETNEXT:XOR	A
E15B: 32D2E5   [17]     	LD	(CLOSEFLG),A	;clear close flag.
E15E: CDA2E0   [34]     	CALL	CLOSEIT		;close this extent.
E161: CDF5DD   [51]     	CALL	CKFILPOS
E164: C8       [56|62]  	RET	Z		;not there???
E165: 2A43DB   [72]     	LD	HL,(PARAMS)	;get extent byte.
E168: 010C00   [82]     	LD	BC,12
E16B: 09       [93]     	ADD	HL,BC
E16C: 7E       [100]    	LD	A,(HL)		;and increment it.
E16D: 3C       [104]    	INC	A
E16E: E61F     [111]    	AND	1FH		;keep within range 0-31.
E170: 77       [118]    	LD	(HL),A
E171: CA83E1   [128|128]	JP	Z,GTNEXT1	;overflow?
E174: 47       [132]    	LD	B,A		;mask extent byte.
E175: 3AC5E5   [145]    	LD	A,(EXTMASK)
E178: A0       [149]    	AND	B
E179: 21D2E5   [159]    	LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
E17C: A6       [166]    	AND	(HL)
E17D: CA8EE1   [176|176]	JP	Z,GTNEXT2	;if zero, we must read in next extent.
E180: C3ACE1   [186]    	JP	GTNEXT3		;else, it is already in memory.
E183: 010200   [10]     GTNEXT1:LD	BC,2		;Point to the 's2' byte.
E186: 09       [21]     	ADD	HL,BC
E187: 34       [32]     	INC	(HL)		;and bump it.
E188: 7E       [39]     	LD	A,(HL)		;too many extents?
E189: E60F     [46]     	AND	0FH
E18B: CAB6E1   [56|56]  	JP	Z,GTNEXT5	;yes, set error code.
                        ;
                        ;   Get here to open the next extent.
                        ;
E18E: 0E0F     [ 7]     GTNEXT2:LD	C,15		;set to check first 15 bytes of fcb.
E190: CD18DF   [24]     	CALL	FINDFST		;find the first one.
E193: CDF5DD   [41]     	CALL	CKFILPOS	;none available?
E196: C2ACE1   [51|51]  	JP	NZ,GTNEXT3
E199: 3AD3E5   [64]     	LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
E19C: 3C       [68]     	INC	A		;0ffh means reading (so not possible).
E19D: CAB6E1   [78|78]  	JP	Z,GTNEXT5	;or an error.
E1A0: CD24E1   [95]     	CALL	GETEMPTY	;we are writing, get an empty entry.
E1A3: CDF5DD   [112]    	CALL	CKFILPOS	;none?
E1A6: CAB6E1   [122|122]	JP	Z,GTNEXT5	;error if true.
E1A9: C3AFE1   [132]    	JP	GTNEXT4		;else we are almost done.
E1AC: CD5AE0   [17]     GTNEXT3:CALL	OPENIT1		;open this extent.
E1AF: CDBBDC   [17]     GTNEXT4:CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
E1B2: AF       [21]     	XOR	A		;clear status and return.
E1B3: C301DB   [31]     	JP	SETSTAT
                        ;
                        ;   Error in extending the file. Too many extents were needed
                        ; or not enough space on the disk.
                        ;
E1B6: CD05DB   [17]     GTNEXT5:CALL	IOERR1		;set error code, clear bit 7 of 's2'
E1B9: C378DD   [27]     	JP	SETS2B7		;so this is not written on a close.
                        ;
                        ;   Read a sequential file.
                        ;
E1BC: 3E01     [ 7]     RDSEQ:	LD	A,1		;set sequential access mode.
E1BE: 32D5E5   [20]     	LD	(MODE),A
E1C1: 3EFF     [ 7]     RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space.
E1C3: 32D3E5   [20]     	LD	(RDWRTFLG),A
E1C6: CDBBDC   [37]     	CALL	STRDATA		;put rec# and ext# into fcb.
E1C9: 3AE3E5   [50]     	LD	A,(SAVNREC)	;get next record to read.
E1CC: 21E1E5   [60]     	LD	HL,SAVNXT	;get number of records in extent.
E1CF: BE       [67]     	CP	(HL)		;within this extent?
E1D0: DAE6E1   [77|77]  	JP	C,RDSEQ2
E1D3: FE80     [84]     	CP	128		;no. Is this extent fully used?
E1D5: C2FBE1   [94|94]  	JP	NZ,RDSEQ3	;no. End-of-file.
E1D8: CD5AE1   [111]    	CALL	GETNEXT		;yes, open the next one.
E1DB: AF       [115]    	XOR	A		;reset next record to read.
E1DC: 32E3E5   [128]    	LD	(SAVNREC),A
E1DF: 3A45DB   [141]    	LD	A,(STATUS)	;check on open, successful?
E1E2: B7       [145]    	OR	A
E1E3: C2FBE1   [155|155]	JP	NZ,RDSEQ3	;no, error.
E1E6: CD77DC   [17]     RDSEQ2:	CALL	COMBLK		;ok. compute block number to read.
E1E9: CD84DC   [34]     	CALL	CHKBLK		;check it. Within bounds?
E1EC: CAFBE1   [44|44]  	JP	Z,RDSEQ3	;no, error.
E1EF: CD8ADC   [61]     	CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
E1F2: CDD1DB   [78]     	CALL	TRKSEC1		;set the track and sector for this block #.
E1F5: CDB2DB   [95]     	CALL	DOREAD		;and read it.
E1F8: C3D2DC   [105]    	JP	SETNREC		;and set the next record to be accessed.
                        ;
                        ;   Read error occured. Set status and return.
                        ;
E1FB: C305DB   [10]     RDSEQ3:	JP	IOERR1
                        ;
                        ;   Write the next sequential record.
                        ;
E1FE: 3E01     [ 7]     WTSEQ:	LD	A,1		;set sequential access mode.
E200: 32D5E5   [20]     	LD	(MODE),A
E203: 3E00     [ 7]     WTSEQ1:	LD	A,0		;allow an addition empty extent to be opened.
E205: 32D3E5   [20]     	LD	(RDWRTFLG),A
E208: CD54DD   [37]     	CALL	CHKWPRT		;check write protect status.
E20B: 2A43DB   [53]     	LD	HL,(PARAMS)
E20E: CD47DD   [70]     	CALL	CKROF1		;check for read only file, (HL) already set to fcb.
E211: CDBBDC   [87]     	CALL	STRDATA		;put updated data into fcb.
E214: 3AE3E5   [100]    	LD	A,(SAVNREC)	;get record number to write.
E217: FE80     [107]    	CP	128		;within range?
E219: D205DB   [117|117]	JP	NC,IOERR1	;no, error(?).
E21C: CD77DC   [134]    	CALL	COMBLK		;compute block number.
E21F: CD84DC   [151]    	CALL	CHKBLK		;check number.
E222: 0E00     [158]    	LD	C,0		;is there one to write to?
E224: C26EE2   [168|168]	JP	NZ,WTSEQ6	;yes, go do it.
E227: CD3EDC   [185]    	CALL	GETBLOCK	;get next block number within fcb to use.
E22A: 32D7E5   [198]    	LD	(RELBLOCK),A	;and save.
E22D: 010000   [208]    	LD	BC,0		;start looking for space from the start
E230: B7       [212]    	OR	A		;if none allocated as yet.
E231: CA3BE2   [222|222]	JP	Z,WTSEQ2
E234: 4F       [226]    	LD	C,A		;extract previous block number from fcb
E235: 0B       [232]    	DEC	BC		;so we can be closest to it.
E236: CD5EDC   [249]    	CALL	EXTBLK
E239: 44       [253]    	LD	B,H
E23A: 4D       [257]    	LD	C,L
E23B: CDBEDF   [17]     WTSEQ2:	CALL	FNDSPACE	;find the next empty block nearest number (BC).
E23E: 7D       [21]     	LD	A,L		;check for a zero number.
E23F: B4       [25]     	OR	H
E240: C248E2   [35|35]  	JP	NZ,WTSEQ3
E243: 3E02     [42]     	LD	A,2		;no more space?
E245: C301DB   [52]     	JP	SETSTAT
E248: 22E5E5   [16]     WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access.
E24B: EB       [20]     	EX	DE,HL		;put block number into (DE).
E24C: 2A43DB   [36]     	LD	HL,(PARAMS)	;now we must update the fcb for this
E24F: 011000   [46]     	LD	BC,16		;newly allocated block.
E252: 09       [57]     	ADD	HL,BC
E253: 3ADDE5   [70]     	LD	A,(BIGDISK)	;8 or 16 bit block numbers?
E256: B7       [74]     	OR	A
E257: 3AD7E5   [87]     	LD	A,(RELBLOCK)	;(* update this entry *)
E25A: CA64E2   [97|97]  	JP	Z,WTSEQ4	;zero means 16 bit ones.
E25D: CD64DD   [114]    	CALL	ADDA2HL		;(HL)=(HL)+(A)
E260: 73       [121]    	LD	(HL),E		;store new block number.
E261: C36CE2   [131]    	JP	WTSEQ5
E264: 4F       [ 4]     WTSEQ4:	LD	C,A		;compute spot in this 16 bit table.
E265: 0600     [11]     	LD	B,0
E267: 09       [22]     	ADD	HL,BC
E268: 09       [33]     	ADD	HL,BC
E269: 73       [40]     	LD	(HL),E		;stuff block number (DE) there.
E26A: 23       [46]     	INC	HL
E26B: 72       [53]     	LD	(HL),D
E26C: 0E02     [ 7]     WTSEQ5:	LD	C,2		;set (C) to indicate writing to un-used disk space.
E26E: 3A45DB   [13]     WTSEQ6:	LD	A,(STATUS)	;are we ok so far?
E271: B7       [17]     	OR	A
E272: C0       [22|28]  	RET	NZ
E273: C5       [33]     	PUSH	BC		;yes, save write flag for bios (register C).
E274: CD8ADC   [50]     	CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
E277: 3AD5E5   [63]     	LD	A,(MODE)	;get access mode flag (1=sequential,
E27A: 3D       [67]     	DEC	A		;0=random, 2=special?).
E27B: 3D       [71]     	DEC	A
E27C: C2BBE2   [81|81]  	JP	NZ,WTSEQ9
                        ;
                        ;   Special random i/o from function #40. Maybe for M/PM, but the
                        ; current block, if it has not been written to, will be zeroed
                        ; out and then written (reason?).
                        ;
E27F: C1       [91]     	POP	BC
E280: C5       [102]    	PUSH	BC
E281: 79       [106]    	LD	A,C		;get write status flag (2=writing unused space).
E282: 3D       [110]    	DEC	A
E283: 3D       [114]    	DEC	A
E284: C2BBE2   [124|124]	JP	NZ,WTSEQ9
E287: E5       [135]    	PUSH	HL
E288: 2AB9E5   [151]    	LD	HL,(DIRBUF)	;zero out the directory buffer.
E28B: 57       [155]    	LD	D,A		;note that (A) is zero here.
E28C: 77       [ 7]     WTSEQ7:	LD	(HL),A
E28D: 23       [13]     	INC	HL
E28E: 14       [17]     	INC	D		;do 128 bytes.
E28F: F28CE2   [27|27]  	JP	P,WTSEQ7
E292: CDE0DD   [44]     	CALL	DIRDMA		;tell the bios the dma address for directory access.
E295: 2AE7E5   [60]     	LD	HL,(LOGSECT)	;get sector that starts current block.
E298: 0E02     [67]     	LD	C,2		;set 'writing to unused space' flag.
E29A: 22E5E5   [16]     WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write.
E29D: C5       [27]     	PUSH	BC
E29E: CDD1DB   [44]     	CALL	TRKSEC1		;determine its track and sector numbers.
E2A1: C1       [54]     	POP	BC
E2A2: CDB8DB   [71]     	CALL	DOWRITE		;now write out 128 bytes of zeros.
E2A5: 2AE5E5   [87]     	LD	HL,(BLKNMBR)	;get sector number.
E2A8: 0E00     [94]     	LD	C,0		;set normal write flag.
E2AA: 3AC4E5   [107]    	LD	A,(BLKMASK)	;determine if we have written the entire
E2AD: 47       [111]    	LD	B,A		;physical block.
E2AE: A5       [115]    	AND	L
E2AF: B8       [119]    	CP	B
E2B0: 23       [125]    	INC	HL		;prepare for the next one.
E2B1: C29AE2   [135|135]	JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written.
E2B4: E1       [145]    	POP	HL		;reset next sector number.
E2B5: 22E5E5   [161]    	LD	(BLKNMBR),HL
E2B8: CDDADD   [178]    	CALL	DEFDMA		;and reset dma address.
                        ;
                        ;   Normal disk write. Set the desired track and sector then
                        ; do the actual write.
                        ;
E2BB: CDD1DB   [17]     WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write.
E2BE: C1       [27]     	POP	BC		;get write status flag.
E2BF: C5       [38]     	PUSH	BC
E2C0: CDB8DB   [55]     	CALL	DOWRITE		;and write this out.
E2C3: C1       [65]     	POP	BC
E2C4: 3AE3E5   [78]     	LD	A,(SAVNREC)	;get number of records in file.
E2C7: 21E1E5   [88]     	LD	HL,SAVNXT	;get last record written.
E2CA: BE       [95]     	CP	(HL)
E2CB: DAD2E2   [105|105]	JP	C,WTSEQ10
E2CE: 77       [112]    	LD	(HL),A		;we have to update record count.
E2CF: 34       [123]    	INC	(HL)
E2D0: 0E02     [130]    	LD	C,2
                        ;
                        ;*   This area has been patched to correct disk update problem
                        ;* when using blocking and de-blocking in the BIOS.
                        ;
E2D2: 00       [ 4]     WTSEQ10:NOP			;was 'dcr c'
E2D3: 00       [ 8]     	NOP			;was 'dcr c'
E2D4: 210000   [18]     	LD	HL,0		;was 'jnz wtseq99'
                        ;
                        ; *   End of patch.
                        ;
E2D7: F5       [29]     	PUSH	AF
E2D8: CD69DD   [46]     	CALL	GETS2		;set 'extent written to' flag.
E2DB: E67F     [53]     	AND	7FH		;(* clear bit 7 *)
E2DD: 77       [60]     	LD	(HL),A
E2DE: F1       [70]     	POP	AF		;get record count for this extent.
E2DF: FE7F     [ 7]     WTSEQ99:CP	127		;is it full?
E2E1: C200E3   [17|17]  	JP	NZ,WTSEQ12
E2E4: 3AD5E5   [30]     	LD	A,(MODE)	;yes, are we in sequential mode?
E2E7: FE01     [37]     	CP	1
E2E9: C200E3   [47|47]  	JP	NZ,WTSEQ12
E2EC: CDD2DC   [64]     	CALL	SETNREC		;yes, set next record number.
E2EF: CD5AE1   [81]     	CALL	GETNEXT		;and get next empty space in directory.
E2F2: 2145DB   [91]     	LD	HL,STATUS	;ok?
E2F5: 7E       [98]     	LD	A,(HL)
E2F6: B7       [102]    	OR	A
E2F7: C2FEE2   [112|112]	JP	NZ,WTSEQ11
E2FA: 3D       [116]    	DEC	A		;yes, set record count to -1.
E2FB: 32E3E5   [129]    	LD	(SAVNREC),A
E2FE: 3600     [10]     WTSEQ11:LD	(HL),0		;clear status.
E300: C3D2DC   [10]     WTSEQ12:JP	SETNREC		;set next record to access.
                        ;
                        ;   For random i/o, set the fcb for the desired record number
                        ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
                        ; used as follows:
                        ;
                        ;       fcb+35            fcb+34            fcb+33
                        ;  |     'r-2'      |      'r-1'      |      'r-0'     |
                        ;  |7             0 | 7             0 | 7             0|
                        ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
                        ;  |    overflow   | | extra |  extent   |   record #  |
                        ;  | ______________| |_extent|__number___|_____________|
                        ;                     also 's2'
                        ;
                        ;   On entry, register (C) contains 0ffh if this is a read
                        ; and thus we can not access unwritten disk space. Otherwise,
                        ; another extent will be opened (for writing) if required.
                        ;
E303: AF       [ 4]     POSITION: XOR	A		;set random i/o flag.
E304: 32D5E5   [17]     	LD	(MODE),A
                        ;
                        ;   Special entry (function #40). M/PM ?
                        ;
E307: C5       [11]     POSITN1:PUSH	BC		;save read/write flag.
E308: 2A43DB   [27]     	LD	HL,(PARAMS)	;get address of fcb.
E30B: EB       [31]     	EX	DE,HL
E30C: 212100   [41]     	LD	HL,33		;now get byte 'r0'.
E30F: 19       [52]     	ADD	HL,DE
E310: 7E       [59]     	LD	A,(HL)
E311: E67F     [66]     	AND	7FH		;keep bits 0-6 for the record number to access.
E313: F5       [77]     	PUSH	AF
E314: 7E       [84]     	LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
E315: 17       [88]     	RLA	
E316: 23       [94]     	INC	HL
E317: 7E       [101]    	LD	A,(HL)
E318: 17       [105]    	RLA	
E319: E61F     [112]    	AND	1FH		;and save this in bits 0-4 of (C).
E31B: 4F       [116]    	LD	C,A		;this is the extent byte.
E31C: 7E       [123]    	LD	A,(HL)		;now get the extra extent byte.
E31D: 1F       [127]    	RRA	
E31E: 1F       [131]    	RRA	
E31F: 1F       [135]    	RRA	
E320: 1F       [139]    	RRA	
E321: E60F     [146]    	AND	0FH
E323: 47       [150]    	LD	B,A		;and save it in (B).
E324: F1       [160]    	POP	AF		;get record number back to (A).
E325: 23       [166]    	INC	HL		;check overflow byte 'r2'.
E326: 6E       [173]    	LD	L,(HL)
E327: 2C       [177]    	INC	L
E328: 2D       [181]    	DEC	L
E329: 2E06     [188]    	LD	L,6		;prepare for error.
E32B: C28BE3   [198|198]	JP	NZ,POSITN5	;out of disk space error.
E32E: 212000   [208]    	LD	HL,32		;store record number into fcb.
E331: 19       [219]    	ADD	HL,DE
E332: 77       [226]    	LD	(HL),A
E333: 210C00   [236]    	LD	HL,12		;and now check the extent byte.
E336: 19       [247]    	ADD	HL,DE
E337: 79       [251]    	LD	A,C
E338: 96       [258]    	SUB	(HL)		;same extent as before?
E339: C247E3   [268|268]	JP	NZ,POSITN2
E33C: 210E00   [278]    	LD	HL,14		;yes, check extra extent byte 's2' also.
E33F: 19       [289]    	ADD	HL,DE
E340: 78       [293]    	LD	A,B
E341: 96       [300]    	SUB	(HL)
E342: E67F     [307]    	AND	7FH
E344: CA7FE3   [317|317]	JP	Z,POSITN3	;same, we are almost done then.
                        ;
                        ;  Get here when another extent is required.
                        ;
E347: C5       [11]     POSITN2:PUSH	BC
E348: D5       [22]     	PUSH	DE
E349: CDA2E0   [39]     	CALL	CLOSEIT		;close current extent.
E34C: D1       [49]     	POP	DE
E34D: C1       [59]     	POP	BC
E34E: 2E03     [66]     	LD	L,3		;prepare for error.
E350: 3A45DB   [79]     	LD	A,(STATUS)
E353: 3C       [83]     	INC	A
E354: CA84E3   [93|93]  	JP	Z,POSITN4	;close error.
E357: 210C00   [103]    	LD	HL,12		;put desired extent into fcb now.
E35A: 19       [114]    	ADD	HL,DE
E35B: 71       [121]    	LD	(HL),C
E35C: 210E00   [131]    	LD	HL,14		;and store extra extent byte 's2'.
E35F: 19       [142]    	ADD	HL,DE
E360: 70       [149]    	LD	(HL),B
E361: CD51E0   [166]    	CALL	OPENIT		;try and get this extent.
E364: 3A45DB   [179]    	LD	A,(STATUS)	;was it there?
E367: 3C       [183]    	INC	A
E368: C27FE3   [193|193]	JP	NZ,POSITN3
E36B: C1       [203]    	POP	BC		;no. can we create a new one (writing?).
E36C: C5       [214]    	PUSH	BC
E36D: 2E04     [221]    	LD	L,4		;prepare for error.
E36F: 0C       [225]    	INC	C
E370: CA84E3   [235|235]	JP	Z,POSITN4	;nope, reading unwritten space error.
E373: CD24E1   [252]    	CALL	GETEMPTY	;yes we can, try to find space.
E376: 2E05     [259]    	LD	L,5		;prepare for error.
E378: 3A45DB   [272]    	LD	A,(STATUS)
E37B: 3C       [276]    	INC	A
E37C: CA84E3   [286|286]	JP	Z,POSITN4	;out of space?
                        ;
                        ;   Normal return location. Clear error code and return.
                        ;
E37F: C1       [10]     POSITN3:POP	BC		;restore stack.
E380: AF       [14]     	XOR	A		;and clear error code byte.
E381: C301DB   [24]     	JP	SETSTAT
                        ;
                        ;   Error. Set the 's2' byte to indicate this (why?).
                        ;
E384: E5       [11]     POSITN4:PUSH	HL
E385: CD69DD   [28]     	CALL	GETS2
E388: 36C0     [38]     	LD	(HL),0C0H
E38A: E1       [48]     	POP	HL
                        ;
                        ;   Return with error code (presently in L).
                        ;
E38B: C1       [10]     POSITN5:POP	BC
E38C: 7D       [14]     	LD	A,L		;get error code.
E38D: 3245DB   [27]     	LD	(STATUS),A
E390: C378DD   [37]     	JP	SETS2B7
                        ;
                        ;   Read a random record.
                        ;
E393: 0EFF     [ 7]     READRAN:LD	C,0FFH		;set 'read' status.
E395: CD03E3   [24]     	CALL	POSITION	;position the file to proper record.
E398: CCC1E1   [34|41]  	CALL	Z,RDSEQ1	;and read it as usual (if no errors).
E39B: C9       [44]     	RET	
                        ;
                        ;   Write to a random record.
                        ;
E39C: 0E00     [ 7]     WRITERAN: LD	C,0		;set 'writing' flag.
E39E: CD03E3   [24]     	CALL	POSITION	;position the file to proper record.
E3A1: CC03E2   [34|41]  	CALL	Z,WTSEQ1	;and write as usual (if no errors).
E3A4: C9       [44]     	RET	
                        ;
                        ;   Compute the random record number. Enter with (HL) pointing
                        ; to a fcb an (DE) contains a relative location of a record
                        ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
                        ; byte, and (A) the 'r2' byte.
                        ;
                        ;   On return, the zero flag is set if the record is within
                        ; bounds. Otherwise, an overflow occured.
                        ;
E3A5: EB       [ 4]     COMPRAND: EX	DE,HL		;save fcb pointer in (DE).
E3A6: 19       [15]     	ADD	HL,DE		;compute relative position of record #.
E3A7: 4E       [22]     	LD	C,(HL)		;get record number into (BC).
E3A8: 0600     [29]     	LD	B,0
E3AA: 210C00   [39]     	LD	HL,12		;now get extent.
E3AD: 19       [50]     	ADD	HL,DE
E3AE: 7E       [57]     	LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
E3AF: 0F       [61]     	RRCA			;move lower bit into bit 7.
E3B0: E680     [68]     	AND	80H		;and ignore all other bits.
E3B2: 81       [72]     	ADD	A,C		;add to our record number.
E3B3: 4F       [76]     	LD	C,A
E3B4: 3E00     [83]     	LD	A,0		;take care of any carry.
E3B6: 88       [87]     	ADC	A,B
E3B7: 47       [91]     	LD	B,A
E3B8: 7E       [98]     	LD	A,(HL)		;now get the upper bits of extent into
E3B9: 0F       [102]    	RRCA			;bit positions 0-3.
E3BA: E60F     [109]    	AND	0FH		;and ignore all others.
E3BC: 80       [113]    	ADD	A,B		;add this in to 'r1' byte.
E3BD: 47       [117]    	LD	B,A
E3BE: 210E00   [127]    	LD	HL,14		;get the 's2' byte (extra extent).
E3C1: 19       [138]    	ADD	HL,DE
E3C2: 7E       [145]    	LD	A,(HL)
E3C3: 87       [149]    	ADD	A,A		;and shift it left 4 bits (bits 4-7).
E3C4: 87       [153]    	ADD	A,A
E3C5: 87       [157]    	ADD	A,A
E3C6: 87       [161]    	ADD	A,A
E3C7: F5       [172]    	PUSH	AF		;save carry flag (bit 0 of flag byte).
E3C8: 80       [176]    	ADD	A,B		;now add extra extent into 'r1'.
E3C9: 47       [180]    	LD	B,A
E3CA: F5       [191]    	PUSH	AF		;and save carry (overflow byte 'r2').
E3CB: E1       [201]    	POP	HL		;bit 0 of (L) is the overflow indicator.
E3CC: 7D       [205]    	LD	A,L
E3CD: E1       [215]    	POP	HL		;and same for first carry flag.
E3CE: B5       [219]    	OR	L		;either one of these set?
E3CF: E601     [226]    	AND	01H		;only check the carry flags.
E3D1: C9       [236]    	RET	
                        ;
                        ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
                        ; reflect the last record used for a random (or other) file.
                        ; This reads the directory and looks at all extents computing
                        ; the largerst record number for each and keeping the maximum
                        ; value only. Then 'r0', 'r1', and 'r2' will reflect this
                        ; maximum record number. This is used to compute the space used
                        ; by a random file.
                        ;
E3D2: 0E0C     [ 7]     RANSIZE:LD	C,12		;look thru directory for first entry with
E3D4: CD18DF   [24]     	CALL	FINDFST		;this name.
E3D7: 2A43DB   [40]     	LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
E3DA: 112100   [50]     	LD	DE,33
E3DD: 19       [61]     	ADD	HL,DE
E3DE: E5       [72]     	PUSH	HL
E3DF: 72       [79]     	LD	(HL),D		;note that (D)=0.
E3E0: 23       [85]     	INC	HL
E3E1: 72       [92]     	LD	(HL),D
E3E2: 23       [98]     	INC	HL
E3E3: 72       [105]    	LD	(HL),D
E3E4: CDF5DD   [17]     RANSIZ1:CALL	CKFILPOS	;is there an extent to process?
E3E7: CA0CE4   [27|27]  	JP	Z,RANSIZ3	;no, we are done.
E3EA: CD5EDD   [44]     	CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
E3ED: 110F00   [54]     	LD	DE,15		;point to last record in extent.
E3F0: CDA5E3   [71]     	CALL	COMPRAND	;and compute random parameters.
E3F3: E1       [81]     	POP	HL
E3F4: E5       [92]     	PUSH	HL		;now check these values against those
E3F5: 5F       [96]     	LD	E,A		;already in fcb.
E3F6: 79       [100]    	LD	A,C		;the carry flag will be set if those
E3F7: 96       [107]    	SUB	(HL)		;in the fcb represent a larger size than
E3F8: 23       [113]    	INC	HL		;this extent does.
E3F9: 78       [117]    	LD	A,B
E3FA: 9E       [124]    	SBC	A,(HL)
E3FB: 23       [130]    	INC	HL
E3FC: 7B       [134]    	LD	A,E
E3FD: 9E       [141]    	SBC	A,(HL)
E3FE: DA06E4   [151|151]	JP	C,RANSIZ2
E401: 73       [158]    	LD	(HL),E		;we found a larger (in size) extent.
E402: 2B       [164]    	DEC	HL		;stuff these values into fcb.
E403: 70       [171]    	LD	(HL),B
E404: 2B       [177]    	DEC	HL
E405: 71       [184]    	LD	(HL),C
E406: CD2DDF   [17]     RANSIZ2:CALL	FINDNXT		;now get the next extent.
E409: C3E4E3   [27]     	JP	RANSIZ1		;continue til all done.
E40C: E1       [10]     RANSIZ3:POP	HL		;we are done, restore the stack and
E40D: C9       [20]     	RET			;return.
                        ;
                        ;   Function to return the random record position of a given
                        ; file which has been read in sequential mode up to now.
                        ;
E40E: 2A43DB   [16]     SETRAN:	LD	HL,(PARAMS)	;point to fcb.
E411: 112000   [26]     	LD	DE,32		;and to last used record.
E414: CDA5E3   [43]     	CALL	COMPRAND	;compute random position.
E417: 212100   [53]     	LD	HL,33		;now stuff these values into fcb.
E41A: 19       [64]     	ADD	HL,DE
E41B: 71       [71]     	LD	(HL),C		;move 'r0'.
E41C: 23       [77]     	INC	HL
E41D: 70       [84]     	LD	(HL),B		;and 'r1'.
E41E: 23       [90]     	INC	HL
E41F: 77       [97]     	LD	(HL),A		;and lastly 'r2'.
E420: C9       [107]    	RET	
                        ;
                        ;   This routine select the drive specified in (ACTIVE) and
                        ; update the login vector and bitmap table if this drive was
                        ; not already active.
                        ;
E421: 2AAFE5   [16]     LOGINDRV: LD	HL,(LOGIN)	;get the login vector.
E424: 3A42DB   [29]     	LD	A,(ACTIVE)	;get the default drive.
E427: 4F       [33]     	LD	C,A
E428: CDEADC   [50]     	CALL	SHIFTR		;position active bit for this drive
E42B: E5       [61]     	PUSH	HL		;into bit 0.
E42C: EB       [65]     	EX	DE,HL
E42D: CD59DB   [82]     	CALL	SELECT		;select this drive.
E430: E1       [92]     	POP	HL
E431: CC47DB   [102|109]	CALL	Z,SLCTERR	;valid drive?
E434: 7D       [106]    	LD	A,L		;is this a newly activated drive?
E435: 1F       [110]    	RRA	
E436: D8       [115|121]	RET	C
E437: 2AAFE5   [131]    	LD	HL,(LOGIN)	;yes, update the login vector.
E43A: 4D       [135]    	LD	C,L
E43B: 44       [139]    	LD	B,H
E43C: CD0BDD   [156]    	CALL	SETBIT
E43F: 22AFE5   [172]    	LD	(LOGIN),HL	;and save.
E442: C3A3DE   [182]    	JP	BITMAP		;now update the bitmap.
                        ;
                        ;   Function to set the active disk number.
                        ;
E445: 3AD6E5   [13]     SETDSK:	LD	A,(EPARAM)	;get parameter passed and see if this
E448: 2142DB   [23]     	LD	HL,ACTIVE	;represents a change in drives.
E44B: BE       [30]     	CP	(HL)
E44C: C8       [35|41]  	RET	Z
E44D: 77       [42]     	LD	(HL),A		;yes it does, log it in.
E44E: C321E4   [52]     	JP	LOGINDRV
                        ;
                        ;   This is the 'auto disk select' routine. The firsst byte
                        ; of the fcb is examined for a drive specification. If non
                        ; zero then the drive will be selected and loged in.
                        ;
E451: 3EFF     [ 7]     AUTOSEL:LD	A,0FFH		;say 'auto-select activated'.
E453: 32DEE5   [20]     	LD	(AUTO),A
E456: 2A43DB   [36]     	LD	HL,(PARAMS)	;get drive specified.
E459: 7E       [43]     	LD	A,(HL)
E45A: E61F     [50]     	AND	1FH		;look at lower 5 bits.
E45C: 3D       [54]     	DEC	A		;adjust for (1=A, 2=B) etc.
E45D: 32D6E5   [67]     	LD	(EPARAM),A	;and save for the select routine.
E460: FE1E     [74]     	CP	1EH		;check for 'no change' condition.
E462: D275E4   [84|84]  	JP	NC,AUTOSL1	;yes, don't change.
E465: 3A42DB   [97]     	LD	A,(ACTIVE)	;we must change, save currently active
E468: 32DFE5   [110]    	LD	(OLDDRV),A	;drive.
E46B: 7E       [117]    	LD	A,(HL)		;and save first byte of fcb also.
E46C: 32E0E5   [130]    	LD	(AUTOFLAG),A	;this must be non-zero.
E46F: E6E0     [137]    	AND	0E0H		;whats this for (bits 6,7 are used for
E471: 77       [144]    	LD	(HL),A		;something)?
E472: CD45E4   [161]    	CALL	SETDSK		;select and log in this drive.
E475: 3A41DB   [13]     AUTOSL1:LD	A,(USERNO)	;move user number into fcb.
E478: 2A43DB   [29]     	LD	HL,(PARAMS)	;(* upper half of first byte *)
E47B: B6       [36]     	OR	(HL)
E47C: 77       [43]     	LD	(HL),A
E47D: C9       [53]     	RET			;and return (all done).
                        ;
                        ;   Function to return the current cp/m version number.
                        ;
E47E: 3E22     [ 7]     GETVER:	LD	A,022H		;version 2.2
E480: C301DB   [17]     	JP	SETSTAT
                        ;
                        ;   Function to reset the disk system.
                        ;
E483: 210000   [10]     RSTDSK:	LD	HL,0		;clear write protect status and log
E486: 22ADE5   [26]     	LD	(WRTPRT),HL	;in vector.
E489: 22AFE5   [42]     	LD	(LOGIN),HL
E48C: AF       [46]     	XOR	A		;select drive 'A'.
E48D: 3242DB   [59]     	LD	(ACTIVE),A
E490: 218000   [69]     	LD	HL,TBUFF	;setup default dma address.
E493: 22B1E5   [85]     	LD	(USERDMA),HL
E496: CDDADD   [102]    	CALL	DEFDMA
E499: C321E4   [112]    	JP	LOGINDRV	;now log in drive 'A'.
                        ;
                        ;   Function to open a specified file.
                        ;
E49C: CD72DD   [17]     OPENFIL:CALL	CLEARS2		;clear 's2' byte.
E49F: CD51E4   [34]     	CALL	AUTOSEL		;select proper disk.
E4A2: C351E0   [44]     	JP	OPENIT		;and open the file.
                        ;
                        ;   Function to close a specified file.
                        ;
E4A5: CD51E4   [17]     CLOSEFIL: CALL	AUTOSEL		;select proper disk.
E4A8: C3A2E0   [27]     	JP	CLOSEIT		;and close the file.
                        ;
                        ;   Function to return the first occurence of a specified file
                        ; name. If the first byte of the fcb is '?' then the name will
                        ; not be checked (get the first entry no matter what).
                        ;
E4AB: 0E00     [ 7]     GETFST:	LD	C,0		;prepare for special search.
E4AD: EB       [11]     	EX	DE,HL
E4AE: 7E       [18]     	LD	A,(HL)		;is first byte a '?'?
E4AF: FE3F     [25]     	CP	'?'
E4B1: CAC2E4   [35|35]  	JP	Z,GETFST1	;yes, just get very first entry (zero length match).
E4B4: CDA6DC   [52]     	CALL	SETEXT		;get the extension byte from fcb.
E4B7: 7E       [59]     	LD	A,(HL)		;is it '?'? if yes, then we want
E4B8: FE3F     [66]     	CP	'?'		;an entry with a specific 's2' byte.
E4BA: C472DD   [76|83]  	CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte.
E4BD: CD51E4   [93]     	CALL	AUTOSEL		;select proper drive.
E4C0: 0E0F     [100]    	LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded).
E4C2: CD18DF   [17]     GETFST1:CALL	FINDFST		;find an entry and then move it into
E4C5: C3E9DD   [27]     	JP	MOVEDIR		;the users dma space.
                        ;
                        ;   Function to return the next occurence of a file name.
                        ;
E4C8: 2AD9E5   [16]     GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no
E4CB: 2243DB   [32]     	LD	(PARAMS),HL	;other dbos calls are allowed.
E4CE: CD51E4   [49]     	CALL	AUTOSEL		;no error will be returned, but the
E4D1: CD2DDF   [66]     	CALL	FINDNXT		;results will be wrong.
E4D4: C3E9DD   [76]     	JP	MOVEDIR
                        ;
                        ;   Function to delete a file by name.
                        ;
E4D7: CD51E4   [17]     DELFILE:CALL	AUTOSEL		;select proper drive.
E4DA: CD9CDF   [34]     	CALL	ERAFILE		;erase the file.
E4DD: C301DF   [44]     	JP	STSTATUS	;set status and return.
                        ;
                        ;   Function to execute a sequential read of the specified
                        ; record number.
                        ;
E4E0: CD51E4   [17]     READSEQ:CALL	AUTOSEL		;select proper drive then read.
E4E3: C3BCE1   [27]     	JP	RDSEQ
                        ;
                        ;   Function to write the net sequential record.
                        ;
E4E6: CD51E4   [17]     WRTSEQ:	CALL	AUTOSEL		;select proper drive then write.
E4E9: C3FEE1   [27]     	JP	WTSEQ
                        ;
                        ;   Create a file function.
                        ;
E4EC: CD72DD   [17]     FCREATE:CALL	CLEARS2		;clear the 's2' byte on all creates.
E4EF: CD51E4   [34]     	CALL	AUTOSEL		;select proper drive and get the next
E4F2: C324E1   [44]     	JP	GETEMPTY	;empty directory space.
                        ;
                        ;   Function to rename a file.
                        ;
E4F5: CD51E4   [17]     RENFILE:CALL	AUTOSEL		;select proper drive and then switch
E4F8: CD16E0   [34]     	CALL	CHGNAMES	;file names.
E4FB: C301DF   [44]     	JP	STSTATUS
                        ;
                        ;   Function to return the login vector.
                        ;
E4FE: 2AAFE5   [16]     GETLOG:	LD	HL,(LOGIN)
E501: C329E5   [26]     	JP	GETPRM1
                        ;
                        ;   Function to return the current disk assignment.
                        ;
E504: 3A42DB   [13]     GETCRNT:LD	A,(ACTIVE)
E507: C301DB   [23]     	JP	SETSTAT
                        ;
                        ;   Function to set the dma address.
                        ;
E50A: EB       [ 4]     PUTDMA:	EX	DE,HL
E50B: 22B1E5   [20]     	LD	(USERDMA),HL	;save in our space and then get to
E50E: C3DADD   [30]     	JP	DEFDMA		;the bios with this also.
                        ;
                        ;   Function to return the allocation vector.
                        ;
E511: 2ABFE5   [16]     GETALOC:LD	HL,(ALOCVECT)
E514: C329E5   [26]     	JP	GETPRM1
                        ;
                        ;   Function to return the read-only status vector.
                        ;
E517: 2AADE5   [16]     GETROV:	LD	HL,(WRTPRT)
E51A: C329E5   [26]     	JP	GETPRM1
                        ;
                        ;   Function to set the file attributes (read-only, system).
                        ;
E51D: CD51E4   [17]     SETATTR:CALL	AUTOSEL		;select proper drive then save attributes.
E520: CD3BE0   [34]     	CALL	SAVEATTR
E523: C301DF   [44]     	JP	STSTATUS
                        ;
                        ;   Function to return the address of the disk parameter block
                        ; for the current drive.
                        ;
E526: 2ABBE5   [16]     GETPARM:LD	HL,(DISKPB)
E529: 2245DB   [16]     GETPRM1:LD	(STATUS),HL
E52C: C9       [26]     	RET	
                        ;
                        ;   Function to get or set the user number. If (E) was (FF)
                        ; then this is a request to return the current user number.
                        ; Else set the user number from (E).
                        ;
E52D: 3AD6E5   [13]     GETUSER:LD	A,(EPARAM)	;get parameter.
E530: FEFF     [20]     	CP	0FFH		;get user number?
E532: C23BE5   [30|30]  	JP	NZ,SETUSER
E535: 3A41DB   [43]     	LD	A,(USERNO)	;yes, just do it.
E538: C301DB   [53]     	JP	SETSTAT
E53B: E61F     [ 7]     SETUSER:AND	1FH		;no, we should set it instead. keep low
E53D: 3241DB   [20]     	LD	(USERNO),A	;bits (0-4) only.
E540: C9       [30]     	RET	
                        ;
                        ;   Function to read a random record from a file.
                        ;
E541: CD51E4   [17]     RDRANDOM: CALL	AUTOSEL		;select proper drive and read.
E544: C393E3   [27]     	JP	READRAN
                        ;
                        ;   Function to compute the file size for random files.
                        ;
E547: CD51E4   [17]     WTRANDOM: CALL	AUTOSEL		;select proper drive and write.
E54A: C39CE3   [27]     	JP	WRITERAN
                        ;
                        ;   Function to compute the size of a random file.
                        ;
E54D: CD51E4   [17]     FILESIZE: CALL	AUTOSEL		;select proper drive and check file length
E550: C3D2E3   [27]     	JP	RANSIZE
                        ;
                        ;   Function #37. This allows a program to log off any drives.
                        ; On entry, set (DE) to contain a word with bits set for those
                        ; drives that are to be logged off. The log-in vector and the
                        ; write protect vector will be updated. This must be a M/PM
                        ; special function.
                        ;
E553: 2A43DB   [16]     LOGOFF:	LD	HL,(PARAMS)	;get drives to log off.
E556: 7D       [20]     	LD	A,L		;for each bit that is set, we want
E557: 2F       [24]     	CPL			;to clear that bit in (LOGIN)
E558: 5F       [28]     	LD	E,A		;and (WRTPRT).
E559: 7C       [32]     	LD	A,H
E55A: 2F       [36]     	CPL	
E55B: 2AAFE5   [52]     	LD	HL,(LOGIN)	;reset the login vector.
E55E: A4       [56]     	AND	H
E55F: 57       [60]     	LD	D,A
E560: 7D       [64]     	LD	A,L
E561: A3       [68]     	AND	E
E562: 5F       [72]     	LD	E,A
E563: 2AADE5   [88]     	LD	HL,(WRTPRT)
E566: EB       [92]     	EX	DE,HL
E567: 22AFE5   [108]    	LD	(LOGIN),HL	;and save.
E56A: 7D       [112]    	LD	A,L		;now do the write protect vector.
E56B: A3       [116]    	AND	E
E56C: 6F       [120]    	LD	L,A
E56D: 7C       [124]    	LD	A,H
E56E: A2       [128]    	AND	D
E56F: 67       [132]    	LD	H,A
E570: 22ADE5   [148]    	LD	(WRTPRT),HL	;and save. all done.
E573: C9       [158]    	RET	
                        ;
                        ;   Get here to return to the user.
                        ;
E574: 3ADEE5   [13]     GOBACK:	LD	A,(AUTO)	;was auto select activated?
E577: B7       [17]     	OR	A
E578: CA91E5   [27|27]  	JP	Z,GOBACK1
E57B: 2A43DB   [43]     	LD	HL,(PARAMS)	;yes, but was a change made?
E57E: 3600     [53]     	LD	(HL),0		;(* reset first byte of fcb *)
E580: 3AE0E5   [66]     	LD	A,(AUTOFLAG)
E583: B7       [70]     	OR	A
E584: CA91E5   [80|80]  	JP	Z,GOBACK1
E587: 77       [87]     	LD	(HL),A		;yes, reset first byte properly.
E588: 3ADFE5   [100]    	LD	A,(OLDDRV)	;and get the old drive and select it.
E58B: 32D6E5   [113]    	LD	(EPARAM),A
E58E: CD45E4   [130]    	CALL	SETDSK
E591: 2A0FDB   [16]     GOBACK1:LD	HL,(USRSTACK)	;reset the users stack pointer.
E594: F9       [22]     	LD	SP,HL
E595: 2A45DB   [38]     	LD	HL,(STATUS)	;get return status.
E598: 7D       [42]     	LD	A,L		;force version 1.4 compatability.
E599: 44       [46]     	LD	B,H
E59A: C9       [56]     	RET			;and go back to user.
                        ;
                        ;   Function #40. This is a special entry to do random i/o.
                        ; For the case where we are writing to unused disk space, this
                        ; space will be zeroed out first. This must be a M/PM special
                        ; purpose function, because why would any normal program even
                        ; care about the previous contents of a sector about to be
                        ; written over.
                        ;
E59B: CD51E4   [17]     WTSPECL:CALL	AUTOSEL		;select proper drive.
E59E: 3E02     [24]     	LD	A,2		;use special write mode.
E5A0: 32D5E5   [37]     	LD	(MODE),A
E5A3: 0E00     [44]     	LD	C,0		;set write indicator.
E5A5: CD07E3   [61]     	CALL	POSITN1		;position the file.
E5A8: CC03E2   [71|78]  	CALL	Z,WTSEQ1	;and write (if no errors).
E5AB: C9       [81]     	RET	
                        ;
                        ;**************************************************************
                        ;*
                        ;*     BDOS data storage pool.
                        ;*
                        ;**************************************************************
                        ;
E5AC: E5                EMPTYFCB: .DB	0E5H		;empty directory segment indicator.
E5AD: 0000              WRTPRT:	.DW	0		;write protect status for all 16 drives.
E5AF: 0000              LOGIN:	.DW	0		;drive active word (1 bit per drive).
E5B1: 8000              USERDMA:.DW	080H		;user's dma address (defaults to 80h).
                        ;
                        ;   Scratch areas from parameter block.
                        ;
E5B3: 0000              SCRATCH1: .DW	0		;relative position within dir segment for file (0-3).
E5B5: 0000              SCRATCH2: .DW	0		;last selected track number.
E5B7: 0000              SCRATCH3: .DW	0		;last selected sector number.
                        ;
                        ;   Disk storage areas from parameter block.
                        ;
E5B9: 0000              DIRBUF:	.DW	0		;address of directory buffer to use.
E5BB: 0000              DISKPB:	.DW	0		;contains address of disk parameter block.
E5BD: 0000              CHKVECT:.DW	0		;address of check vector.
E5BF: 0000              ALOCVECT: .DW	0		;address of allocation vector (bit map).
                        ;
                        ;   Parameter block returned from the bios.
                        ;
E5C1: 0000              SECTORS:.DW	0		;sectors per track from bios.
E5C3: 00                BLKSHFT:.DB	0		;block shift.
E5C4: 00                BLKMASK:.DB	0		;block mask.
E5C5: 00                EXTMASK:.DB	0		;extent mask.
E5C6: 0000              DSKSIZE:.DW	0		;disk size from bios (number of blocks-1).
E5C8: 0000              DIRSIZE:.DW	0		;directory size.
E5CA: 0000              ALLOC0:	.DW	0		;storage for first bytes of bit map (dir space used).
E5CC: 0000              ALLOC1:	.DW	0
E5CE: 0000              OFFSET:	.DW	0		;first usable track number.
E5D0: 0000              XLATE:	.DW	0		;sector translation table address.
                        ;
                        ;
E5D2: 00                CLOSEFLG: .DB	0		;close flag (=0ffh is extent written ok).
E5D3: 00                RDWRTFLG: .DB	0		;read/write flag (0ffh=read, 0=write).
E5D4: 00                FNDSTAT:.DB	0		;filename found status (0=found first entry).
E5D5: 00                MODE:	.DB	0		;I/o mode select (0=random, 1=sequential, 2=special random).
E5D6: 00                EPARAM:	.DB	0		;storage for register (E) on entry to bdos.
E5D7: 00                RELBLOCK: .DB	0		;relative position within fcb of block number written.
E5D8: 00                COUNTER:.DB	0		;byte counter for directory name searches.
E5D9: 00000000          SAVEFCB:.DW	0,0		;save space for address of fcb (for directory searches).
E5DD: 00                BIGDISK:.DB	0		;if =0 then disk is > 256 blocks long.
E5DE: 00                AUTO:	.DB	0		;if non-zero, then auto select activated.
E5DF: 00                OLDDRV:	.DB	0		;on auto select, storage for previous drive.
E5E0: 00                AUTOFLAG: .DB	0		;if non-zero, then auto select changed drives.
E5E1: 00                SAVNXT:	.DB	0		;storage for next record number to access.
E5E2: 00                SAVEXT:	.DB	0		;storage for extent number of file.
E5E3: 0000              SAVNREC:.DW	0		;storage for number of records in file.
E5E5: 0000              BLKNMBR:.DW	0		;block number (physical sector) used within a file or logical sect
E5E7: 0000              LOGSECT:.DW	0		;starting logical (128 byte) sector of block (physical sector).
E5E9: 00                FCBPOS:	.DB	0		;relative position within buffer for fcb of file of interest.
E5EA: 0000              FILEPOS:.DW	0		;files position within directory (0 to max entries -1).
                        ;
                        ;   Disk directory buffer checksum bytes. One for each of the
                        ; 16 possible drives.
                        ;
E5EC: 00000000          CKSUMTBL: .DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E5F0: 00...             
                        ;
                        ;   Extra space ?
                        ;
E5FC: 00000000          	.DB	0,0,0,0
                        ;
                        ;**************************************************************
                        ;*
                        ;*        B I O S   J U M P   T A B L E
                        ;*
                        ;**************************************************************
                        ;
E600: C30000   [10]     BOOT:	JP	0		;NOTE WE USE FAKE DESTINATIONS
E603: C30000   [10]     WBOOT:	JP	0
E606: C30000   [10]     CONST:	JP	0
E609: C30000   [10]     CONIN:	JP	0
E60C: C30000   [10]     CONOUT:	JP	0
E60F: C30000   [10]     LIST:	JP	0
E612: C30000   [10]     PUNCH:	JP	0
E615: C30000   [10]     READER:	JP	0
E618: C30000   [10]     HOME:	JP	0
E61B: C30000   [10]     SELDSK:	JP	0
E61E: C30000   [10]     SETTRK:	JP	0
E621: C30000   [10]     SETSEC:	JP	0
E624: C30000   [10]     SETDMA:	JP	0
E627: C30000   [10]     READ:	JP	0
E62A: C30000   [10]     WRITE:	JP	0
E62D: C30000   [10]     PRSTAT:	JP	0
E630: C30000   [10]     SECTRN:	JP	0
                        ;
                        ;*
                        ;******************   E N D   O F   C P / M   *****************
                        ;*
                        
                        	.END


; +++ segments +++

#CODE          = $D000 = 53248,  size = $1633 =  5683

; +++ global symbols +++

ACTIVE   = $DB42 = 56130          cpm22.asm:1710
ADDA2HL  = $DD64 = 56676          cpm22.asm:2139
ADDHL    = $D259 = 53849          cpm22.asm:430
ALLOC0   = $E5CA = 58826          cpm22.asm:3687
ALLOC1   = $E5CC = 58828          cpm22.asm:3688
ALOCVECT = $E5BF = 58815          cpm22.asm:3677
AUTO     = $E5DE = 58846          cpm22.asm:3702
AUTOFLAG = $E5E0 = 58848          cpm22.asm:3704
AUTOSEL  = $E451 = 58449          cpm22.asm:3417
AUTOSL1  = $E475 = 58485          cpm22.asm:3433
BACKUP   = $D9A4 = 55716          cpm22.asm:1470
BACKUP1  = $D9AC = 55724          cpm22.asm:1473
BADLOAD  = $D77A = 55162          cpm22.asm:1194
BADSCTR  = $D809 = 55305          cpm22.asm:1254
BADSEC   = $D8CA = 55498          cpm22.asm:1325
BADSEL   = $D8D5 = 55509          cpm22.asm:1326
BADSLCT  = $D80B = 55307          cpm22.asm:1255
BATCH    = $D7AB = 55211          cpm22.asm:1218
BATCHFCB = $D7AC = 55212          cpm22.asm:1219
BDOSDRV  = $D8C6 = 55494          cpm22.asm:1324
BDOSERR  = $D8BA = 55482          cpm22.asm:1323
BIGDISK  = $E5DD = 58845          cpm22.asm:3701
BITMAP   = $DEA3 = 56995          cpm22.asm:2432
BITMAP1  = $DEB1 = 57009          cpm22.asm:2447
BITMAP2  = $DED2 = 57042          cpm22.asm:2468
BITMAP3  = $DEF6 = 57078          cpm22.asm:2485
BLKMASK  = $E5C4 = 58820          cpm22.asm:3683
BLKNMBR  = $E5E5 = 58853          cpm22.asm:3708
BLKSHFT  = $E5C3 = 58819          cpm22.asm:3682
BOOT     = $E600 = 58880          cpm22.asm:3728 (unused)
BS       = $0008 =     8          cpm22.asm:26
CBASE    = $D000 = 53248          cpm22.asm:43
CCPSTACK = $D7AB = 55211          cpm22.asm:1214
CDRIVE   = $D7EF = 55279          cpm22.asm:1231
CHARBUF  = $DB0E = 56078          cpm22.asm:1699
CHECK    = $D230 = 53808          cpm22.asm:396
CHECKDIR = $DD9E = 56734          cpm22.asm:2212
CHECKSUM = $DCF7 = 56567          cpm22.asm:2051
CHGDRV   = $D7F0 = 55280          cpm22.asm:1232
CHGNAM1  = $E027 = 57383          cpm22.asm:2724
CHGNAMES = $E016 = 57366          cpm22.asm:2716
CHKBLK   = $DC84 = 56452          cpm22.asm:1958
CHKCHAR  = $D914 = 55572          cpm22.asm:1367
CHKCON   = $D1C2 = 53698          cpm22.asm:321
CHKDIR1  = $DDC4 = 56772          cpm22.asm:2232
CHKNMBR  = $DD8C = 56716          cpm22.asm:2185
CHKROFL  = $DD44 = 56644          cpm22.asm:2115
CHKSUM1  = $DCFD = 56573          cpm22.asm:2054
CHKVECT  = $E5BD = 58813          cpm22.asm:3676
CHKWPRT  = $DD54 = 56660          cpm22.asm:2126
CKBITMAP = $DE35 = 56885          cpm22.asm:2326
CKBMAP1  = $DE56 = 56918          cpm22.asm:2361
CKCON1   = $D942 = 55618          cpm22.asm:1397
CKCON2   = $D945 = 55621          cpm22.asm:1398
CKCONSOL = $D923 = 55587          cpm22.asm:1383
CKFILPOS = $DDF5 = 56821          cpm22.asm:2275
CKROF1   = $DD47 = 56647          cpm22.asm:2116
CKSUMTBL = $E5EC = 58860          cpm22.asm:3716
CLEARBUF = $D358 = 54104          cpm22.asm:596
CLEARS2  = $DD72 = 56690          cpm22.asm:2156
CLOSE    = $D0DA = 53466          cpm22.asm:136
CLOSEFIL = $E4A5 = 58533          cpm22.asm:3464
CLOSEFLG = $E5D2 = 58834          cpm22.asm:3693
CLOSEIT  = $E0A2 = 57506          cpm22.asm:2810
CLOSEIT1 = $E0CD = 57549          cpm22.asm:2830
CLOSEIT2 = $E0DB = 57563          cpm22.asm:2838
CLOSEIT3 = $E0E1 = 57569          cpm22.asm:2842
CLOSEIT4 = $E0E8 = 57576          cpm22.asm:2845
CLOSEIT5 = $E0FD = 57597          cpm22.asm:2858
CLOSEIT6 = $E117 = 57623          cpm22.asm:2876
CLOSEIT7 = $E11F = 57631          cpm22.asm:2879
CMDADR   = $D3C1 = 54209          cpm22.asm:668
CMDTBL   = $D310 = 54032          cpm22.asm:550
CMMND1   = $D382 = 54146          cpm22.asm:629
CMMND2   = $D398 = 54168          cpm22.asm:640
CNTRLC   = $0003 =     3          cpm22.asm:24
CNTRLE   = $0005 =     5          cpm22.asm:25
CNTRLP   = $0010 =    16          cpm22.asm:31
CNTRLR   = $0012 =    18          cpm22.asm:32
CNTRLS   = $0013 =    19          cpm22.asm:33
CNTRLU   = $0015 =    21          cpm22.asm:34
CNTRLX   = $0018 =    24          cpm22.asm:35
CNTRLZ   = $001A =    26          cpm22.asm:36
COMBLK   = $DC77 = 56439          cpm22.asm:1949
COMFILE  = $D783 = 55171          cpm22.asm:1196
COMMAND  = $D35C = 54108          cpm22.asm:606
COMPRAND = $E3A5 = 58277          cpm22.asm:3283
CONIN    = $E609 = 58889          cpm22.asm:3731
CONOUT   = $E60C = 58892          cpm22.asm:3732
CONST    = $E606 = 58886          cpm22.asm:3730
CONVERT  = $D260 = 53856          cpm22.asm:444
CONVFST  = $D25E = 53854          cpm22.asm:438
CONVRT1  = $D289 = 53897          cpm22.asm:467
CONVRT2  = $D290 = 53904          cpm22.asm:470
CONVRT3  = $D296 = 53910          cpm22.asm:477
CONVRT4  = $D298 = 53912          cpm22.asm:478
CONVRT5  = $D2A9 = 53929          cpm22.asm:485
CONVRT6  = $D2AB = 53931          cpm22.asm:487
CONVRT7  = $D2AF = 53935          cpm22.asm:489
CONVRT8  = $D2B9 = 53945          cpm22.asm:493
COUNTER  = $E5D8 = 58840          cpm22.asm:3699
CR       = $000D =    13          cpm22.asm:30
CREATE   = $D109 = 53513          cpm22.asm:186
CRLF     = $D098 = 53400          cpm22.asm:78
CURPOS   = $DB0C = 56076          cpm22.asm:1697
DE2HL    = $DB4F = 56143          cpm22.asm:1728
DE2HL1   = $DB50 = 56144          cpm22.asm:1729
DECODE   = $D3F8 = 54264          cpm22.asm:697
DECODE1  = $D408 = 54280          cpm22.asm:703
DECODE2  = $D42A = 54314          cpm22.asm:723 (unused)
DECODE3  = $D433 = 54323          cpm22.asm:728
DECODE4  = $D43A = 54330          cpm22.asm:732 (unused)
DEFDMA   = $DDDA = 56794          cpm22.asm:2250
DEL      = $007F =   127          cpm22.asm:37
DELBATCH = $D1DD = 53725          cpm22.asm:346
DELETE   = $D0EF = 53487          cpm22.asm:157
DELFILE  = $E4D7 = 58583          cpm22.asm:3495
DIRBUF   = $E5B9 = 58809          cpm22.asm:3674
DIRC1    = $DAE0 = 56032          cpm22.asm:1655
DIRCIO   = $DAD4 = 56020          cpm22.asm:1649
DIRDMA   = $DDE0 = 56800          cpm22.asm:2255
DIRDMA1  = $DDE3 = 56803          cpm22.asm:2260
DIRECT   = $D477 = 54391          cpm22.asm:794
DIRECT1  = $D488 = 54408          cpm22.asm:801
DIRECT2  = $D48F = 54415          cpm22.asm:805
DIRECT3  = $D498 = 54424          cpm22.asm:809
DIRECT4  = $D4CC = 54476          cpm22.asm:836
DIRECT5  = $D4D4 = 54484          cpm22.asm:839
DIRECT6  = $D4D9 = 54489          cpm22.asm:841
DIRECT7  = $D50E = 54542          cpm22.asm:865
DIRECT8  = $D50F = 54543          cpm22.asm:866
DIRECT9  = $D51B = 54555          cpm22.asm:870
DIRREAD  = $DDD4 = 56788          cpm22.asm:2245
DIRSIZE  = $E5C8 = 58824          cpm22.asm:3686
DIRWRITE = $DDC6 = 56774          cpm22.asm:2237
DISKPB   = $E5BB = 58811          cpm22.asm:3675
DISKRO   = $D8E1 = 55521          cpm22.asm:1328
DMASET   = $D1D8 = 53720          cpm22.asm:341
DOREAD   = $DBB2 = 56242          cpm22.asm:1799
DOWRITE  = $DBB8 = 56248          cpm22.asm:1804
DRECT63  = $D4F7 = 54519          cpm22.asm:855
DRECT65  = $D4F9 = 54521          cpm22.asm:856
DSELECT  = $D454 = 54356          cpm22.asm:764
DSKSEL   = $D0BD = 53437          cpm22.asm:110
DSKSIZE  = $E5C6 = 58822          cpm22.asm:3685
EMPTYFCB = $E5AC = 58796          cpm22.asm:3661
ENTRY    = $0005 =     5          cpm22.asm:17
ENTRY1   = $D0C3 = 53443          cpm22.asm:117
ENTRY2   = $D0F4 = 53492          cpm22.asm:163
EPARAM   = $E5D6 = 58838          cpm22.asm:3697
ERAFIL1  = $DFA4 = 57252          cpm22.asm:2602
ERAFILE  = $DF9C = 57244          cpm22.asm:2599
ERASE    = $D51F = 54559          cpm22.asm:879
ERASE1   = $D542 = 54594          cpm22.asm:894
ERROR1   = $D899 = 55449          cpm22.asm:1306
ERROR2   = $D8A5 = 55461          cpm22.asm:1312
ERROR3   = $D8AB = 55467          cpm22.asm:1315
ERROR4   = $D8B1 = 55473          cpm22.asm:1318
ERROR5   = $D8B4 = 55476          cpm22.asm:1320
EXISTS   = $D682 = 54914          cpm22.asm:1058
EXTBLK   = $DC5E = 56414          cpm22.asm:1930
EXTBLK1  = $DC71 = 56433          cpm22.asm:1940
EXTMASK  = $E5C5 = 58821          cpm22.asm:3684
EXTRACT  = $D44B = 54347          cpm22.asm:754
FBASE    = $D806 = 55302          cpm22.asm:1250 (unused)
FBASE1   = $D811 = 55313          cpm22.asm:1262
FCB      = $D7CD = 55245          cpm22.asm:1225
FCB2HL   = $DD5E = 56670          cpm22.asm:2134
FCBPOS   = $E5E9 = 58857          cpm22.asm:3710
FCBSET   = $DFFD = 57341          cpm22.asm:2694
FCREATE  = $E4EC = 58604          cpm22.asm:3512
FF       = $000C =    12          cpm22.asm:29 (unused)
FILEPOS  = $E5EA = 58858          cpm22.asm:3711
FILERO   = $D8DC = 55516          cpm22.asm:1327
FILESIZE = $E54D = 58701          cpm22.asm:3586
FINDFST  = $DF18 = 57112          cpm22.asm:2519
FINDNXT  = $DF2D = 57133          cpm22.asm:2532
FNDNXT1  = $DF4A = 57162          cpm22.asm:2545
FNDNXT2  = $DF53 = 57171          cpm22.asm:2549
FNDNXT3  = $DF73 = 57203          cpm22.asm:2565
FNDNXT4  = $DF7C = 57212          cpm22.asm:2574
FNDNXT5  = $DF83 = 57219          cpm22.asm:2579
FNDNXT6  = $DF94 = 57236          cpm22.asm:2592
FNDSPA1  = $DFC0 = 57280          cpm22.asm:2632
FNDSPA2  = $DFD1 = 57297          cpm22.asm:2655
FNDSPA3  = $DFEC = 57324          cpm22.asm:2676
FNDSPA4  = $DFF4 = 57332          cpm22.asm:2686
FNDSPACE = $DFBE = 57278          cpm22.asm:2626
FNDSTAT  = $E5D4 = 58836          cpm22.asm:3695
FUNCTNS  = $D847 = 55367          cpm22.asm:1297
GETALOC  = $E511 = 58641          cpm22.asm:3540
GETBACK  = $D786 = 55174          cpm22.asm:1202
GETBACK1 = $D789 = 55177          cpm22.asm:1203
GETBLK1  = $DC45 = 56389          cpm22.asm:1908
GETBLK2  = $DC53 = 56403          cpm22.asm:1917
GETBLK3  = $DC5C = 56412          cpm22.asm:1922
GETBLOCK = $DC3E = 56382          cpm22.asm:1905
GETCHAR  = $D8FB = 55547          cpm22.asm:1345
GETCON   = $DAC8 = 56008          cpm22.asm:1637
GETCRNT  = $E504 = 58628          cpm22.asm:3529
GETCSTS  = $DAFE = 56062          cpm22.asm:1682
GETDSK   = $D1D0 = 53712          cpm22.asm:332
GETECHO  = $D906 = 55558          cpm22.asm:1354
GETEMPTY = $E124 = 57636          cpm22.asm:2886
GETEXT   = $D2C0 = 53952          cpm22.asm:500
GETEXT1  = $D2C8 = 53960          cpm22.asm:504
GETEXT2  = $D2D9 = 53977          cpm22.asm:511
GETEXT3  = $D2DB = 53979          cpm22.asm:513
GETEXT4  = $D2DF = 53983          cpm22.asm:515
GETEXT5  = $D2E9 = 53993          cpm22.asm:519
GETEXT6  = $D2F0 = 54000          cpm22.asm:523
GETEXT7  = $D2F2 = 54002          cpm22.asm:524
GETEXT8  = $D301 = 54017          cpm22.asm:536
GETEXT9  = $D309 = 54025          cpm22.asm:541
GETFST   = $E4AB = 58539          cpm22.asm:3471
GETFST1  = $E4C2 = 58562          cpm22.asm:3482
GETINP   = $D139 = 53561          cpm22.asm:237
GETINP1  = $D196 = 53654          cpm22.asm:293
GETINP2  = $D1A7 = 53671          cpm22.asm:302
GETINP3  = $D1AB = 53675          cpm22.asm:304
GETINP4  = $D1BA = 53690          cpm22.asm:313
GETIOB   = $DAED = 56045          cpm22.asm:1663
GETLOG   = $E4FE = 58622          cpm22.asm:3524
GETMT1   = $E146 = 57670          cpm22.asm:2902
GETNEXT  = $E15A = 57690          cpm22.asm:2916
GETNXT   = $E4C8 = 58568          cpm22.asm:3487
GETPARM  = $E526 = 58662          cpm22.asm:3557
GETPRM1  = $E529 = 58665          cpm22.asm:3558
GETRDR   = $DACE = 56014          cpm22.asm:1642
GETROV   = $E517 = 58647          cpm22.asm:3545
GETS2    = $DD69 = 56681          cpm22.asm:2148
GETSETUC = $D115 = 53525          cpm22.asm:202
GETUSER  = $E52D = 58669          cpm22.asm:3565
GETUSR   = $D113 = 53523          cpm22.asm:197
GETVER   = $E47E = 58494          cpm22.asm:3441
GETWPRT  = $DD1E = 56606          cpm22.asm:2088
GOBACK   = $E574 = 58740          cpm22.asm:3621
GOBACK1  = $E591 = 58769          cpm22.asm:3633
GTNEXT1  = $E183 = 57731          cpm22.asm:2936
GTNEXT2  = $E18E = 57742          cpm22.asm:2945
GTNEXT3  = $E1AC = 57772          cpm22.asm:2956
GTNEXT4  = $E1AF = 57775          cpm22.asm:2957
GTNEXT5  = $E1B6 = 57782          cpm22.asm:2964
HALT     = $D3CF = 54223          cpm22.asm:673
HL2DE    = $D442 = 54338          cpm22.asm:744
HOME     = $E618 = 58904          cpm22.asm:3736
HOMEDRV  = $DBA1 = 56225          cpm22.asm:1785
INBUFF   = $D006 = 53254          cpm22.asm:50
INPOINT  = $D088 = 53384          cpm22.asm:58
IOBYTE   = $0003 =     3          cpm22.asm:15
IOERR1   = $DB05 = 56069          cpm22.asm:1692
IORET    = $DBBB = 56251          cpm22.asm:1805
JUMPHL   = $DB4A = 56138          cpm22.asm:1720
LF       = $000A =    10          cpm22.asm:28
LIST     = $E60F = 58895          cpm22.asm:3733
LOGICAL  = $DC8A = 56458          cpm22.asm:1969
LOGICL1  = $DC90 = 56464          cpm22.asm:1971
LOGIN    = $E5AF = 58799          cpm22.asm:3663
LOGINDRV = $E421 = 58401          cpm22.asm:3385
LOGOFF   = $E553 = 58707          cpm22.asm:3595
LOGSECT  = $E5E7 = 58855          cpm22.asm:3709
MODE     = $E5D5 = 58837          cpm22.asm:3696
MOREFLS  = $DD7F = 56703          cpm22.asm:2172
MOVE3    = $D440 = 54336          cpm22.asm:740
MOVECD   = $D129 = 53545          cpm22.asm:219
MOVEDIR  = $DDE9 = 56809          cpm22.asm:2267
MOVEWORD = $E094 = 57492          cpm22.asm:2793
NAMEPNT  = $D08A = 53386          cpm22.asm:59
NBYTES   = $D7F1 = 55281          cpm22.asm:1233
NEWLINE  = $D9B1 = 55729          cpm22.asm:1479
NEWLN1   = $D9B9 = 55737          cpm22.asm:1482
NFUNCTS  = $0029 =    41          cpm22.asm:1295
NOFILE   = $D3F0 = 54256          cpm22.asm:689
NONBLANK = $D24F = 53839          cpm22.asm:420
NONE     = $D3EA = 54250          cpm22.asm:687
NOSPACE  = $D607 = 54791          cpm22.asm:999
NUMCMDS  = $0006 =     6          cpm22.asm:549
NXENT1   = $DE19 = 56857          cpm22.asm:2305
NXENT2   = $DE20 = 56864          cpm22.asm:2308
NXENTRY  = $DE05 = 56837          cpm22.asm:2297
OFFSET   = $E5CE = 58830          cpm22.asm:3689
OLDDRV   = $E5DF = 58847          cpm22.asm:3703
OPEN     = $D0CB = 53451          cpm22.asm:124
OPENFCB  = $D0D0 = 53456          cpm22.asm:129
OPENFIL  = $E49C = 58524          cpm22.asm:3458
OPENIT   = $E051 = 57425          cpm22.asm:2750
OPENIT1  = $E05A = 57434          cpm22.asm:2754
OPENIT2  = $E08B = 57483          cpm22.asm:2782
OUTCHAR  = $D948 = 55624          cpm22.asm:1405
OUTCHR1  = $D962 = 55650          cpm22.asm:1419
OUTCHR2  = $D979 = 55673          cpm22.asm:1435
OUTCON   = $D990 = 55696          cpm22.asm:1456
OUTCON1  = $D996 = 55702          cpm22.asm:1459
OUTCRLF  = $D9C9 = 55753          cpm22.asm:1492
OUTFLAG  = $DB0A = 56074          cpm22.asm:1695
PARAMS   = $DB43 = 56131          cpm22.asm:1711
PATTRN1  = $D328 = 54056          cpm22.asm:560
PATTRN2  = $D800 = 55296          cpm22.asm:1242
PLINE    = $D0A7 = 53415          cpm22.asm:91
PLINE2   = $D0AC = 53420          cpm22.asm:94
POSITION = $E303 = 58115          cpm22.asm:3160
POSITN1  = $E307 = 58119          cpm22.asm:3165
POSITN2  = $E347 = 58183          cpm22.asm:3211
POSITN3  = $E37F = 58239          cpm22.asm:3243
POSITN4  = $E384 = 58244          cpm22.asm:3249
POSITN5  = $E38B = 58251          cpm22.asm:3256
PRINT    = $D08C = 53388          cpm22.asm:64
PRINTB   = $D092 = 53394          cpm22.asm:70
PRSTAT   = $E62D = 58925          cpm22.asm:3743 (unused)
PRTERR   = $D8E5 = 55525          cpm22.asm:1332
PRTFLAG  = $DB0D = 56077          cpm22.asm:1698
PRTMESG  = $D9D3 = 55763          cpm22.asm:1499
PRTSTR   = $DAF8 = 56056          cpm22.asm:1675
PUNCH    = $E612 = 58898          cpm22.asm:3734
PUTDMA   = $E50A = 58634          cpm22.asm:3534
RANSIZ1  = $E3E4 = 58340          cpm22.asm:3339
RANSIZ2  = $E406 = 58374          cpm22.asm:3361
RANSIZ3  = $E40C = 58380          cpm22.asm:3363
RANSIZE  = $E3D2 = 58322          cpm22.asm:3328
RDBUF1   = $D9EF = 55791          cpm22.asm:1518
RDBUF10  = $DA70 = 55920          cpm22.asm:1580
RDBUF11  = $DA78 = 55928          cpm22.asm:1586
RDBUF12  = $DA8A = 55946          cpm22.asm:1598
RDBUF13  = $DA99 = 55961          cpm22.asm:1605
RDBUF14  = $DAA6 = 55974          cpm22.asm:1613
RDBUF15  = $DAA9 = 55977          cpm22.asm:1616
RDBUF16  = $DABD = 55997          cpm22.asm:1628
RDBUF17  = $DAC1 = 56001          cpm22.asm:1630
RDBUF2   = $D9F1 = 55793          cpm22.asm:1520
RDBUF3   = $DA16 = 55830          cpm22.asm:1537
RDBUF4   = $DA26 = 55846          cpm22.asm:1546
RDBUF5   = $DA37 = 55863          cpm22.asm:1554
RDBUF6   = $DA48 = 55880          cpm22.asm:1563
RDBUF7   = $DA4E = 55886          cpm22.asm:1566
RDBUF8   = $DA5F = 55903          cpm22.asm:1573
RDBUF9   = $DA6B = 55915          cpm22.asm:1578
RDBUFF   = $D9E1 = 55777          cpm22.asm:1511
RDERR    = $D3DF = 54239          cpm22.asm:682
RDERROR  = $D3D9 = 54233          cpm22.asm:680
RDRANDOM = $E541 = 58689          cpm22.asm:3576
RDREC    = $D0F9 = 53497          cpm22.asm:170
RDSEQ    = $E1BC = 57788          cpm22.asm:2969
RDSEQ1   = $E1C1 = 57793          cpm22.asm:2971
RDSEQ2   = $E1E6 = 57830          cpm22.asm:2986
RDSEQ3   = $E1FB = 57851          cpm22.asm:2996
RDWRTFLG = $E5D3 = 58835          cpm22.asm:3694
READ     = $E627 = 58919          cpm22.asm:3741
READER   = $E615 = 58901          cpm22.asm:3735
READFCB  = $D0FE = 53502          cpm22.asm:175
READRAN  = $E393 = 58259          cpm22.asm:3263
READSEQ  = $E4E0 = 58592          cpm22.asm:3502
RELBLOCK = $E5D7 = 58839          cpm22.asm:3698
RENAM    = $D10E = 53518          cpm22.asm:192
RENAME   = $D610 = 54800          cpm22.asm:1008
RENAME1  = $D63F = 54847          cpm22.asm:1026
RENAME2  = $D659 = 54873          cpm22.asm:1040
RENAME3  = $D65E = 54878          cpm22.asm:1043 (unused)
RENAME4  = $D66D = 54893          cpm22.asm:1051
RENAME5  = $D673 = 54899          cpm22.asm:1053
RENAME6  = $D679 = 54905          cpm22.asm:1055
RENFILE  = $E4F5 = 58613          cpm22.asm:3518
RESDSK   = $D0B8 = 53432          cpm22.asm:105
RESETDR  = $D466 = 54374          cpm22.asm:778
RODISK   = $D80D = 55309          cpm22.asm:1256
ROFILE   = $D80F = 55311          cpm22.asm:1257
RSTDSK   = $E483 = 58499          cpm22.asm:3446
RTN      = $DB04 = 56068          cpm22.asm:1688
RTNCODE  = $D7EE = 55278          cpm22.asm:1230
SAMEXT   = $DF07 = 57095          cpm22.asm:2500
SAVATR1  = $E040 = 57408          cpm22.asm:2740
SAVE     = $D5AD = 54701          cpm22.asm:952
SAVE1    = $D5D4 = 54740          cpm22.asm:970
SAVE2    = $D5F1 = 54769          cpm22.asm:988
SAVE3    = $D5FB = 54779          cpm22.asm:995
SAVE4    = $D601 = 54785          cpm22.asm:997
SAVEATTR = $E03B = 57403          cpm22.asm:2738
SAVEFCB  = $E5D9 = 58841          cpm22.asm:3700
SAVEXT   = $E5E2 = 58850          cpm22.asm:3706
SAVNREC  = $E5E3 = 58851          cpm22.asm:3707
SAVNXT   = $E5E1 = 58849          cpm22.asm:3705
SCRATCH1 = $E5B3 = 58803          cpm22.asm:3668
SCRATCH2 = $E5B5 = 58805          cpm22.asm:3669
SCRATCH3 = $E5B7 = 58807          cpm22.asm:3670
SEARCH   = $D32E = 54062          cpm22.asm:568
SEARCH1  = $D333 = 54067          cpm22.asm:570
SEARCH2  = $D33C = 54076          cpm22.asm:575
SEARCH3  = $D34F = 54095          cpm22.asm:587
SEARCH4  = $D354 = 54100          cpm22.asm:590
SECTORS  = $E5C1 = 58817          cpm22.asm:3681
SECTRN   = $E630 = 58928          cpm22.asm:3744
SELDSK   = $E61B = 58907          cpm22.asm:3737
SELECT   = $DB59 = 56153          cpm22.asm:1739
SELECT1  = $DB9D = 56221          cpm22.asm:1779
SETATTR  = $E51D = 58653          cpm22.asm:3550
SETBIT   = $DD0B = 56587          cpm22.asm:2071
SETCDRV  = $D11A = 53530          cpm22.asm:207
SETDIR   = $DD9C = 56732          cpm22.asm:2205
SETDMA   = $E624 = 58916          cpm22.asm:3740
SETDSK   = $E445 = 58437          cpm22.asm:3406
SETEXT   = $DCA6 = 56486          cpm22.asm:1986
SETFILE  = $DE6B = 56939          cpm22.asm:2390
SETFL1   = $DE75 = 56949          cpm22.asm:2395
SETFL2   = $DE88 = 56968          cpm22.asm:2407
SETFL3   = $DE8E = 56974          cpm22.asm:2413
SETFL4   = $DE9D = 56989          cpm22.asm:2422
SETHLDE  = $DCAE = 56494          cpm22.asm:1994
SETIOB   = $DAF3 = 56051          cpm22.asm:1668
SETNREC  = $DCD2 = 56530          cpm22.asm:2020
SETRAN   = $E40E = 58382          cpm22.asm:3369
SETS2B7  = $DD78 = 56696          cpm22.asm:2162
SETSEC   = $E621 = 58913          cpm22.asm:3739
SETSTAT  = $DB01 = 56065          cpm22.asm:1687
SETTRK   = $E61E = 58910          cpm22.asm:3738
SETUSER  = $E53B = 58683          cpm22.asm:3570
SHIFTL   = $DD04 = 56580          cpm22.asm:2062
SHIFTL1  = $DD05 = 56581          cpm22.asm:2063
SHIFTR   = $DCEA = 56554          cpm22.asm:2036
SHIFTR1  = $DCEB = 56555          cpm22.asm:2037
SHOWIT   = $D97F = 55679          cpm22.asm:1443
SLCTERR  = $DB47 = 56135          cpm22.asm:1716
SPACE    = $D0A2 = 53410          cpm22.asm:85
SRCHFCB  = $D0E9 = 53481          cpm22.asm:152
SRCHFST  = $D0DF = 53471          cpm22.asm:142
SRCHNXT  = $D0E4 = 53476          cpm22.asm:147
STARTING = $DB0B = 56075          cpm22.asm:1696
STATUS   = $DB45 = 56133          cpm22.asm:1712
STBITMAP = $DE5C = 56924          cpm22.asm:2370
STBMAP1  = $DE64 = 56932          cpm22.asm:2381
STDDMA   = $D1D5 = 53717          cpm22.asm:337
STFILPOS = $DDFE = 56830          cpm22.asm:2285
STKAREA  = $DB41 = 56129          cpm22.asm:1707
STNREC1  = $DCDE = 56542          cpm22.asm:2025
STRDATA  = $DCBB = 56507          cpm22.asm:2004
STSTATUS = $DF01 = 57089          cpm22.asm:2492
SUBHL    = $DD95 = 56725          cpm22.asm:2195
SYNERR   = $D209 = 53769          cpm22.asm:375
SYNERR1  = $D20F = 53775          cpm22.asm:377
SYNERR2  = $D222 = 53794          cpm22.asm:387
TAB      = $0009 =     9          cpm22.asm:27
TBASE    = $0100 =   256          cpm22.asm:20
TBUFF    = $0080 =   128          cpm22.asm:19
TDRIVE   = $0004 =     4          cpm22.asm:16
TFCB     = $005C =    92          cpm22.asm:18
TRKSEC   = $DBC3 = 56259          cpm22.asm:1813
TRKSEC1  = $DBD1 = 56273          cpm22.asm:1822
TRKSEC2  = $DBE4 = 56292          cpm22.asm:1835
TRKSEC3  = $DBFA = 56314          cpm22.asm:1851
TRKSEC4  = $DC0F = 56335          cpm22.asm:1868
TYPE     = $D55D = 54621          cpm22.asm:909
TYPE1    = $D574 = 54644          cpm22.asm:917
TYPE2    = $D577 = 54647          cpm22.asm:918 (unused)
TYPE3    = $D587 = 54663          cpm22.asm:927
TYPE4    = $D5A0 = 54688          cpm22.asm:940
TYPE5    = $D5A7 = 54695          cpm22.asm:943
UNKNOWN  = $D6A5 = 54949          cpm22.asm:1083
UNKWN0   = $D771 = 55153          cpm22.asm:1191
UNKWN1   = $D6C4 = 54980          cpm22.asm:1098
UNKWN2   = $D6CD = 54989          cpm22.asm:1102 (unused)
UNKWN3   = $D6E1 = 55009          cpm22.asm:1113
UNKWN4   = $D701 = 55041          cpm22.asm:1132
UNKWN5   = $D730 = 55088          cpm22.asm:1153
UNKWN6   = $D73E = 55102          cpm22.asm:1163
UNKWN7   = $D743 = 55107          cpm22.asm:1165
UNKWN8   = $D74F = 55119          cpm22.asm:1173
UNKWN9   = $D76B = 55147          cpm22.asm:1189
UPDATE   = $E001 = 57345          cpm22.asm:2701
UPDATE1  = $E010 = 57360          cpm22.asm:2709
UPPER    = $D130 = 53552          cpm22.asm:226
USER     = $D68E = 54926          cpm22.asm:1067
USERDMA  = $E5B1 = 58801          cpm22.asm:3664
USERNO   = $DB41 = 56129          cpm22.asm:1709
USRSTACK = $DB0F = 56079          cpm22.asm:1703
VERIFY   = $D1F5 = 53749          cpm22.asm:361
VERIFY1  = $D1FD = 53757          cpm22.asm:364
WBOOT    = $E603 = 58883          cpm22.asm:3729
WRITE    = $E62A = 58922          cpm22.asm:3742
WRITERAN = $E39C = 58268          cpm22.asm:3270
WRTPRT   = $E5AD = 58797          cpm22.asm:3662
WRTPRTD  = $DD2C = 56620          cpm22.asm:2098
WRTREC   = $D104 = 53508          cpm22.asm:181
WRTSEQ   = $E4E6 = 58598          cpm22.asm:3507
WTRANDOM = $E547 = 58695          cpm22.asm:3581
WTSEQ    = $E1FE = 57854          cpm22.asm:3000
WTSEQ1   = $E203 = 57859          cpm22.asm:3002
WTSEQ10  = $E2D2 = 58066          cpm22.asm:3117
WTSEQ11  = $E2FE = 58110          cpm22.asm:3141
WTSEQ12  = $E300 = 58112          cpm22.asm:3142
WTSEQ2   = $E23B = 57915          cpm22.asm:3025
WTSEQ3   = $E248 = 57928          cpm22.asm:3031
WTSEQ4   = $E264 = 57956          cpm22.asm:3043
WTSEQ5   = $E26C = 57964          cpm22.asm:3050
WTSEQ6   = $E26E = 57966          cpm22.asm:3051
WTSEQ7   = $E28C = 57996          cpm22.asm:3074
WTSEQ8   = $E29A = 58010          cpm22.asm:3081
WTSEQ9   = $E2BB = 58043          cpm22.asm:3101
WTSEQ99  = $E2DF = 58079          cpm22.asm:3128 (unused)
WTSPECL  = $E59B = 58779          cpm22.asm:3647
XLATE    = $E5D0 = 58832          cpm22.asm:3690
YESNO    = $D552 = 54610          cpm22.asm:900
_end     = $E633 = 58931          cpm22.asm:40 (unused)
_size    = $1633 =  5683          cpm22.asm:40 (unused)


total time: 0.0344 sec.
no errors
